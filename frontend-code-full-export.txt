================================================
AURORANOTES FRONTEND - FULL CODE EXPORT
Generated: Mon Dec 15 13:42:00 EST 2025
For External Code Review
================================================


================================================
FILE: package.json
================================================

{
  "name": "auroranotes-web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.561.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.1.18",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "tailwindcss": "^4.1.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


================================================
FILE: tsconfig.json
================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================
FILE: tsconfig.app.json
================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


================================================
FILE: tsconfig.node.json
================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================
FILE: vite.config.ts
================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
})


================================================
FILE: eslint.config.js
================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


================================================
FILE: firebase.json
================================================

{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "/assets/**",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      },
      {
        "source": "**/*.@(js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ]
  }
}



================================================
FILE: index.html
================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#7c3aed" />
    <title>AuroraNotes – AI-Powered Notes</title>

    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================
FILE: src/App.tsx
================================================

/**
 * AuroraNotes AI - Main App Entry
 *
 * This is a thin composition layer that sets up providers and renders the shell.
 * All UI logic has been moved to components.
 */

import './styles/app.css';
import { ThemeProvider } from './lib/ThemeContext';
import { ToastProvider } from './components/common/Toast';
import { AppShell } from './components/layout/AppShell';

export default function App() {
  return (
    <ThemeProvider>
      <ToastProvider>
        <AppShell />
      </ToastProvider>
    </ThemeProvider>
  );
}


================================================
FILE: src/components/chat/ChatMessage.tsx
================================================

/**
 * ChatMessage component
 * Renders chat messages with inline citation chips and sources summary
 */

import { BookOpen, AlertCircle } from 'lucide-react';
import type { ChatMessage as ChatMessageType, Citation } from '../../lib/types';
import { parseCitations, getReferencedCitations } from '../../lib/citations';
import { CitationChip, SourceChip } from './CitationChip';

interface ChatMessageProps {
  message: ChatMessageType;
  onCitationClick: (citation: Citation) => void;
  activeCid?: string | null;
}

export function ChatMessage({ message, onCitationClick, activeCid }: ChatMessageProps) {
  const isUser = message.role === 'user';
  const segments = parseCitations(message.content, message.citations);
  const referencedCitations = getReferencedCitations(message.content, message.citations);

  return (
    <div className={`chat-message ${isUser ? 'user' : 'assistant'}`}>
      <div className="chat-bubble">
        {segments.map((segment, i) => {
          if (segment.type === 'citation' && segment.citation) {
            return (
              <CitationChip
                key={`${segment.citation.cid}-${i}`}
                citation={segment.citation}
                onClick={onCitationClick}
              />
            );
          }
          return <span key={i}>{segment.content}</span>;
        })}
      </div>

      {/* Sources summary for assistant messages */}
      {!isUser && referencedCitations.length > 0 && (
        <div className="chat-sources-summary">
          <span className="sources-label">
            <BookOpen size={14} />
            Sources:
          </span>
          <div className="sources-chips">
            {referencedCitations.map((citation) => (
              <SourceChip
                key={citation.cid}
                cid={citation.cid}
                onClick={() => onCitationClick(citation)}
                isActive={citation.cid === activeCid}
              />
            ))}
          </div>
          {message.meta?.retrieval?.timeMs && (
            <span className="retrieval-time" title={`Retrieved using ${message.meta.retrieval.strategy}`}>
              {message.meta.retrieval.timeMs}ms
            </span>
          )}
        </div>
      )}
    </div>
  );
}

/**
 * Loading state message bubble with AI typing indicator
 */
export function ChatMessageLoading() {
  return (
    <div className="chat-message assistant animate-fade-in">
      <div className="chat-bubble chat-bubble-loading">
        <div className="ai-typing">
          <span></span>
          <span></span>
          <span></span>
        </div>
        <span className="text-muted">Searching your notes...</span>
      </div>
    </div>
  );
}

/**
 * Error state message with retry option
 */
interface ChatMessageErrorProps {
  error: string;
  onRetry?: () => void;
}

export function ChatMessageError({ error, onRetry }: ChatMessageErrorProps) {
  return (
    <div className="chat-message assistant">
      <div className="chat-bubble chat-bubble-error">
        <AlertCircle size={14} />
        <span>{error || 'Something went wrong. Please try again.'}</span>
        {onRetry && (
          <button className="btn btn-sm btn-ghost" onClick={onRetry}>
            Retry
          </button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/chat/ChatPanel.tsx
================================================

/**
 * ChatPanel component
 * RAG-powered chat with inline citations, sources panel, and note navigation
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { Sparkles, BookOpen, ArrowUp } from 'lucide-react';
import type { ChatMessage as ChatMessageType, Citation } from '../../lib/types';
import { sendChatMessage, ApiRequestError } from '../../lib/api';
import { useToast } from '../common/useToast';
import { ChatMessage, ChatMessageLoading } from './ChatMessage';
import { SourcesPanel } from './SourcesPanel';

interface ChatPanelProps {
  className?: string;
  onOpenNote?: (noteId: string, snippet?: string) => void;
}

const MAX_MESSAGE_LENGTH = 2000;

const SUGGESTIONS = [
  { label: 'Summarize', prompt: 'Summarize my recent notes from this week' },
  { label: 'Decisions', prompt: 'What decisions did I make recently?' },
  { label: 'Questions', prompt: 'What are my open questions or unresolved items?' },
  { label: 'Actions', prompt: 'List action items from my notes' },
];

export function ChatPanel({ className = '', onOpenNote }: ChatPanelProps) {
  const [messages, setMessages] = useState<ChatMessageType[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [showSources, setShowSources] = useState(false);
  const [activeCitations, setActiveCitations] = useState<Citation[]>([]);
  const [selectedCid, setSelectedCid] = useState<string | null>(null);
  const [rateLimitCountdown, setRateLimitCountdown] = useState<number | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const countdownRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const { showToast } = useToast();

  // Cleanup countdown interval on unmount
  useEffect(() => {
    return () => {
      if (countdownRef.current) {
        clearInterval(countdownRef.current);
      }
    };
  }, []);

  // Start rate limit countdown
  const startRateLimitCountdown = useCallback((ms: number) => {
    setRateLimitCountdown(Math.ceil(ms / 1000));

    if (countdownRef.current) {
      clearInterval(countdownRef.current);
    }

    countdownRef.current = setInterval(() => {
      setRateLimitCountdown(prev => {
        if (prev === null || prev <= 1) {
          if (countdownRef.current) {
            clearInterval(countdownRef.current);
            countdownRef.current = null;
          }
          return null;
        }
        return prev - 1;
      });
    }, 1000);
  }, []);

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, scrollToBottom]);

  // Collect all citations from messages for sources panel
  useEffect(() => {
    const allCitations: Citation[] = [];
    const seen = new Set<string>();

    for (const msg of messages) {
      if (msg.citations) {
        for (const c of msg.citations) {
          if (!seen.has(c.cid)) {
            seen.add(c.cid);
            allCitations.push(c);
          }
        }
      }
    }

    setActiveCitations(allCitations);
  }, [messages]);

  const handleSend = useCallback(async (text?: string) => {
    const messageText = (text || input).trim();
    if (!messageText || loading || rateLimitCountdown !== null) return;

    // Client-side validation: max 2000 chars
    if (messageText.length > MAX_MESSAGE_LENGTH) {
      showToast(`Message too long. Maximum ${MAX_MESSAGE_LENGTH} characters.`, 'error');
      return;
    }

    // Add user message
    const userMessage: ChatMessageType = {
      id: `user-${Date.now()}`,
      role: 'user',
      content: messageText,
      timestamp: new Date(),
    };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    try {
      const response = await sendChatMessage(messageText);

      // Add assistant message with citations and metadata
      const assistantMessage: ChatMessageType = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: response.answer,
        timestamp: new Date(),
        citations: response.citations,
        meta: response.meta,
      };
      setMessages(prev => [...prev, assistantMessage]);

      // Auto-show sources panel if there are citations
      if (response.citations && response.citations.length > 0) {
        setShowSources(true);
      }
    } catch (err) {
      let userErrorMessage = 'Sorry, I encountered an error. Please try again.';

      if (err instanceof ApiRequestError) {
        // Handle specific status codes
        if (err.status === 400) {
          userErrorMessage = err.message || 'Invalid request. Please check your message.';
        } else if (err.status === 401 || err.status === 403) {
          userErrorMessage = 'Authentication error. Please check your API key configuration.';
        } else if (err.status === 429) {
          // Rate limited - start countdown if retryAfterMs provided
          const retryMs = err.retryAfterMs || 60000; // Default to 60s if not provided
          startRateLimitCountdown(retryMs);
          userErrorMessage = `Too many requests. Please wait ${Math.ceil(retryMs / 1000)} seconds.`;
        } else if (err.status === 503) {
          userErrorMessage = 'Chat temporarily unavailable. Please try again later.';
        } else if (err.status && err.status >= 500) {
          userErrorMessage = 'The server is experiencing issues. Please try again in a few moments.';
        }

        showToast(err.message, 'error');
      } else {
        const errorMsg = err instanceof Error ? err.message : 'Failed to get response';
        showToast(errorMsg, 'error');
      }

      // Add error message to chat
      const errorMessage: ChatMessageType = {
        id: `error-${Date.now()}`,
        role: 'assistant',
        content: userErrorMessage,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
      inputRef.current?.focus();
    }
  }, [input, loading, rateLimitCountdown, showToast, startRateLimitCountdown]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  }, [handleSend]);

  const handleSuggestionClick = useCallback((prompt: string) => {
    handleSend(prompt);
  }, [handleSend]);

  const handleCitationClick = useCallback((citation: Citation) => {
    setSelectedCid(citation.cid);
    setShowSources(true);
  }, []);

  const handleOpenNote = useCallback((noteId: string) => {
    const citation = activeCitations.find(c => c.noteId === noteId);
    onOpenNote?.(noteId, citation?.snippet);
    setShowSources(false);
  }, [activeCitations, onOpenNote]);

  const hasCitations = activeCitations.length > 0;

  return (
    <div className={`panel ${className}`}>
      <div className="panel-header">
        <h2>
          <Sparkles size={16} />
          Ask Aurora
        </h2>
        <div className="header-actions-row">
          {hasCitations && (
            <button
              className={`btn btn-sm ${showSources ? 'btn-ai' : 'btn-ghost'}`}
              onClick={() => setShowSources(!showSources)}
              aria-label={showSources ? 'Hide sources' : 'Show sources'}
            >
              <BookOpen size={14} />
              {activeCitations.length} sources
            </button>
          )}
        </div>
      </div>

      <div className="panel-body chat-panel-body">
        <div className="chat-container">
          {/* Suggestion Chips */}
          {messages.length === 0 && (
            <div className="chat-suggestions stagger-children">
              {SUGGESTIONS.map((suggestion) => (
                <button
                  key={suggestion.prompt}
                  className="suggestion-chip"
                  onClick={() => handleSuggestionClick(suggestion.prompt)}
                  disabled={loading}
                >
                  <span>{suggestion.label}</span>
                </button>
              ))}
            </div>
          )}

          {/* Messages Area */}
          <div className="chat-messages">
            {messages.length === 0 ? (
              <div className="chat-empty">
                <div className="chat-empty-icon">
                  <Sparkles size={28} />
                </div>
                <h3>Your AI-powered memory</h3>
                <p>
                  Ask questions and get instant answers with citations from your notes.
                </p>
              </div>
            ) : (
              messages.map((message) => (
                <ChatMessage
                  key={message.id}
                  message={message}
                  onCitationClick={handleCitationClick}
                  activeCid={selectedCid}
                />
              ))
            )}
            {loading && <ChatMessageLoading />}
            <div ref={messagesEndRef} />
          </div>

          {/* Input Area */}
          <div className="chat-input-area">
            {rateLimitCountdown !== null && (
              <div className="rate-limit-notice">
                Rate limited. Try again in {rateLimitCountdown}s
              </div>
            )}
            <div className="chat-input-row">
              <input
                ref={inputRef}
                type="text"
                className={`chat-input ${input.trim().length > MAX_MESSAGE_LENGTH ? 'input-error' : ''}`}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={rateLimitCountdown !== null ? `Wait ${rateLimitCountdown}s...` : 'Ask a question...'}
                aria-label="Chat input"
                disabled={loading || rateLimitCountdown !== null}
                maxLength={MAX_MESSAGE_LENGTH + 100} // Allow slight overage to show error
              />
              <button
                className="btn btn-primary btn-icon"
                onClick={() => handleSend()}
                disabled={!input.trim() || input.trim().length > MAX_MESSAGE_LENGTH || loading || rateLimitCountdown !== null}
                aria-label="Send message"
              >
                {loading ? <span className="spinner" /> : <ArrowUp size={18} />}
              </button>
            </div>
            {input.trim().length > 0 && (
              <div className={`chat-char-count ${input.trim().length > MAX_MESSAGE_LENGTH ? 'over-limit' : ''}`}>
                {input.trim().length.toLocaleString()} / {MAX_MESSAGE_LENGTH.toLocaleString()}
              </div>
            )}
          </div>
        </div>

        {/* Sources Panel */}
        {showSources && (
          <SourcesPanel
            citations={activeCitations}
            selectedCid={selectedCid}
            onSelectCitation={setSelectedCid}
            onOpenNote={handleOpenNote}
            onClose={() => setShowSources(false)}
          />
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/chat/CitationChip.tsx
================================================

/**
 * CitationChip component
 * Clickable inline chip that replaces raw [N1] citation tokens
 * Shows tooltip preview and triggers sources panel on click
 */

import { useState, useRef, useEffect } from 'react';
import type { Citation } from '../../lib/types';
import { formatSnippet } from '../../lib/citations';

interface CitationChipProps {
  citation: Citation;
  onClick: (citation: Citation) => void;
}

export function CitationChip({ citation, onClick }: CitationChipProps) {
  const [showTooltip, setShowTooltip] = useState(false);
  const chipRef = useRef<HTMLButtonElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);

  // Position tooltip to avoid overflow
  useEffect(() => {
    if (showTooltip && tooltipRef.current && chipRef.current) {
      const tooltip = tooltipRef.current;
      const viewportWidth = window.innerWidth;

      // Reset position
      tooltip.style.left = '50%';
      tooltip.style.transform = 'translateX(-50%)';

      // Check if tooltip overflows right
      const tooltipRect = tooltip.getBoundingClientRect();
      if (tooltipRect.right > viewportWidth - 8) {
        tooltip.style.left = 'auto';
        tooltip.style.right = '0';
        tooltip.style.transform = 'none';
      }
      // Check if tooltip overflows left
      if (tooltipRect.left < 8) {
        tooltip.style.left = '0';
        tooltip.style.right = 'auto';
        tooltip.style.transform = 'none';
      }
    }
  }, [showTooltip]);

  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onClick(citation);
  };

  const snippetPreview = formatSnippet(citation.snippet, 100);

  return (
    <span className="citation-chip-wrapper">
      <button
        ref={chipRef}
        className="citation-chip"
        onClick={handleClick}
        onMouseEnter={() => setShowTooltip(true)}
        onMouseLeave={() => setShowTooltip(false)}
        onFocus={() => setShowTooltip(true)}
        onBlur={() => setShowTooltip(false)}
        aria-label={`Source ${citation.cid}: ${snippetPreview}`}
        title=""
      >
        {citation.cid}
      </button>
      
      {showTooltip && (
        <div ref={tooltipRef} className="citation-tooltip" role="tooltip">
          <div className="citation-tooltip-header">
            <span className="citation-tooltip-badge">{citation.cid}</span>
            <span className="citation-tooltip-score">
              {Math.round(citation.score * 100)}% match
            </span>
          </div>
          <p className="citation-tooltip-text">{snippetPreview}</p>
          <div className="citation-tooltip-hint">Click to view source</div>
        </div>
      )}
    </span>
  );
}

/**
 * Plain citation chip for source lists (no tooltip, simpler styling)
 */
interface SourceChipProps {
  cid: string;
  onClick: () => void;
  isActive?: boolean;
}

export function SourceChip({ cid, onClick, isActive = false }: SourceChipProps) {
  return (
    <button
      className={`source-chip ${isActive ? 'active' : ''}`}
      onClick={onClick}
      aria-label={`View source ${cid}`}
    >
      {cid}
    </button>
  );
}



================================================
FILE: src/components/chat/SourcesPanel.tsx
================================================

/**
 * SourcesPanel component
 * Shows citation sources in a side panel (desktop) or bottom sheet (mobile)
 * Allows viewing source snippets and navigating to full notes
 */

import { useEffect, useRef } from 'react';
import { BookOpen, X, ShieldCheck, ArrowRight } from 'lucide-react';
import type { Citation } from '../../lib/types';
import { formatSnippet, getConfidenceLevel } from '../../lib/citations';
import { formatRelativeTime } from '../../lib/format';

interface SourcesPanelProps {
  citations: Citation[];
  selectedCid: string | null;
  onSelectCitation: (cid: string | null) => void;
  onOpenNote: (noteId: string) => void;
  onClose: () => void;
}

export function SourcesPanel({
  citations,
  selectedCid,
  onSelectCitation,
  onOpenNote,
  onClose,
}: SourcesPanelProps) {
  const panelRef = useRef<HTMLDivElement>(null);
  const selectedRef = useRef<HTMLDivElement>(null);

  // Scroll to selected citation when it changes
  useEffect(() => {
    if (selectedCid && selectedRef.current) {
      selectedRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }, [selectedCid]);

  // Close on Escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onClose]);

  if (citations.length === 0) return null;

  return (
    <div className="sources-modal-overlay" onClick={onClose}>
      <div
        className="sources-modal animate-scale-in"
        ref={panelRef}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="sources-modal-header">
          <div className="sources-modal-title">
            <BookOpen size={16} />
            <span>Sources</span>
            <span className="sources-count">{citations.length}</span>
          </div>
          <button
            className="btn btn-icon btn-ghost btn-sm"
            onClick={onClose}
            aria-label="Close sources panel"
          >
            <X size={16} />
          </button>
        </div>

        <div className="sources-modal-body">
          <div className="sources-trust-hint">
            <ShieldCheck size={14} />
            Grounded in your notes
          </div>

          <div className="sources-list">
            {citations.map((citation) => {
              const isSelected = citation.cid === selectedCid;
              const confidence = getConfidenceLevel(citation.score);
              const createdAt = citation.createdAt ? new Date(citation.createdAt) : null;

              return (
                <div
                  key={citation.cid}
                  ref={isSelected ? selectedRef : null}
                  className={`source-card ${isSelected ? 'selected' : ''} confidence-${confidence}`}
                  onClick={() => onSelectCitation(isSelected ? null : citation.cid)}
                >
                  <div className="source-card-header">
                    <span className="source-badge">{citation.cid}</span>
                    <span className="source-score" title={`Relevance: ${Math.round(citation.score * 100)}%`}>
                      {Math.round(citation.score * 100)}%
                    </span>
                  </div>

                  <p className="source-snippet">
                    {formatSnippet(citation.snippet, 200)}
                  </p>

                  <div className="source-card-footer">
                    <span className="source-time">
                      {createdAt ? formatRelativeTime(createdAt) : ''}
                    </span>
                    <button
                      className="btn btn-sm btn-ghost"
                      onClick={(e) => {
                        e.stopPropagation();
                        onOpenNote(citation.noteId);
                      }}
                    >
                      View
                      <ArrowRight size={14} />
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/common/Toast.tsx
================================================

/**
 * Toast notification system
 * Lightweight context-based toast for showing ephemeral messages
 */

import { useState, useCallback, type ReactNode } from 'react';
import { Check, X, Info } from 'lucide-react';
import { ToastContext, type ToastType } from './ToastContext';

interface Toast {
  id: string;
  message: string;
  type: ToastType;
}

const TOAST_DURATION = 3000;

interface ToastProviderProps {
  children: ReactNode;
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const showToast = useCallback((message: string, type: ToastType = 'info') => {
    const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    setToasts((prev) => [...prev, { id, message, type }]);

    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, TOAST_DURATION);
  }, []);

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      <div className="toast-container" role="status" aria-live="polite">
        {toasts.map((toast) => (
          <div key={toast.id} className={`toast ${toast.type}`}>
            <span className="toast-icon">
              {toast.type === 'success' && <Check size={14} />}
              {toast.type === 'error' && <X size={14} />}
              {toast.type === 'info' && <Info size={14} />}
            </span>
            {toast.message}
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}



================================================
FILE: src/components/common/ToastContext.ts
================================================

/**
 * Toast context - separated for fast refresh compatibility
 */

import { createContext } from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastContextValue {
  showToast: (message: string, type?: ToastType) => void;
}

export const ToastContext = createContext<ToastContextValue | null>(null);



================================================
FILE: src/components/common/useToast.ts
================================================

/**
 * useToast hook - extracted for fast refresh compatibility
 */

import { useContext } from 'react';
import { ToastContext, type ToastContextValue } from './ToastContext';

export function useToast(): ToastContextValue {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}



================================================
FILE: src/components/layout/AppShell.tsx
================================================

/**
 * AppShell component
 * Main layout with header, responsive grid, and mobile tabs
 * Manages cross-pane communication for note highlighting from chat citations
 */

import { useState, useEffect, useCallback } from 'react';
import { Sparkles, FileText, Link2, Sun, Moon } from 'lucide-react';
import { getHealth, getApiBaseUrl } from '../../lib/api';
import { useToast } from '../common/useToast';
import { useTheme } from '../../lib/ThemeContext';
import { NotesPanel } from '../notes/NotesPanel';
import { ChatPanel } from '../chat/ChatPanel';
import { NoteDetailDrawer } from '../notes/NoteDetailDrawer';
import type { Note } from '../../lib/types';

type Tab = 'notes' | 'chat';

export function AppShell() {
  const [isConnected, setIsConnected] = useState(false);
  const [activeTab, setActiveTab] = useState<Tab>('notes');
  const [highlightNoteId, setHighlightNoteId] = useState<string | null>(null);
  const [drawerNote, setDrawerNote] = useState<Note | null>(null);
  const [drawerHighlight, setDrawerHighlight] = useState<string | undefined>();
  const { showToast } = useToast();
  const { theme, toggleTheme } = useTheme();

  const checkHealth = useCallback(async () => {
    const health = await getHealth();
    setIsConnected(health.status === 'healthy');
  }, []);

  const handleCopyApi = useCallback(async () => {
    const apiBase = getApiBaseUrl();
    if (!apiBase) return;

    try {
      await navigator.clipboard.writeText(apiBase);
      showToast('API URL copied', 'success');
    } catch {
      showToast('Failed to copy', 'error');
    }
  }, [showToast]);

  // Handle opening a note from chat citation
  const handleOpenNote = useCallback((noteId: string, snippet?: string) => {
    const tempNote: Note = {
      id: noteId,
      text: snippet || 'Loading note content...',
      tenantId: 'public',
      createdAt: null,
      updatedAt: null,
    };

    setDrawerNote(tempNote);
    setDrawerHighlight(snippet);
    setActiveTab('notes');
    setHighlightNoteId(noteId);
  }, []);

  const handleNoteHighlighted = useCallback(() => {
    setTimeout(() => setHighlightNoteId(null), 2500);
  }, []);

  const handleCloseDrawer = useCallback(() => {
    setDrawerNote(null);
    setDrawerHighlight(undefined);
  }, []);

  useEffect(() => {
    const initialTimeout = setTimeout(checkHealth, 0);
    const interval = setInterval(checkHealth, 30000);
    return () => {
      clearTimeout(initialTimeout);
      clearInterval(interval);
    };
  }, [checkHealth]);

  return (
    <div className="app-shell">
      <div className="app-container">
        {/* Header */}
        <header className="app-header">
          <div className="app-title">
            <div className="app-logo">
              <Sparkles size={18} />
            </div>
            <h1>Aurora</h1>
            <span className="tagline">Intelligent notes</span>
          </div>

          <div className="header-actions">
            <div className="status-indicator">
              <span className={`status-dot${isConnected ? ' connected' : ''}`} />
              {isConnected ? 'Online' : 'Offline'}
            </div>

            <button
              className="btn btn-icon btn-ghost"
              onClick={handleCopyApi}
              title="Copy API URL"
              aria-label="Copy API URL"
            >
              <Link2 size={18} />
            </button>

            <button
              className="theme-toggle"
              onClick={toggleTheme}
              title={theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'}
              aria-label={theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'}
            >
              {theme === 'light' ? <Moon size={18} /> : <Sun size={18} />}
            </button>
          </div>
        </header>

        {/* Mobile Tabs */}
        <div className="mobile-tabs" role="tablist">
          <button
            role="tab"
            aria-selected={activeTab === 'notes'}
            className={activeTab === 'notes' ? 'active' : ''}
            onClick={() => setActiveTab('notes')}
          >
            <FileText size={16} />
            Notes
          </button>
          <button
            role="tab"
            aria-selected={activeTab === 'chat'}
            className={activeTab === 'chat' ? 'active' : ''}
            onClick={() => setActiveTab('chat')}
          >
            <Sparkles size={16} />
            Ask AI
          </button>
        </div>

        {/* Main Grid */}
        <main className="main-grid">
          <NotesPanel
            className={activeTab !== 'notes' ? 'hidden' : ''}
            highlightNoteId={highlightNoteId}
            onNoteHighlighted={handleNoteHighlighted}
          />
          <ChatPanel
            className={activeTab !== 'chat' ? 'hidden' : ''}
            onOpenNote={handleOpenNote}
          />
        </main>

        <NoteDetailDrawer
          note={drawerNote}
          onClose={handleCloseDrawer}
          highlightText={drawerHighlight}
        />
      </div>
    </div>
  );
}



================================================
FILE: src/components/notes/NoteCard.tsx
================================================

/**
 * NoteCard component
 * Compact note display with expandable text, hover actions, and relative time
 * Supports search highlighting and external highlight state
 */

import { useState, useCallback, useEffect } from 'react';
import { Copy } from 'lucide-react';
import type { Note } from '../../lib/types';
import { formatRelativeTime, formatFullTimestamp, shortId } from '../../lib/format';
import { useToast } from '../common/useToast';

interface NoteCardProps {
  note: Note;
  isPending?: boolean;
  isHighlighted?: boolean;
  searchQuery?: string;
}

export function NoteCard({
  note,
  isPending = false,
  isHighlighted = false,
  searchQuery = ''
}: NoteCardProps) {
  const [expanded, setExpanded] = useState(false);
  const [highlightActive, setHighlightActive] = useState(false);
  const { showToast } = useToast();

  // Flash highlight effect - triggered when isHighlighted prop changes
  useEffect(() => {
    if (!isHighlighted) {
      return;
    }
    // Start highlight animation after a microtask to avoid synchronous setState
    const startTimeout = setTimeout(() => setHighlightActive(true), 0);
    const endTimeout = setTimeout(() => setHighlightActive(false), 2000);
    return () => {
      clearTimeout(startTimeout);
      clearTimeout(endTimeout);
    };
  }, [isHighlighted]);

  const showHighlight = isHighlighted || highlightActive;

  const needsExpansion = note.text.length > 200 || note.text.split('\n').length > 2;

  const handleToggle = useCallback(() => {
    if (needsExpansion) {
      setExpanded((prev) => !prev);
    }
  }, [needsExpansion]);

  const handleCopy = useCallback(async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(note.text);
      showToast('Copied', 'success');
    } catch {
      showToast('Failed to copy', 'error');
    }
  }, [note.text, showToast]);

  const displayId = shortId(note.id);
  const relativeTime = formatRelativeTime(note.createdAt);
  const fullTime = formatFullTimestamp(note.createdAt);

  // Render text with optional search highlighting
  const renderText = () => {
    if (!searchQuery || !note.text.toLowerCase().includes(searchQuery.toLowerCase())) {
      return note.text;
    }

    // Simple case-insensitive highlight
    const parts = note.text.split(new RegExp(`(${escapeRegex(searchQuery)})`, 'gi'));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === searchQuery.toLowerCase() ? (
            <mark key={i} className="search-highlight">{part}</mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  const cardClasses = [
    'note-card',
    isPending ? 'pending' : '',
    showHighlight ? 'highlighted' : '',
  ].filter(Boolean).join(' ');

  return (
    <div
      className={cardClasses}
      onClick={handleToggle}
      role={needsExpansion ? 'button' : undefined}
      tabIndex={needsExpansion ? 0 : undefined}
      onKeyDown={(e) => {
        if (needsExpansion && (e.key === 'Enter' || e.key === ' ')) {
          e.preventDefault();
          handleToggle();
        }
      }}
    >
      <div className={`note-text${!expanded && needsExpansion ? ' clamped' : ''}`}>
        {renderText()}
      </div>

      <div className="note-meta">
        <span className="note-time" title={fullTime}>
          {isPending ? 'Saving…' : relativeTime}
        </span>

        <div className="note-actions">
          <button
            className="btn btn-icon btn-ghost btn-sm"
            onClick={handleCopy}
            title="Copy note"
            aria-label="Copy note text"
          >
            <Copy size={14} />
          </button>
        </div>

        {displayId && (
          <span className="note-id" title={`ID: ${note.id}`}>
            {displayId}
          </span>
        )}
      </div>
    </div>
  );
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}



================================================
FILE: src/components/notes/NoteDetailDrawer.tsx
================================================

/**
 * NoteDetailDrawer component
 * Modal/drawer for viewing full note content when navigating from citations
 */

import { useEffect, useCallback } from 'react';
import { FileText, X, Copy } from 'lucide-react';
import type { Note } from '../../lib/types';
import { formatFullTimestamp, formatRelativeTime, shortId } from '../../lib/format';
import { useToast } from '../common/useToast';

interface NoteDetailDrawerProps {
  note: Note | null;
  onClose: () => void;
  highlightText?: string;
}

export function NoteDetailDrawer({ note, onClose, highlightText }: NoteDetailDrawerProps) {
  const { showToast } = useToast();

  // Close on Escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onClose]);

  // Prevent body scroll when drawer is open
  useEffect(() => {
    if (note) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = '';
      };
    }
  }, [note]);

  const handleCopy = useCallback(async () => {
    if (!note) return;
    try {
      await navigator.clipboard.writeText(note.text);
      showToast('Copied to clipboard', 'success');
    } catch {
      showToast('Failed to copy', 'error');
    }
  }, [note, showToast]);

  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  }, [onClose]);

  if (!note) return null;

  const displayId = shortId(note.id);
  const relativeTime = formatRelativeTime(note.createdAt);
  const fullTime = formatFullTimestamp(note.createdAt);

  // Highlight matching text if provided
  const renderText = () => {
    if (!highlightText || !note.text.toLowerCase().includes(highlightText.toLowerCase())) {
      return <p className="note-detail-text">{note.text}</p>;
    }

    // Simple case-insensitive highlight
    const parts = note.text.split(new RegExp(`(${escapeRegex(highlightText)})`, 'gi'));
    return (
      <p className="note-detail-text">
        {parts.map((part, i) => 
          part.toLowerCase() === highlightText.toLowerCase() ? (
            <mark key={i} className="highlight">{part}</mark>
          ) : (
            part
          )
        )}
      </p>
    );
  };

  return (
    <div className="note-drawer-backdrop" onClick={handleBackdropClick}>
      <div className="note-drawer" role="dialog" aria-modal="true" aria-labelledby="note-drawer-title">
        <div className="note-drawer-header">
          <h3 id="note-drawer-title">
            <FileText size={18} style={{ marginRight: '8px' }} />
            Note
          </h3>
          <button
            className="btn btn-icon btn-ghost"
            onClick={onClose}
            aria-label="Close"
          >
            <X size={18} />
          </button>
        </div>

        <div className="note-drawer-body">
          {renderText()}
        </div>

        <div className="note-drawer-footer">
          <div className="note-drawer-meta">
            <span className="note-drawer-time" title={fullTime}>
              {relativeTime}
            </span>
            {displayId && (
              <span className="note-drawer-id">{displayId}</span>
            )}
          </div>
          <div className="note-drawer-actions">
            <button className="btn btn-sm" onClick={handleCopy}>
              <Copy size={14} />
              Copy
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}




================================================
FILE: src/components/notes/NotesPanel.tsx
================================================

/**
 * NotesPanel component
 * Sticky composer, scrollable notes list, keyboard shortcuts, optimistic updates
 * Now with cursor-based pagination for 100k+ notes support
 * Includes search and quick filters (Today/This week/All)
 */

import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { FileText, Search, Plus } from 'lucide-react';
import type { Note } from '../../lib/types';
import { normalizeNote } from '../../lib/format';
import { listNotes, createNote } from '../../lib/api';
import { useToast } from '../common/useToast';
import { NoteCard } from './NoteCard';

const MAX_NOTE_LENGTH = 5000;
const PAGE_SIZE = 50;
const SEARCH_DEBOUNCE_MS = 300;

type FilterType = 'all' | 'today' | 'week';

interface NotesPanelProps {
  className?: string;
  highlightNoteId?: string | null;
  onNoteHighlighted?: () => void;
}

export function NotesPanel({ className = '', highlightNoteId, onNoteHighlighted }: NotesPanelProps) {
  const [notes, setNotes] = useState<Note[]>([]);
  const [pendingNotes, setPendingNotes] = useState<Note[]>([]);
  const [text, setText] = useState('');
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [cursor, setCursor] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(false);

  // Search and filter state
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  const [activeFilter, setActiveFilter] = useState<FilterType>('all');

  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const scrollRef = useRef<HTMLDivElement>(null);
  const highlightRef = useRef<HTMLDivElement>(null);
  const searchTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const { showToast } = useToast();

  // Debounce search input
  useEffect(() => {
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }
    searchTimeoutRef.current = setTimeout(() => {
      setDebouncedSearch(searchQuery);
    }, SEARCH_DEBOUNCE_MS);

    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, [searchQuery]);

  const trimmed = text.trim();
  const canSubmit = useMemo(
    () => trimmed.length > 0 && trimmed.length <= MAX_NOTE_LENGTH && !saving,
    [trimmed, saving]
  );

  const loadNotes = useCallback(async (loadCursor?: string, append = false) => {
    if (append) {
      setLoadingMore(true);
    } else {
      setLoading(true);
    }
    setError(null);

    try {
      const response = await listNotes(loadCursor, PAGE_SIZE);
      const normalized = response.notes.map(normalizeNote);

      if (append) {
        setNotes(prev => [...prev, ...normalized]);
      } else {
        setNotes(normalized);
      }

      setCursor(response.cursor);
      setHasMore(response.hasMore);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load notes';
      setError(message);
      showToast(message, 'error');
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [showToast]);

  const loadMore = useCallback(() => {
    if (cursor && !loadingMore && hasMore) {
      loadNotes(cursor, true);
    }
  }, [cursor, loadingMore, hasMore, loadNotes]);

  const handleCreate = useCallback(async () => {
    if (!canSubmit) return;

    // Create optimistic note
    const optimisticNote: Note = {
      id: `temp-${Date.now()}`,
      text: trimmed,
      tenantId: 'public',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    setPendingNotes((prev) => [optimisticNote, ...prev]);
    setText('');
    setSaving(true);
    setError(null);

    try {
      const createdNote = await createNote(trimmed);
      // Replace optimistic note with the real one from API (more efficient than reloading all)
      const normalizedNote = normalizeNote(createdNote);
      setPendingNotes([]);
      setNotes((prev) => [normalizedNote, ...prev]);
      showToast('Saved', 'success');
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to save note';
      setError(message);
      showToast(message, 'error');
      // Restore text on failure
      setText(optimisticNote.text);
      setPendingNotes([]);
    } finally {
      setSaving(false);
    }
  }, [canSubmit, trimmed, showToast]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        handleCreate();
      }
    },
    [handleCreate]
  );

  // Handle infinite scroll
  const handleScroll = useCallback(() => {
    const scrollEl = scrollRef.current;
    if (!scrollEl || loadingMore || !hasMore) return;

    const { scrollTop, scrollHeight, clientHeight } = scrollEl;
    // Load more when within 200px of bottom
    if (scrollHeight - scrollTop - clientHeight < 200) {
      loadMore();
    }
  }, [loadMore, loadingMore, hasMore]);

  useEffect(() => {
    loadNotes();
  }, [loadNotes]);

  // Attach scroll listener
  useEffect(() => {
    const scrollEl = scrollRef.current;
    if (!scrollEl) return;

    scrollEl.addEventListener('scroll', handleScroll);
    return () => scrollEl.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  // Scroll to highlighted note when requested
  useEffect(() => {
    if (highlightNoteId && highlightRef.current) {
      highlightRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
      onNoteHighlighted?.();
    }
  }, [highlightNoteId, onNoteHighlighted]);

  // Filter notes client-side
  const filteredNotes = useMemo(() => {
    const allNotes = [...pendingNotes, ...notes];

    let result = allNotes;

    // Apply time filter
    if (activeFilter !== 'all') {
      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfWeek = new Date(startOfDay);
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());

      result = result.filter(note => {
        if (!note.createdAt) return false;
        if (activeFilter === 'today') {
          return note.createdAt >= startOfDay;
        }
        if (activeFilter === 'week') {
          return note.createdAt >= startOfWeek;
        }
        return true;
      });
    }

    // Apply search filter
    if (debouncedSearch) {
      const query = debouncedSearch.toLowerCase();
      result = result.filter(note =>
        note.text.toLowerCase().includes(query)
      );
    }

    return result;
  }, [pendingNotes, notes, activeFilter, debouncedSearch]);

  const totalLoaded = notes.length;
  const isFiltered = activeFilter !== 'all' || debouncedSearch.length > 0;

  return (
    <div className={`panel ${className}`}>
      <div className="panel-header">
        <h2>
          <FileText size={16} />
          Your Notes
        </h2>
        <div className="text-muted text-xs">
          {loading ? (
            <span className="spinner" />
          ) : isFiltered ? (
            <>{filteredNotes.length} found</>
          ) : (
            <>
              {totalLoaded.toLocaleString()}{hasMore && '+'} notes
            </>
          )}
        </div>
      </div>

      <div className="panel-body">
        {/* Floating Composer */}
        <div className="composer">
          <textarea
            ref={textareaRef}
            className="composer-input"
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Capture a thought..."
            aria-label="Write a note"
            disabled={saving}
          />
          <div className="composer-row">
            <div className="composer-hint">
              {trimmed.length > 0 && (
                <>{trimmed.length.toLocaleString()} / {MAX_NOTE_LENGTH.toLocaleString()}</>
              )}
            </div>
            <button
              className="btn btn-primary"
              onClick={handleCreate}
              disabled={!canSubmit}
            >
              {saving ? (
                <span className="spinner" />
              ) : (
                <Plus size={16} />
              )}
              Save
            </button>
          </div>
        </div>

        {/* Search and Filters */}
        <div className="notes-toolbar">
          <div className="search-box">
            <Search size={16} />
            <input
              type="text"
              className="search-input"
              placeholder="Search..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              aria-label="Search notes"
            />
            {searchQuery && (
              <button
                className="search-clear"
                onClick={() => setSearchQuery('')}
                aria-label="Clear search"
              >
                ✕
              </button>
            )}
          </div>
          <div className="filter-tabs">
            {(['all', 'today', 'week'] as FilterType[]).map((filter) => (
              <button
                key={filter}
                className={`filter-tab ${activeFilter === filter ? 'active' : ''}`}
                onClick={() => setActiveFilter(filter)}
              >
                {filter === 'all' ? 'All' : filter === 'today' ? 'Today' : 'Week'}
              </button>
            ))}
          </div>
        </div>

        {error && <div className="error-inline">{error}</div>}

        {/* Scrollable Notes List with Infinite Scroll */}
        <div className="notes-scroll" ref={scrollRef}>
          <div className="notes-list" role="list" aria-label="Notes list">
            {loading && notes.length === 0 ? (
              <>
                <div className="skeleton" />
                <div className="skeleton" />
                <div className="skeleton" />
              </>
            ) : filteredNotes.length === 0 ? (
              <div className="empty-state">
                {isFiltered ? (
                  <>No notes match your search.</>
                ) : (
                  <>No notes yet. Create your first note above.</>
                )}
              </div>
            ) : (
              <>
                {filteredNotes.map((note) => (
                  <div
                    key={note.id}
                    ref={note.id === highlightNoteId ? highlightRef : null}
                  >
                    <NoteCard
                      note={note}
                      isPending={note.id.startsWith('temp-')}
                      isHighlighted={note.id === highlightNoteId}
                      searchQuery={debouncedSearch}
                    />
                  </div>
                ))}
                {!isFiltered && loadingMore && (
                  <div className="loading-more">
                    <span className="spinner" /> Loading more...
                  </div>
                )}
                {!isFiltered && hasMore && !loadingMore && (
                  <button
                    className="btn load-more-btn"
                    onClick={loadMore}
                  >
                    Load more notes
                  </button>
                )}
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/lib/api.ts
================================================

/**
 * API client wrapper for AuroraNotes backend
 */

import type { RawNote, HealthResponse, ApiError, NotesListResponse, ChatResponse } from './types';

const DEFAULT_TIMEOUT = 10000; // 10 seconds
const CHAT_TIMEOUT = 30000; // 30 seconds for chat

function getApiBase(): string {
  return (import.meta.env.VITE_API_BASE as string) || '';
}

function getApiKey(): string | null {
  return (import.meta.env.VITE_API_KEY as string) || null;
}

function getDefaultHeaders(): Record<string, string> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  const apiKey = getApiKey();
  if (apiKey) {
    headers['Authorization'] = `Bearer ${apiKey}`;
    headers['X-API-Key'] = apiKey;
  }

  return headers;
}

/**
 * Custom error class for API errors
 */
export class ApiRequestError extends Error {
  status?: number;
  code?: string;
  retryAfterMs?: number;

  constructor(message: string, status?: number, code?: string, retryAfterMs?: number) {
    super(message);
    this.name = 'ApiRequestError';
    this.status = status;
    this.code = code;
    this.retryAfterMs = retryAfterMs;
  }
}

/**
 * Safe JSON parsing
 */
async function safeJson<T>(res: Response): Promise<T | null> {
  try {
    return await res.json();
  } catch {
    return null;
  }
}

/**
 * Make a single API request attempt
 */
async function singleRequest<T>(
  path: string,
  options: RequestInit,
  timeout: number,
  apiBase: string
): Promise<T> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const res = await fetch(`${apiBase}${path}`, {
      ...options,
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!res.ok) {
      const body = await safeJson<ApiError>(res);
      throw new ApiRequestError(
        body?.error || `Request failed: ${res.status}`,
        res.status,
        body?.code,
        body?.retryAfterMs
      );
    }

    return await res.json();
  } catch (err) {
    clearTimeout(timeoutId);

    if (err instanceof ApiRequestError) {
      throw err;
    }

    if (err instanceof Error) {
      if (err.name === 'AbortError') {
        throw new ApiRequestError('Request timed out', 0, 'TIMEOUT');
      }
      throw new ApiRequestError(err.message, 0, 'NETWORK_ERROR');
    }

    throw new ApiRequestError('An unexpected error occurred');
  }
}

/**
 * Check if an error is retryable
 */
function isRetryable(error: ApiRequestError): boolean {
  // Retry on network errors, timeouts, and 5xx server errors
  if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT') {
    return true;
  }
  if (error.status && error.status >= 500 && error.status < 600) {
    return true;
  }
  return false;
}

/**
 * Make API request with timeout, error handling, and retry for transient failures
 */
async function request<T>(
  path: string,
  options: RequestInit = {},
  timeout = DEFAULT_TIMEOUT,
  maxRetries = 1
): Promise<T> {
  const apiBase = getApiBase();

  if (!apiBase) {
    throw new ApiRequestError(
      'Missing VITE_API_BASE. Add it to .env.local and restart the dev server.',
      0,
      'MISSING_CONFIG'
    );
  }

  let lastError: ApiRequestError | null = null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await singleRequest<T>(path, options, timeout, apiBase);
    } catch (err) {
      if (err instanceof ApiRequestError) {
        lastError = err;

        // Only retry if it's a retryable error and we have retries left
        if (attempt < maxRetries && isRetryable(err)) {
          // Wait a bit before retrying (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 300 * Math.pow(2, attempt)));
          continue;
        }
      }
      throw err;
    }
  }

  // Should not reach here, but just in case
  throw lastError || new ApiRequestError('Request failed after retries');
}

/**
 * Check API health
 */
export async function getHealth(): Promise<HealthResponse> {
  try {
    const response = await request<HealthResponse>('/health', {}, 5000);
    // Backend returns status: 'healthy' on success
    if (response.status === 'healthy') {
      return response;
    }
    return { ...response, status: 'unhealthy' };
  } catch {
    return { status: 'unhealthy' };
  }
}

/**
 * List notes with pagination
 */
export async function listNotes(cursor?: string, limit = 50): Promise<NotesListResponse> {
  const params = new URLSearchParams();
  if (limit) params.set('limit', String(limit));
  if (cursor) params.set('cursor', cursor);

  const queryString = params.toString();
  const path = queryString ? `/notes?${queryString}` : '/notes';

  return await request<NotesListResponse>(path);
}

/**
 * List all notes (legacy compatibility - returns just the notes array)
 */
export async function listAllNotes(): Promise<RawNote[]> {
  const data = await listNotes();
  return data.notes;
}

/**
 * Create a new note
 */
export async function createNote(text: string): Promise<RawNote> {
  return await request<RawNote>('/notes', {
    method: 'POST',
    headers: getDefaultHeaders(),
    body: JSON.stringify({ text }),
  });
}

/**
 * Send a chat message and get RAG-powered response with citations
 */
export async function sendChatMessage(message: string): Promise<ChatResponse> {
  return await request<ChatResponse>(
    '/chat',
    {
      method: 'POST',
      headers: getDefaultHeaders(),
      body: JSON.stringify({ message }),
    },
    CHAT_TIMEOUT
  );
}

/**
 * Get API base URL (for display/copy)
 */
export function getApiBaseUrl(): string {
  return getApiBase();
}



================================================
FILE: src/lib/citations.ts
================================================

/**
 * Citation parsing and handling utilities
 * Parses [N1], [N2] citation tokens from RAG responses and maps to citation objects
 */

import type { Citation } from './types';

/** Regex pattern to match citation tokens like [N1], [N2], etc. */
const CITATION_PATTERN = /\[N(\d+)\]/g;

/** Represents a segment of parsed text - either plain text or a citation */
export interface TextSegment {
  type: 'text' | 'citation';
  content: string;
  citation?: Citation;
}

/**
 * Parse answer text and identify citation tokens
 * Returns an array of segments for rendering
 */
export function parseCitations(
  text: string,
  citations: Citation[] | undefined
): TextSegment[] {
  if (!text) return [];
  if (!citations || citations.length === 0) {
    return [{ type: 'text', content: text }];
  }

  // Build a lookup map for faster access
  const citationMap = new Map<string, Citation>();
  for (const c of citations) {
    citationMap.set(c.cid, c);
  }

  const segments: TextSegment[] = [];
  let lastIndex = 0;

  // Find all citation matches
  const matches = text.matchAll(CITATION_PATTERN);

  for (const match of matches) {
    const fullMatch = match[0]; // e.g., "[N1]"
    const num = match[1]; // e.g., "1"
    const cid = `N${num}`;
    const matchIndex = match.index!;

    // Add text before this citation
    if (matchIndex > lastIndex) {
      segments.push({
        type: 'text',
        content: text.slice(lastIndex, matchIndex),
      });
    }

    // Add citation segment
    const citation = citationMap.get(cid);
    if (citation) {
      segments.push({
        type: 'citation',
        content: fullMatch,
        citation,
      });
    } else {
      // Citation not found in list - render as plain text
      segments.push({
        type: 'text',
        content: fullMatch,
      });
    }

    lastIndex = matchIndex + fullMatch.length;
  }

  // Add remaining text after last citation
  if (lastIndex < text.length) {
    segments.push({
      type: 'text',
      content: text.slice(lastIndex),
    });
  }

  return segments;
}

/**
 * Get unique citations referenced in the text
 * Useful for building a summary list of sources
 */
export function getReferencedCitations(
  text: string,
  citations: Citation[] | undefined
): Citation[] {
  if (!text || !citations || citations.length === 0) return [];

  const citationMap = new Map<string, Citation>();
  for (const c of citations) {
    citationMap.set(c.cid, c);
  }

  const referenced: Citation[] = [];
  const seen = new Set<string>();

  const matches = text.matchAll(CITATION_PATTERN);
  for (const match of matches) {
    const cid = `N${match[1]}`;
    if (!seen.has(cid)) {
      seen.add(cid);
      const citation = citationMap.get(cid);
      if (citation) {
        referenced.push(citation);
      }
    }
  }

  return referenced;
}

/**
 * Check if text contains any citation tokens
 */
export function hasCitations(text: string): boolean {
  return CITATION_PATTERN.test(text);
}

/**
 * Format citation snippet for display (truncate if needed)
 */
export function formatSnippet(snippet: string, maxLength = 200): string {
  if (!snippet) return '';
  if (snippet.length <= maxLength) return snippet;
  return snippet.slice(0, maxLength).trim() + '…';
}

/**
 * Calculate confidence level from score
 */
export function getConfidenceLevel(score: number): 'high' | 'medium' | 'low' {
  if (score >= 0.7) return 'high';
  if (score >= 0.4) return 'medium';
  return 'low';
}



================================================
FILE: src/lib/format.ts
================================================

/**
 * Formatting utilities for timestamps and notes
 */

import type { RawTimestamp, RawNote, Note } from './types';

/**
 * Convert raw timestamp value to Date object
 */
export function toDate(value: RawTimestamp): Date | null {
  if (!value) return null;
  
  if (typeof value === 'string') {
    const d = new Date(value);
    return isNaN(d.getTime()) ? null : d;
  }
  
  if (typeof value === 'object' && '_seconds' in value) {
    return new Date(value._seconds * 1000);
  }
  
  return null;
}

/**
 * Format a date as relative time (e.g., "Just now", "5m", "2h", "3d")
 */
export function formatRelativeTime(d: Date | null): string {
  if (!d) return '';
  
  try {
    const now = Date.now();
    const diffMs = now - d.getTime();
    const diffMin = Math.floor(diffMs / 60000);
    
    if (diffMin < 1) return 'Just now';
    if (diffMin < 60) return `${diffMin}m`;
    
    const diffHr = Math.floor(diffMin / 60);
    if (diffHr < 24) return `${diffHr}h`;
    
    const diffDay = Math.floor(diffHr / 24);
    if (diffDay < 7) return `${diffDay}d`;
    
    // For older, show short date
    return d.toLocaleDateString(undefined, { 
      month: 'short', 
      day: 'numeric' 
    });
  } catch {
    return '';
  }
}

/**
 * Format a date as full timestamp for tooltips
 */
export function formatFullTimestamp(d: Date | null): string {
  if (!d) return 'Unknown time';
  
  try {
    return d.toLocaleString(undefined, {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
    });
  } catch {
    return 'Unknown time';
  }
}

/**
 * Normalize a raw note from API to consistent format
 */
export function normalizeNote(raw: RawNote): Note {
  return {
    id: raw.id || `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    text: raw.text || '',
    tenantId: raw.tenantId || 'public',
    createdAt: toDate(raw.createdAt),
    updatedAt: toDate(raw.updatedAt),
  };
}

/**
 * Truncate text to specified length with ellipsis
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength).trim() + '…';
}

/**
 * Get short ID for display (first 8 chars)
 */
export function shortId(id: string): string {
  if (!id || id.startsWith('temp-')) return '';
  return id.slice(0, 8);
}



================================================
FILE: src/lib/ThemeContext.tsx
================================================

/**
 * Theme Context
 * Provides dark/light mode toggle functionality with localStorage persistence
 * Defaults to light mode
 */

import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: Theme) => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

const STORAGE_KEY = 'aurora-theme';

function getInitialTheme(): Theme {
  // Check localStorage first
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored === 'dark' || stored === 'light') {
      return stored;
    }
  }
  // Default to light mode
  return 'light';
}

interface ThemeProviderProps {
  children: ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(getInitialTheme);

  // Apply theme class to document
  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(theme);
    localStorage.setItem(STORAGE_KEY, theme);
  }, [theme]);

  const toggleTheme = useCallback(() => {
    setThemeState((prev) => (prev === 'light' ? 'dark' : 'light'));
  }, []);

  const setTheme = useCallback((newTheme: Theme) => {
    setThemeState(newTheme);
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}



================================================
FILE: src/lib/types.ts
================================================

/**
 * Shared types for AuroraNotes
 */

/** Firestore timestamp shape when serialized from backend */
export type FirestoreTs = { _seconds: number; _nanoseconds?: number };

/** Raw timestamp value that can come from API */
export type RawTimestamp = string | FirestoreTs | undefined | null;

/** Note as returned from API (with raw timestamps) */
export interface RawNote {
  id?: string;
  text: string;
  tenantId?: string;
  createdAt?: RawTimestamp;
  updatedAt?: RawTimestamp;
}

/** Normalized note with JS Date objects */
export interface Note {
  id: string;
  text: string;
  tenantId: string;
  createdAt: Date | null;
  updatedAt: Date | null;
}

/** Paginated notes list response from API */
export interface NotesListResponse {
  notes: RawNote[];
  cursor: string | null;
  hasMore: boolean;
}

// ============================================
// Chat Types
// ============================================

/** Citation in chat response */
export interface Citation {
  cid: string;          // e.g., "N1", "N2"
  noteId: string;
  chunkId: string;
  createdAt: string;    // ISO string
  snippet: string;
  score: number;
}

/** Chat response from API */
export interface ChatResponse {
  answer: string;
  citations: Citation[];
  meta: {
    model: string;
    retrieval: {
      k: number;
      strategy: string;
      candidateCount?: number;
      rerankCount?: number;
      timeMs?: number;
    };
  };
}

/** Retrieval metadata from chat response */
export interface RetrievalMeta {
  model: string;
  retrieval: {
    k: number;
    strategy: string;
    candidateCount?: number;
    rerankCount?: number;
    timeMs?: number;
  };
}

/** Chat message for UI state */
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  citations?: Citation[];
  meta?: RetrievalMeta;
}

/** Health check response */
export interface HealthResponse {
  status: 'healthy' | 'unhealthy';
  timestamp?: string;
  service?: string;
  project?: string;
  version?: string;
}

/** API error response */
export interface ApiError {
  error: string;
  code?: string;
  retryAfterMs?: number;
}



================================================
FILE: src/main.tsx
================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================
FILE: src/styles/app.css
================================================

@import "tailwindcss";

/**
 * AuroraNotes Design System v7.0
 * Tailwind CSS + Custom Properties for theming
 * Red accent theme
 */

/* ============================================
   Theme Variables (CSS Custom Properties)
   ============================================ */
:root,
:root.light {
  /* Brand - Red Theme */
  --color-primary: #dc2626;
  --color-primary-hover: #b91c1c;
  --color-accent: #e11d48;
  --color-accent-hover: #be123c;

  /* Surfaces */
  --color-bg: #ffffff;
  --color-bg-subtle: #fafafa;
  --color-surface: #ffffff;
  --color-surface-hover: #f5f5f5;

  /* Text */
  --color-text: #171717;
  --color-text-secondary: #525252;
  --color-text-muted: #a3a3a3;

  /* Borders */
  --color-border: #e5e5e5;
  --color-border-strong: #d4d4d4;
  --color-primary-muted: rgba(220, 38, 38, 0.1);

  /* Status Colors */
  --color-success: #16a34a;
  --color-success-bg: #f0fdf4;
  --color-success-border: #bbf7d0;
  --color-danger: #dc2626;
  --color-danger-bg: #fef2f2;
  --color-danger-border: #fecaca;
  --color-warning: #d97706;
  --color-warning-bg: #fffbeb;

  /* AI Accent - Rose/Red gradient */
  --color-ai: #e11d48;
  --color-ai-hover: #be123c;
  --color-ai-bg: #fff1f2;
  --color-ai-border: #fecdd3;
  --color-ai-muted: rgba(225, 29, 72, 0.1);

  /* Shadows - Refined, subtle */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.2);
  --shadow-inner: inset 0 2px 4px rgba(0, 0, 0, 0.04);
  --shadow-focus: 0 0 0 3px rgba(220, 38, 38, 0.15);
  --shadow-focus-ai: 0 0 0 3px rgba(225, 29, 72, 0.15);

  /* Focus ring */
  --ring: var(--shadow-focus);
  --ring-ai: var(--shadow-focus-ai);

  /* Radii */
  --radius-xs: 4px;
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  --radius-2xl: 20px;
  --radius-full: 9999px;

  /* Transitions */
  --ease-out: cubic-bezier(0.33, 1, 0.68, 1);
  --ease-in-out: cubic-bezier(0.65, 0, 0.35, 1);
  --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
  --transition-fast: 0.15s var(--ease-out);
  --transition-normal: 0.2s var(--ease-out);
  --transition-slow: 0.3s var(--ease-out);

  /* Typography */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-mono: 'SF Mono', 'JetBrains Mono', ui-monospace, monospace;

  /* Font weights */
  --font-normal: 400;
  --font-medium: 500;
  --font-semibold: 600;
  --font-bold: 700;

  /* Letter spacing */
  --tracking-tighter: -0.03em;
  --tracking-tight: -0.015em;
  --tracking-normal: 0;
  --tracking-wide: 0.015em;

  /* Line heights */
  --leading-none: 1;
  --leading-tight: 1.25;
  --leading-snug: 1.375;
  --leading-normal: 1.5;
  --leading-relaxed: 1.625;

  /* Spacing */
  --space-0: 0;
  --space-0-5: 2px;
  --space-1: 4px;
  --space-1-5: 6px;
  --space-2: 8px;
  --space-2-5: 10px;
  --space-3: 12px;
  --space-4: 16px;
  --space-5: 20px;
  --space-6: 24px;
  --space-8: 32px;
  --space-10: 40px;
  --space-12: 48px;
  --space-16: 64px;
  --space-20: 80px;
}

/* Dark Mode */
:root.dark {
  --color-bg: #0a0a0a;
  --color-bg-subtle: #0f0f0f;
  --color-bg-muted: #171717;
  --color-surface: #141414;
  --color-surface-elevated: #1a1a1a;
  --color-surface-hover: #1f1f1f;
  --color-text: #fafafa;
  --color-text-secondary: #a3a3a3;
  --color-text-tertiary: #737373;
  --color-muted: #525252;
  --color-border: #262626;
  --color-border-subtle: #1a1a1a;
  --color-border-strong: #404040;

  --color-primary: #ef4444;
  --color-primary-hover: #f87171;
  --color-primary-light: rgba(239, 68, 68, 0.15);
  --color-primary-muted: rgba(239, 68, 68, 0.12);

  --color-success-bg: rgba(22, 163, 74, 0.15);
  --color-success-border: rgba(22, 163, 74, 0.3);
  --color-danger-bg: rgba(220, 38, 38, 0.15);
  --color-danger-border: rgba(220, 38, 38, 0.3);

  --color-ai: #fb7185;
  --color-ai-hover: #fda4af;
  --color-ai-bg: rgba(251, 113, 133, 0.12);
  --color-ai-border: rgba(251, 113, 133, 0.25);
  --color-ai-muted: rgba(251, 113, 133, 0.15);

  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.2);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.35);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
  --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.5);
  --shadow-2xl: 0 25px 50px rgba(0, 0, 0, 0.6);

  --shadow-focus: 0 0 0 3px rgba(239, 68, 68, 0.2);
  --shadow-focus-ai: 0 0 0 3px rgba(251, 113, 133, 0.2);
}

/* ============================================
   Reset & Base
   ============================================ */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  -webkit-text-size-adjust: 100%;
  font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
}

body {
  min-height: 100vh;
  min-height: 100dvh;
  background: var(--color-bg);
  color: var(--color-text);
  font-family: var(--font-sans);
  font-size: 14px;
  line-height: var(--leading-normal);
  font-weight: var(--font-normal);
  letter-spacing: var(--tracking-normal);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow-x: hidden;
  text-rendering: optimizeLegibility;
  transition: background-color var(--transition-normal), color var(--transition-normal);
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* ============================================
   Typography
   ============================================ */
.text-muted { color: var(--color-muted); }
.text-secondary { color: var(--color-text-secondary); }
.text-tertiary { color: var(--color-text-tertiary); }
.text-primary { color: var(--color-primary); }
.text-sm { font-size: 13px; }
.text-xs { font-size: 11px; letter-spacing: 0.02em; }

.font-medium { font-weight: var(--font-medium); }
.font-semibold { font-weight: var(--font-semibold); }
.font-bold { font-weight: var(--font-bold); }
.font-mono { font-family: var(--font-mono); font-size: 0.9em; }

/* ============================================
   Layout - Clean, spacious
   ============================================ */
.app-shell {
  min-height: 100vh;
  min-height: 100dvh;
  padding: var(--space-4);
  background: var(--color-bg-subtle);
  transition: background-color var(--transition-normal);
}

@media (min-width: 640px) {
  .app-shell {
    padding: var(--space-5);
  }
}

@media (min-width: 1024px) {
  .app-shell {
    padding: var(--space-6);
  }
}

@media (min-width: 1400px) {
  .app-shell {
    padding: var(--space-8);
  }
}

.app-container {
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* ============================================
   Header - Clean, minimal design
   ============================================ */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-4);
  margin-bottom: var(--space-5);
  padding: var(--space-3) var(--space-4);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  transition: all var(--transition-normal);
}

@media (min-width: 640px) {
  .app-header {
    padding: var(--space-3) var(--space-5);
  }
}

.app-title {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.app-logo {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--brand-aurora);
  border-radius: var(--radius-md);
  transition: transform var(--transition-fast);
}

.app-logo:hover {
  transform: scale(1.02);
}

.app-logo svg {
  width: 18px;
  height: 18px;
  color: white;
}

.app-title h1 {
  font-size: 16px;
  font-weight: var(--font-bold);
  letter-spacing: var(--tracking-tight);
  color: var(--color-text);
}

.app-title .tagline {
  display: none;
}

@media (min-width: 768px) {
  .app-title .tagline {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    color: var(--color-muted);
    font-size: 13px;
    font-weight: var(--font-normal);
    padding-left: var(--space-3);
    margin-left: var(--space-3);
    border-left: 1px solid var(--color-border);
  }
}

.header-actions {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.header-actions-row {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

/* Status indicator */
.status-indicator {
  display: none;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  font-size: 12px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
  background: var(--color-bg-muted);
  border-radius: var(--radius-full);
  transition: all var(--transition-fast);
}

@media (min-width: 640px) {
  .status-indicator {
    display: flex;
  }
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: var(--radius-full);
  background: var(--color-muted);
  transition: all var(--transition-fast);
}

.status-dot.connected {
  background: var(--color-success);
}

/* Theme toggle button */
.theme-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  padding: 0;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  background: var(--color-surface);
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.theme-toggle:hover {
  background: var(--color-surface-hover);
  color: var(--color-text);
  border-color: var(--color-border-strong);
}

.theme-toggle svg {
  width: 18px;
  height: 18px;
}

/* Main grid */
.main-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-4);
}

@media (min-width: 900px) {
  .main-grid {
    grid-template-columns: 1fr 1fr;
    gap: var(--space-5);
    align-items: stretch;
  }
}

@media (min-width: 1200px) {
  .main-grid {
    grid-template-columns: 1.1fr 0.9fr;
    gap: var(--space-6);
  }
}

/* ============================================
   Mobile Tabs - Segmented control
   ============================================ */
.mobile-tabs {
  display: flex;
  gap: 4px;
  padding: 4px;
  margin-bottom: var(--space-4);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
}

.mobile-tabs button {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-2-5) var(--space-4);
  font-size: 13px;
  font-weight: var(--font-medium);
  border: none;
  border-radius: var(--radius-md);
  background: transparent;
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.mobile-tabs button svg {
  width: 16px;
  height: 16px;
}

.mobile-tabs button:hover:not(.active) {
  color: var(--color-text);
  background: var(--color-bg-muted);
}

.mobile-tabs button.active {
  background: var(--color-primary);
  color: white;
}

.mobile-tabs button:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

@media (min-width: 900px) {
  .mobile-tabs {
    display: none;
  }
}

/* ============================================
   Panels - Clean card design
   ============================================ */
.panel {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 500px;
  max-height: calc(100vh - 160px);
  max-height: calc(100dvh - 160px);
  transition: all var(--transition-normal);
}

.panel.hidden {
  display: none;
}

@media (min-width: 900px) {
  .panel.hidden {
    display: flex;
  }

  .panel {
    min-height: 560px;
    max-height: calc(100vh - 140px);
    max-height: calc(100dvh - 140px);
  }
}

.panel-header {
  padding: var(--space-4) var(--space-5);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-4);
  flex-shrink: 0;
  background: var(--color-surface);
}

.panel-header h2 {
  font-size: 13px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.panel-header h2 svg {
  width: 16px;
  height: 16px;
  color: var(--color-text-secondary);
}

.panel-body {
  padding: var(--space-5);
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  background: var(--color-bg-subtle);
}

@media (max-width: 640px) {
  .panel-body {
    padding: var(--space-4);
  }
}

/* ============================================
   Buttons - Clean, modern design
   ============================================ */
.btn {
  appearance: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  color: var(--color-text);
  border-radius: var(--radius-md);
  padding: var(--space-2) var(--space-4);
  font-family: inherit;
  font-size: 13px;
  font-weight: var(--font-medium);
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
  user-select: none;
}

.btn svg {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
}

.btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-border-strong);
}

.btn:active {
  background: var(--color-bg-muted);
}

.btn:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

.btn-primary {
  background: var(--color-primary);
  border-color: var(--color-primary);
  color: white;
}

.btn-primary:hover {
  background: var(--color-primary-hover);
  border-color: var(--color-primary-hover);
}

.btn-icon {
  padding: var(--space-2);
  min-width: 36px;
  min-height: 36px;
}

.btn-ghost {
  background: transparent;
  border-color: transparent;
}

.btn-ghost:hover {
  background: var(--color-bg-muted);
  border-color: transparent;
}

.btn-sm {
  padding: var(--space-1-5) var(--space-3);
  font-size: 12px;
  min-height: 28px;
  border-radius: var(--radius-sm);
}

.btn-sm svg {
  width: 14px;
  height: 14px;
}

/* AI/Purple button variant */
.btn-ai {
  background: var(--color-ai);
  border-color: var(--color-ai);
  color: white;
}

.btn-ai:hover {
  background: var(--color-ai-hover);
  border-color: var(--color-ai-hover);
}

/* ============================================
   Composer - Note creation
   ============================================ */
.composer {
  padding-bottom: var(--space-4);
  flex-shrink: 0;
}

.composer-input {
  width: 100%;
  min-height: 80px;
  max-height: 160px;
  resize: none;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-lg);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 14px;
  line-height: var(--leading-relaxed);
  transition: all var(--transition-fast);
}

.composer-input::placeholder {
  color: var(--color-muted);
}

.composer-input:hover {
  border-color: var(--color-border-strong);
}

.composer-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--ring);
}

.composer-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  margin-top: var(--space-3);
}

.composer-hint {
  color: var(--color-muted);
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.composer-hint kbd {
  padding: 2px 6px;
  margin: 0 2px;
  border-radius: var(--radius-xs);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
}

/* ============================================
   Notes List - Clean, scannable
   ============================================ */
.notes-scroll {
  flex: 1;
  overflow-y: auto;
  margin-top: var(--space-3);
  scroll-behavior: smooth;
  padding-right: 4px;
}

.notes-scroll::-webkit-scrollbar {
  width: 6px;
}

.notes-scroll::-webkit-scrollbar-track {
  background: transparent;
}

.notes-scroll::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-full);
}

.notes-scroll::-webkit-scrollbar-thumb:hover {
  background: var(--color-border-strong);
}

.notes-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.note-card {
  padding: var(--space-4);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all var(--transition-fast);
  position: relative;
}

.note-card:hover {
  border-color: var(--color-border-strong);
  background: var(--color-surface-hover);
}

.note-card:hover .note-actions {
  opacity: 1;
}

.note-text {
  font-size: 14px;
  line-height: var(--leading-relaxed);
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--color-text);
}

.note-text.clamped {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.note-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  margin-top: var(--space-3);
  padding-top: var(--space-3);
  border-top: 1px solid var(--color-border-subtle);
  color: var(--color-muted);
  font-size: 12px;
}

.note-time {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--color-text-tertiary);
}

.note-time svg {
  width: 12px;
  height: 12px;
}

.note-id {
  opacity: 0;
  font-family: var(--font-mono);
  font-size: 10px;
  padding: 2px 6px;
  background: var(--color-bg-muted);
  border-radius: var(--radius-xs);
  color: var(--color-muted);
  transition: opacity var(--transition-fast);
}

.note-card:hover .note-id {
  opacity: 1;
}

.note-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.note-actions .btn-icon {
  min-width: 28px;
  min-height: 28px;
  padding: 6px;
}

/* Pending state */
.note-card.pending {
  opacity: 0.6;
  border-style: dashed;
}

/* Empty state */
.empty-state {
  padding: var(--space-12) var(--space-6);
  text-align: center;
  color: var(--color-text-tertiary);
  font-size: 14px;
}

/* Skeleton */
.skeleton {
  height: 80px;
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  position: relative;
  overflow: hidden;
}

.skeleton::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, var(--color-bg-muted), transparent);
  background-size: 200% 100%;
  animation: shimmer 1.5s ease-in-out infinite;
}

.skeleton + .skeleton {
  margin-top: var(--space-2);
}

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* ============================================
   Chat Panel - AI-focused design
   ============================================ */
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 320px;
}

.chat-suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  padding-bottom: var(--space-4);
}

.suggestion-chip {
  padding: var(--space-2) var(--space-3);
  font-size: 13px;
  font-weight: var(--font-medium);
  color: var(--color-ai);
  background: var(--color-ai-bg);
  border: 1px solid var(--color-ai-border);
  border-radius: var(--radius-full);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.suggestion-chip:hover {
  background: var(--color-ai);
  color: white;
  border-color: var(--color-ai);
}

.suggestion-chip:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  scroll-behavior: smooth;
  padding-right: 4px;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: transparent;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-full);
}

.chat-empty {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: var(--space-10);
  color: var(--color-muted);
}

.chat-empty-icon {
  width: 64px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: var(--space-4);
  background: var(--color-ai-bg);
  border: 1px solid var(--color-ai-border);
  border-radius: var(--radius-xl);
}

.chat-empty-icon svg {
  width: 28px;
  height: 28px;
  color: var(--color-ai);
}

.chat-empty h3 {
  margin-bottom: var(--space-1);
  font-size: 16px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.chat-empty p {
  font-size: 14px;
  max-width: 280px;
  color: var(--color-text-tertiary);
  line-height: var(--leading-relaxed);
}

.chat-input-area {
  display: flex;
  flex-direction: column;
  gap: 0;
  padding-top: var(--space-4);
  margin-top: auto;
}

.chat-input {
  flex: 1;
  padding: var(--space-3) var(--space-4);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 14px;
  transition: all var(--transition-fast);
}

.chat-input:hover {
  border-color: var(--color-border-strong);
}

.chat-input:focus {
  outline: none;
  border-color: var(--color-ai);
  box-shadow: var(--ring-ai);
}

.chat-input:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chat-input::placeholder {
  color: var(--color-muted);
}

.chat-input.input-error {
  border-color: var(--color-danger);
}

.chat-input-row {
  display: flex;
  gap: var(--space-2);
  flex: 1;
}

.rate-limit-notice {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  background: var(--color-warning-bg, rgba(234, 179, 8, 0.1));
  border: 1px solid var(--color-warning, #eab308);
  border-radius: var(--radius-md);
  color: var(--color-warning, #eab308);
  font-size: 13px;
  text-align: center;
  margin-bottom: var(--space-2);
}

.chat-char-count {
  font-size: 12px;
  color: var(--color-muted);
  text-align: right;
  padding-top: var(--space-1);
}

.chat-char-count.over-limit {
  color: var(--color-danger);
  font-weight: 500;
}

/* Chat Messages */
.chat-message {
  display: flex;
  flex-direction: column;
  gap: 6px;
  animation: message-in 0.2s var(--ease-out);
}

@keyframes message-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chat-message.user {
  align-items: flex-end;
}

.chat-message.assistant {
  align-items: flex-start;
}

.chat-bubble {
  max-width: 85%;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-lg);
  font-size: 14px;
  line-height: var(--leading-relaxed);
  word-break: break-word;
}

.chat-message.user .chat-bubble {
  background: var(--color-primary);
  color: white;
  border-bottom-right-radius: var(--radius-xs);
}

.chat-message.assistant .chat-bubble {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  color: var(--color-text);
  border-bottom-left-radius: var(--radius-xs);
}

/* Citation badges */
.citation-link {
  display: inline;
  padding: 2px 6px;
  margin: 0 2px;
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border: 1px solid var(--color-ai-border);
  border-radius: var(--radius-full);
  font-size: 10px;
  font-weight: var(--font-semibold);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.citation-link:hover {
  background: var(--color-ai);
  color: white;
  border-color: var(--color-ai);
}

/* Sources summary */
.chat-sources-summary {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  flex-wrap: wrap;
  font-size: 12px;
  color: var(--color-text-tertiary);
  margin-top: var(--space-1);
}

.sources-label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-weight: var(--font-medium);
}

.sources-label svg {
  width: 14px;
  height: 14px;
}

.sources-chips {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.retrieval-time {
  margin-left: auto;
  font-size: 11px;
  font-family: var(--font-mono);
  color: var(--color-muted);
  cursor: help;
}

.source-chip {
  padding: 3px 8px;
  background: var(--color-surface);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
  font-size: 11px;
  font-weight: var(--font-medium);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.source-chip:hover,
.source-chip.active {
  background: var(--color-ai);
  color: white;
  border-color: var(--color-ai);
}

/* Loading */
.loading-more {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-4);
  color: var(--color-text-tertiary);
  font-size: 13px;
}

.load-more-btn {
  width: 100%;
  margin-top: var(--space-3);
}

/* ============================================
   Toast - Clean notifications
   ============================================ */
.toast-container {
  position: fixed;
  bottom: var(--space-5);
  right: var(--space-5);
  z-index: 1100;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  pointer-events: none;
}

@media (max-width: 640px) {
  .toast-container {
    left: var(--space-4);
    right: var(--space-4);
    bottom: var(--space-4);
  }
}

.toast {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3) var(--space-4);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  font-size: 13px;
  font-weight: var(--font-medium);
  color: var(--color-text);
  pointer-events: auto;
  animation: toast-in 0.2s var(--ease-out);
}

.toast-icon {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-full);
  flex-shrink: 0;
}

.toast-icon svg {
  width: 14px;
  height: 14px;
}

.toast.success .toast-icon {
  color: var(--color-success);
}

.toast.error .toast-icon {
  color: var(--color-danger);
}

.toast.info .toast-icon {
  color: var(--color-primary);
}

@keyframes toast-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Error display */
.error-inline {
  margin-top: var(--space-3);
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-md);
  background: var(--color-danger-bg);
  border: 1px solid var(--color-danger-border);
  color: var(--color-danger);
  font-size: 13px;
}

/* Spinner */
.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--color-border);
  border-top-color: var(--color-primary);
  border-radius: var(--radius-full);
  animation: spin 0.6s linear infinite;
}

.btn-ai .spinner {
  border-color: rgba(255, 255, 255, 0.3);
  border-top-color: white;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* AI typing indicator */
.ai-typing {
  display: flex;
  align-items: center;
  gap: 4px;
}

.ai-typing span {
  width: 6px;
  height: 6px;
  background: var(--color-ai);
  border-radius: var(--radius-full);
  animation: typing-wave 1.2s ease-in-out infinite;
}

.ai-typing span:nth-child(2) {
  animation-delay: 0.1s;
}

.ai-typing span:nth-child(3) {
  animation-delay: 0.2s;
}

@keyframes typing-wave {
  0%, 60%, 100% {
    opacity: 0.4;
    transform: translateY(0);
  }
  30% {
    opacity: 1;
    transform: translateY(-3px);
  }
}

/* ============================================
   Notes Toolbar - Clean, functional
   ============================================ */
.notes-toolbar {
  display: flex;
  align-items: center;
  gap: 10px;
  padding-bottom: var(--space-4);
}

.search-box {
  position: relative;
  flex: 1;
}

.search-box svg {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--color-muted);
  pointer-events: none;
  width: 14px;
  height: 14px;
  transition: color var(--transition-fast);
}

.search-box:focus-within svg {
  color: var(--color-primary);
}

.search-input {
  width: 100%;
  padding: 9px 32px 9px 36px;
  border: 1px solid transparent;
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 13px;
  box-shadow: var(--shadow-xs);
  transition: all var(--transition-normal);
}

.search-input::placeholder {
  color: var(--color-muted);
}

.search-input:hover {
  box-shadow: var(--shadow-sm);
}

.search-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--shadow-sm), var(--ring);
}

.search-clear {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--color-bg-muted);
  border: none;
  border-radius: var(--radius-full);
  color: var(--color-muted);
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 10px;
  transition: all var(--transition-fast);
}

.search-clear:hover {
  background: var(--color-text);
  color: white;
}

.filter-tabs {
  display: flex;
  gap: 2px;
  padding: 3px;
  background: var(--color-surface);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xs);
}

.filter-tab {
  padding: 6px 12px;
  font-size: 11px;
  font-weight: var(--font-semibold);
  border: none;
  border-radius: var(--radius-md);
  background: transparent;
  color: var(--color-muted);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.filter-tab:hover:not(.active) {
  color: var(--color-text-secondary);
}

.filter-tab.active {
  background: var(--color-text);
  color: white;
}

/* Note highlighted */
.note-card.highlighted {
  border-color: var(--color-ai);
  background: var(--color-ai-bg);
}

.note-card.highlighted::before {
  background: var(--color-ai);
  height: 100%;
}

/* Search highlight */
.search-highlight,
mark.highlight {
  background: rgba(251, 191, 36, 0.25);
  color: inherit;
  padding: 1px 4px;
  border-radius: var(--radius-xs);
}


/* ============================================
   Sources Panel - Side drawer
   ============================================ */
.chat-panel-body {
  display: flex;
  gap: 0;
  height: 100%;
}

.chat-container.with-sources {
  flex: 1;
  min-width: 0;
}

/* Sources Modal Overlay */
.sources-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-4);
}

.sources-modal {
  width: 100%;
  max-width: 500px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  box-shadow: var(--shadow-2xl);
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-scale-in {
  animation: scale-in 0.2s var(--ease-out);
}

.sources-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--color-border-subtle);
}

.sources-modal-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.sources-count {
  padding: 2px 7px;
  font-size: 10px;
  font-weight: var(--font-bold);
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
}

.sources-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-5);
}

.sources-trust-hint {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 14px;
  margin-bottom: var(--space-4);
  background: rgba(34, 197, 94, 0.15);
  border: 1px solid rgba(34, 197, 94, 0.3);
  border-radius: var(--radius-lg);
  font-size: 13px;
  font-weight: var(--font-medium);
  color: #4ade80;
}

.sources-trust-hint svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.sources-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.source-card {
  padding: 16px;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  background: var(--color-bg);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.source-card:hover {
  border-color: var(--color-ai);
  background: var(--color-bg-subtle);
  box-shadow: var(--shadow-md);
}

.source-card.selected {
  border-color: var(--color-ai);
  background: var(--color-ai-muted);
}

.source-card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.source-badge {
  padding: 4px 10px;
  font-size: 11px;
  font-weight: var(--font-bold);
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
}

.source-score {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
}

.source-score svg {
  width: 12px;
  height: 12px;
}

.source-snippet {
  margin: 0 0 12px;
  font-size: 14px;
  line-height: var(--leading-relaxed);
  color: var(--color-text);
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.source-card-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-top: 12px;
  border-top: 1px solid var(--color-border-subtle);
}

.source-card-footer .btn {
  color: var(--color-ai);
  font-weight: var(--font-medium);
}

.source-time {
  font-size: 12px;
  color: var(--color-text-secondary);
}


/* ============================================
   Citation Tooltip - Premium popover
   ============================================ */
.citation-chip-wrapper {
  position: relative;
  display: inline;
}

.citation-chip {
  display: inline;
  padding: 2px 7px;
  margin: 0 2px;
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border: 1px solid var(--color-ai-border);
  border-radius: var(--radius-full);
  font-size: 10px;
  font-weight: var(--font-bold);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.citation-chip:hover {
  background: var(--color-ai);
  color: white;
  border-color: var(--color-ai);
}

.citation-tooltip {
  position: absolute;
  bottom: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%);
  width: 260px;
  padding: 14px;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-xl);
  z-index: 1000;
  pointer-events: none;
  animation: tooltip-in 0.15s var(--ease-out);
}

@keyframes tooltip-in {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.citation-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 7px solid transparent;
  border-top-color: var(--color-surface);
  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.05));
}

.citation-tooltip-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.citation-tooltip-badge {
  padding: 3px 8px;
  font-size: 10px;
  font-weight: var(--font-bold);
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
}

.citation-tooltip-score {
  font-size: 10px;
  color: var(--color-muted);
}

.citation-tooltip-text {
  margin: 0 0 10px;
  font-size: 12px;
  line-height: var(--leading-relaxed);
  color: var(--color-text);
}

.citation-tooltip-hint {
  font-size: 10px;
  font-weight: var(--font-medium);
  color: var(--color-ai);
}

/* Chat bubble states */
.chat-bubble-loading {
  display: flex;
  align-items: center;
  gap: 10px;
}

.chat-bubble-error {
  background: var(--color-danger-bg);
  border-color: var(--color-danger-border);
}

/* ============================================
   Note Detail Drawer - Modal overlay
   ============================================ */
.note-drawer-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-5);
  animation: modal-backdrop-in 0.25s var(--ease-out);
}

@keyframes modal-backdrop-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.note-drawer {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  box-shadow: var(--shadow-2xl);
  max-width: 580px;
  width: 100%;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  animation: modal-in 0.25s var(--ease-spring);
  overflow: hidden;
}

@keyframes modal-in {
  from {
    opacity: 0;
    transform: scale(0.96) translateY(12px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.note-drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--color-border-subtle);
  background: var(--color-surface);
}

.note-drawer-header h3 {
  display: flex;
  align-items: center;
  font-size: 15px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.note-drawer-body {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-6);
  background: var(--color-bg-subtle);
}

.note-detail-text {
  font-size: 15px;
  line-height: 1.8;
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--color-text);
}

.note-drawer-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  border-top: 1px solid var(--color-border-subtle);
  background: var(--color-surface);
}

.note-drawer-meta {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  font-size: 11px;
  color: var(--color-muted);
}

.note-drawer-time {
  display: flex;
  align-items: center;
}

.note-drawer-id {
  font-family: var(--font-mono);
  font-size: 10px;
  padding: 3px 8px;
  background: var(--color-bg-muted);
  color: var(--color-muted);
  border-radius: var(--radius-md);
}

.note-drawer-actions {
  display: flex;
  gap: 8px;
}

/* ============================================
   Utilities & Helpers
   ============================================ */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

*:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

::selection {
  background: rgba(220, 38, 38, 0.15);
  color: inherit;
}

/* Hover lift effect */
.hover-lift {
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.hover-lift:hover {
  transform: translateY(-2px);
}

/* Stagger animation for lists */
.stagger-children > * {
  animation: fade-slide-in 0.3s var(--ease-out) backwards;
}

.stagger-children > *:nth-child(1) { animation-delay: 0.02s; }
.stagger-children > *:nth-child(2) { animation-delay: 0.04s; }
.stagger-children > *:nth-child(3) { animation-delay: 0.06s; }
.stagger-children > *:nth-child(4) { animation-delay: 0.08s; }
.stagger-children > *:nth-child(5) { animation-delay: 0.10s; }

@keyframes fade-slide-in {
  from {
    opacity: 0;
    transform: translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Animations */
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Subtle glow for AI elements */
.glow-ai {
  box-shadow: 0 0 20px rgba(225, 29, 72, 0.15);
}

/* Gradient text */
.gradient-text {
  background: var(--brand-aurora);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* ============================================
   Mobile Optimizations
   ============================================ */
@media (max-width: 480px) {
  /* Reduce padding on very small screens */
  .app-shell {
    padding: var(--space-2);
  }

  .panel {
    border-radius: var(--radius-lg);
    min-height: 450px;
    max-height: calc(100vh - 140px);
    max-height: calc(100dvh - 140px);
  }

  .panel-header {
    padding: var(--space-3) var(--space-4);
  }

  .panel-body {
    padding: var(--space-3);
  }

  /* Composer optimization */
  .composer-input {
    min-height: 60px;
    font-size: 16px; /* Prevents iOS zoom on focus */
  }

  .composer-row {
    flex-wrap: wrap;
    gap: var(--space-2);
  }

  /* Chat input optimization */
  .chat-input {
    font-size: 16px; /* Prevents iOS zoom on focus */
    padding: var(--space-2) var(--space-3);
  }

  .chat-input-row {
    gap: var(--space-2);
  }

  /* Chat messages */
  .chat-bubble {
    padding: var(--space-3);
    font-size: 14px;
    max-width: 95%;
  }

  .chat-empty {
    padding: var(--space-4);
  }

  .chat-empty h3 {
    font-size: 16px;
  }

  .chat-empty p {
    font-size: 13px;
  }

  /* Suggestions on mobile */
  .chat-suggestions {
    flex-wrap: wrap;
    gap: var(--space-2);
    padding: var(--space-2) 0;
  }

  .suggestion-chip {
    font-size: 12px;
    padding: var(--space-2) var(--space-3);
  }

  /* Note cards */
  .note-card {
    padding: var(--space-3);
  }

  .note-text {
    font-size: 14px;
    line-height: 1.5;
  }

  /* Sources modal - full screen on mobile */
  .sources-modal-overlay {
    padding: 0;
    align-items: flex-end;
  }

  .sources-modal {
    max-width: 100%;
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  .sources-modal-body {
    padding: var(--space-4);
  }

  .source-card {
    padding: var(--space-3);
  }

  /* Note drawer - full screen on mobile */
  .note-drawer-backdrop {
    padding: 0;
    align-items: flex-end;
  }

  .note-drawer {
    max-width: 100%;
    max-height: 90vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  .note-drawer-body {
    padding: var(--space-4);
  }

  /* Citation tooltip - wider on mobile */
  .citation-tooltip {
    width: 220px;
    padding: var(--space-3);
  }

  /* Header simplification */
  .app-header {
    padding: var(--space-2) var(--space-3);
    margin-bottom: var(--space-3);
  }

  .app-logo {
    width: 28px;
    height: 28px;
  }

  .app-title h1 {
    font-size: 16px;
  }

  /* Mobile tabs */
  .mobile-tabs {
    margin-bottom: var(--space-3);
  }

  .mobile-tabs button {
    padding: var(--space-2) var(--space-3);
    font-size: 13px;
  }

  /* Rate limit notice */
  .rate-limit-notice {
    font-size: 12px;
    padding: var(--space-2);
  }

  /* Character count */
  .chat-char-count {
    font-size: 11px;
  }

  /* Toolbar and filters */
  .notes-toolbar {
    flex-direction: column;
    gap: var(--space-2);
  }

  .filter-tabs {
    width: 100%;
    justify-content: space-between;
  }

  .filter-tab {
    flex: 1;
    text-align: center;
  }

  .search-box {
    width: 100%;
  }
}

/* Touch-friendly tap targets */
@media (hover: none) and (pointer: coarse) {
  .btn {
    min-height: 44px;
    min-width: 44px;
  }

  .btn-sm {
    min-height: 36px;
    min-width: 36px;
  }

  .btn-icon {
    min-height: 44px;
    min-width: 44px;
  }

  .filter-tab {
    min-height: 40px;
  }

  .mobile-tabs button {
    min-height: 44px;
  }

  .note-card {
    padding: var(--space-4);
  }

  .citation-chip {
    padding: 4px 10px;
    font-size: 11px;
  }

  .source-chip {
    padding: 6px 12px;
    min-height: 32px;
  }
}

/* Safe area insets for notched devices */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
  .app-shell {
    padding-bottom: calc(var(--space-3) + env(safe-area-inset-bottom));
  }

  .chat-input-area {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .sources-modal,
  .note-drawer {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .toast-container {
    bottom: calc(var(--space-4) + env(safe-area-inset-bottom));
  }
}


================================================
EXPORT SUMMARY
Total files: 27
Total lines:     4806
================================================
