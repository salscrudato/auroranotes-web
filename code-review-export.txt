==================================================
CODE REVIEW EXPORT
Generated: Sat Dec 20 12:38:24 EST 2025
Project: auroranotes-web
==================================================

==================================================
FILE: ./eslint.config.js
==================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


==================================================
FILE: ./firebase.json
==================================================

{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "/assets/**",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      },
      {
        "source": "**/*.@(js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ]
  }
}



==================================================
FILE: ./index.html
==================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#dc2626" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="AuroraNotes" />

    <!-- SEO Meta Tags -->
    <meta name="description" content="AI-powered note-taking with intelligent search and retrieval. Ask questions about your notes and get instant answers with citations." />
    <meta name="keywords" content="notes, AI, search, RAG, productivity, knowledge base" />
    <meta name="author" content="AuroraNotes" />

    <!-- Open Graph -->
    <meta property="og:title" content="AuroraNotes – AI-Powered Notes" />
    <meta property="og:description" content="AI-powered note-taking with intelligent search and retrieval." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/icons/og-image.png" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="AuroraNotes – AI-Powered Notes" />
    <meta name="twitter:description" content="AI-powered note-taking with intelligent search and retrieval." />

    <title>AuroraNotes – AI-Powered Notes</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />

    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <noscript>
      <div style="padding: 2rem; text-align: center; font-family: system-ui, sans-serif;">
        <h1>JavaScript Required</h1>
        <p>AuroraNotes requires JavaScript to run. Please enable JavaScript in your browser settings.</p>
      </div>
    </noscript>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


==================================================
FILE: ./package.json
==================================================

{
  "name": "auroranotes-web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "lucide-react": "^0.561.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.1.18",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "tailwindcss": "^4.1.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


==================================================
FILE: ./public/manifest.json
==================================================

{
  "name": "AuroraNotes AI",
  "short_name": "AuroraNotes",
  "description": "AI-powered note-taking with intelligent search and retrieval",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0f0f0f",
  "theme_color": "#dc2626",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "categories": ["productivity", "utilities"],
  "lang": "en-US",
  "dir": "ltr"
}



==================================================
FILE: ./src/App.tsx
==================================================

/**
 * AuroraNotes AI - Main App Entry
 *
 * This is a thin composition layer that sets up providers and renders the shell.
 * Shows landing page first, then main app after user clicks "Enter App".
 */

import { useState, useCallback } from 'react';
import './styles/app.css';
import { ThemeProvider } from './lib/ThemeContext';
import { ToastProvider } from './components/common/Toast';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import { AppShell } from './components/layout/AppShell';
import { HowItWorks } from './components/landing/HowItWorks';

const STORAGE_KEY = 'auroranotes_has_entered';

// Read from localStorage synchronously to avoid flash
function getInitialHasEntered(): boolean {
  try {
    return localStorage.getItem(STORAGE_KEY) === 'true';
  } catch {
    // localStorage may not be available (SSR, private browsing, etc.)
    return false;
  }
}

export default function App() {
  // Initialize synchronously to avoid flash of wrong content
  const [hasEntered, setHasEntered] = useState(getInitialHasEntered);

  const handleEnterApp = useCallback(() => {
    try {
      localStorage.setItem(STORAGE_KEY, 'true');
    } catch {
      // Ignore localStorage errors
    }
    setHasEntered(true);
  }, []);

  // Soft return to landing - doesn't clear localStorage so refresh returns to app
  const handleShowLanding = useCallback(() => {
    setHasEntered(false);
  }, []);

  return (
    <ErrorBoundary>
      <ThemeProvider>
        <ToastProvider>
          {hasEntered ? (
            <AppShell onShowHowItWorks={handleShowLanding} />
          ) : (
            <HowItWorks onEnterApp={handleEnterApp} />
          )}
        </ToastProvider>
      </ThemeProvider>
    </ErrorBoundary>
  );
}


==================================================
FILE: ./src/components/chat/ChatMessage.tsx
==================================================

/**
 * ChatMessage component
 * Renders chat messages with inline source chips and sources summary
 */

import { memo, useCallback, useMemo } from 'react';
import { BookOpen, AlertCircle, RotateCcw, Copy } from 'lucide-react';
import type { ChatMessage as ChatMessageType, Source } from '../../lib/types';
import { parseSources, getReferencedSources } from '../../lib/citations';
import { formatRelativeTime } from '../../lib/format';
import { copyToClipboard, cn } from '../../lib/utils';
import { useToast } from '../common/useToast';
import { SourceRefChip, SourceBadge } from './CitationChip';
import { ConfidenceIndicator } from './ConfidenceIndicator';

interface ChatMessageProps {
  message: ChatMessageType;
  onSourceClick: (source: Source) => void;
  activeSourceId?: string | null;
  onRetry?: () => void;
  showTimestamp?: boolean;
}

export const ChatMessage = memo(function ChatMessage({
  message,
  onSourceClick,
  activeSourceId,
  onRetry,
  showTimestamp = true,
}: ChatMessageProps) {
  const { showToast } = useToast();
  const isUser = message.role === 'user';
  const isError = message.isError;
  const isStreaming = message.isStreaming;
  const segments = parseSources(message.content, message.sources);
  const referencedSources = getReferencedSources(message.content, message.sources);

  // Get all sources: combine cited sources with context sources, avoiding duplicates
  const allSources = useMemo(() => {
    const citedIds = new Set(referencedSources.map(s => s.noteId));
    const contextSources = (message.contextSources || []).filter(s => !citedIds.has(s.noteId));
    return {
      cited: referencedSources,
      context: contextSources,
      hasAny: referencedSources.length > 0 || contextSources.length > 0,
    };
  }, [referencedSources, message.contextSources]);

  // Show retry button for 503 and 5xx errors
  const showRetry = isError && onRetry && (message.errorCode === 503 || (message.errorCode && message.errorCode >= 500));

  const handleCopy = useCallback(async () => {
    const success = await copyToClipboard(message.content);
    showToast(success ? 'Copied' : 'Failed to copy', success ? 'success' : 'error');
  }, [message.content, showToast]);

  return (
    <div className={cn('chat-message', isUser ? 'user' : 'assistant', isStreaming && 'streaming')}>
      <div className={cn('chat-bubble', isError && 'chat-bubble-error')}>
        {isError && <AlertCircle size={14} className="error-icon" />}
        {segments.map((segment, i) => {
          if (segment.type === 'source' && segment.source) {
            return (
              <SourceRefChip
                key={`${segment.source.id}-${i}`}
                source={segment.source}
                onClick={onSourceClick}
              />
            );
          }
          return <span key={i}>{segment.content}</span>;
        })}
        {isStreaming && <span className="streaming-cursor" />}
        {showRetry && (
          <button className="btn btn-sm btn-ghost retry-btn" onClick={onRetry}>
            <RotateCcw size={12} />
            Retry
          </button>
        )}
      </div>

      {/* Message meta: timestamp, copy, sources, confidence */}
      <div className="chat-message-meta">
        {showTimestamp && !isStreaming && (
          <span className="chat-timestamp">
            {formatRelativeTime(message.timestamp)}
          </span>
        )}

        {/* Confidence indicator for assistant messages */}
        {!isUser && !isError && !isStreaming && message.meta?.confidence && (
          <ConfidenceIndicator
            confidence={message.meta.confidence}
            sourceCount={message.meta.sourceCount}
          />
        )}

        {/* Copy button for assistant messages */}
        {!isUser && !isError && !isStreaming && (
          <button
            className="btn btn-icon btn-ghost btn-sm chat-copy-btn"
            onClick={handleCopy}
            title="Copy message"
            aria-label="Copy message"
          >
            <Copy size={12} />
          </button>
        )}

        {/* Sources summary for assistant messages - shows both cited and context sources */}
        {!isUser && !isError && allSources.hasAny && (
          <div className="chat-sources-summary">
            {/* Cited sources - directly referenced in the answer */}
            {allSources.cited.length > 0 && (
              <>
                <span className="sources-label">
                  <BookOpen size={14} />
                  Cited:
                </span>
                <div className="sources-chips">
                  {allSources.cited.map((source) => (
                    <SourceBadge
                      key={source.id}
                      id={source.id}
                      onClick={() => onSourceClick(source)}
                      isActive={source.id === activeSourceId}
                    />
                  ))}
                </div>
              </>
            )}

            {/* Context sources - used for context but not directly cited */}
            {allSources.context.length > 0 && (
              <>
                <span className="sources-label sources-label-context">
                  <BookOpen size={14} />
                  Context:
                </span>
                <div className="sources-chips sources-chips-context">
                  {allSources.context.map((source) => (
                    <SourceBadge
                      key={source.id}
                      id={source.id}
                      onClick={() => onSourceClick(source)}
                      isActive={source.id === activeSourceId}
                      variant="context"
                    />
                  ))}
                </div>
              </>
            )}

            {message.meta?.responseTimeMs && (
              <span className="response-time" title={`Response time`}>
                {message.meta.responseTimeMs}ms
              </span>
            )}
          </div>
        )}
      </div>
    </div>
  );
});

/**
 * Loading state message bubble with AI typing indicator
 */
export function ChatMessageLoading() {
  return (
    <div className="chat-message assistant animate-fade-in">
      <div className="chat-bubble chat-bubble-loading">
        <div className="ai-typing">
          <span></span>
          <span></span>
          <span></span>
        </div>
        <span className="text-muted">Searching your notes...</span>
      </div>
    </div>
  );
}

/**
 * Error state message with retry option
 */
interface ChatMessageErrorProps {
  error: string;
  onRetry?: () => void;
}

export function ChatMessageError({ error, onRetry }: ChatMessageErrorProps) {
  return (
    <div className="chat-message assistant">
      <div className="chat-bubble chat-bubble-error">
        <AlertCircle size={14} />
        <span>{error || 'Something went wrong. Please try again.'}</span>
        {onRetry && (
          <button className="btn btn-sm btn-ghost" onClick={onRetry}>
            Retry
          </button>
        )}
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/chat/ChatPanel.tsx
==================================================

/**
 * ChatPanel component
 * RAG-powered chat with inline source references, streaming support, and feedback
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import {
  Sparkles,
  BookOpen,
  ArrowUp,
  FileText,
  ListChecks,
  HelpCircle,
  CheckSquare,
  ThumbsUp,
  ThumbsDown,
  Trash2,
  Square,
  Send,
  X,
} from 'lucide-react';
import type { ChatMessage as ChatMessageType, Source, FeedbackRating } from '../../lib/types';
import { useChat } from '../../hooks/useChat';
import { submitFeedback, ApiRequestError } from '../../lib/api';
import { useToast } from '../common/useToast';
import { ChatMessage, ChatMessageLoading } from './ChatMessage';
import { SourcesPanel } from './SourcesPanel';

interface ChatPanelProps {
  className?: string;
  onOpenNote?: (noteId: string, preview?: string) => void;
}

const MAX_MESSAGE_LENGTH = 2000;

const SUGGESTIONS = [
  { label: 'Summarize my notes', prompt: 'Summarize my recent notes from this week', Icon: FileText },
  { label: 'What decisions did I make?', prompt: 'What decisions did I make recently?', Icon: ListChecks },
  { label: 'Open questions', prompt: 'What are my open questions or unresolved items?', Icon: HelpCircle },
  { label: 'Find action items', prompt: 'List action items from my notes', Icon: CheckSquare },
];

export function ChatPanel({ className = '', onOpenNote }: ChatPanelProps) {
  const {
    messages,
    loadingState,
    sendMessage,
    retryLastMessage,
    clearChat,
    cancelStream,
  } = useChat({ streaming: true }); // Streaming SSE by default per API spec

  const [input, setInput] = useState('');
  const [showSources, setShowSources] = useState(false);
  const [activeSources, setActiveSources] = useState<Source[]>([]);
  const [selectedSourceId, setSelectedSourceId] = useState<string | null>(null);
  const [feedbackSent, setFeedbackSent] = useState<Set<string>>(new Set());
  const [rateLimitCountdown, setRateLimitCountdown] = useState<number | null>(null);
  // Feedback comment state for thumbs-down
  const [feedbackCommentFor, setFeedbackCommentFor] = useState<string | null>(null);
  const [feedbackComment, setFeedbackComment] = useState('');
  const [feedbackSubmitting, setFeedbackSubmitting] = useState(false);

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const countdownRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const { showToast } = useToast();

  const isLoading = loadingState === 'sending' || loadingState === 'streaming';

  // Cleanup countdown interval on unmount
  useEffect(() => {
    return () => {
      if (countdownRef.current) {
        clearInterval(countdownRef.current);
      }
    };
  }, []);

  // Start rate limit countdown
  const startRateLimitCountdown = useCallback((seconds: number) => {
    setRateLimitCountdown(seconds);

    if (countdownRef.current) {
      clearInterval(countdownRef.current);
    }

    countdownRef.current = setInterval(() => {
      setRateLimitCountdown(prev => {
        if (prev === null || prev <= 1) {
          if (countdownRef.current) {
            clearInterval(countdownRef.current);
            countdownRef.current = null;
          }
          return null;
        }
        return prev - 1;
      });
    }, 1000);
  }, []);

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, scrollToBottom]);

  // Collect all sources from messages for sources panel
  useEffect(() => {
    const allSources: Source[] = [];
    const seen = new Set<string>();

    for (const msg of messages) {
      if (msg.sources) {
        for (const s of msg.sources) {
          if (!seen.has(s.id)) {
            seen.add(s.id);
            allSources.push(s);
          }
        }
      }
    }

    setActiveSources(allSources);
  }, [messages]);

  const handleSend = useCallback(async (text?: string) => {
    const messageText = (text || input).trim();
    if (!messageText || isLoading || rateLimitCountdown !== null) return;

    if (messageText.length > MAX_MESSAGE_LENGTH) {
      showToast(`Message too long. Maximum ${MAX_MESSAGE_LENGTH} characters.`, 'error');
      return;
    }

    setInput('');

    try {
      await sendMessage(messageText);
    } catch (err) {
      if (err instanceof ApiRequestError) {
        if (err.status === 429) {
          const retrySeconds = err.retryAfterSeconds || 30;
          startRateLimitCountdown(retrySeconds);
        }
        showToast(err.getUserMessage(), 'error');
      }
    } finally {
      inputRef.current?.focus();
    }
  }, [input, isLoading, rateLimitCountdown, showToast, sendMessage, startRateLimitCountdown]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  }, [handleSend]);

  const handleSuggestionClick = useCallback((prompt: string) => {
    handleSend(prompt);
  }, [handleSend]);

  const handleSourceClick = useCallback((source: Source) => {
    setSelectedSourceId(source.id);
    setShowSources(true);
  }, []);

  const handleOpenNote = useCallback((noteId: string, preview?: string) => {
    onOpenNote?.(noteId, preview);
    setShowSources(false);
  }, [onOpenNote]);

  const handleRetry = useCallback(async () => {
    await retryLastMessage();
  }, [retryLastMessage]);

  const handleFeedback = useCallback(async (message: ChatMessageType, rating: FeedbackRating, comment?: string) => {
    const requestId = message.meta?.requestId;
    if (!requestId) {
      showToast('Cannot submit feedback: missing request ID', 'error');
      return;
    }

    // Check if already submitted
    if (feedbackSent.has(requestId)) {
      showToast('Feedback already submitted', 'info');
      return;
    }

    // For thumbs-down, show comment input first (unless already submitting with comment)
    if (rating === 'down' && !comment && feedbackCommentFor !== requestId) {
      setFeedbackCommentFor(requestId);
      setFeedbackComment('');
      return;
    }

    setFeedbackSubmitting(true);
    try {
      await submitFeedback(requestId, rating, comment?.trim() || undefined);
      setFeedbackSent(prev => new Set(prev).add(requestId));
      setFeedbackCommentFor(null);
      setFeedbackComment('');
      showToast(rating === 'up' ? 'Thanks for the feedback!' : 'Thanks, we\'ll improve', 'success');
    } catch (err) {
      const msg = err instanceof ApiRequestError ? err.getUserMessage() : 'Failed to submit feedback';
      showToast(msg, 'error');
    } finally {
      setFeedbackSubmitting(false);
    }
  }, [feedbackSent, feedbackCommentFor, showToast]);

  const handleCancelFeedbackComment = useCallback(() => {
    setFeedbackCommentFor(null);
    setFeedbackComment('');
  }, []);

  const handleSubmitFeedbackWithComment = useCallback(async (message: ChatMessageType) => {
    await handleFeedback(message, 'down', feedbackComment);
  }, [handleFeedback, feedbackComment]);

  const handleCancelStream = useCallback(() => {
    cancelStream();
  }, [cancelStream]);

  const handleClearChat = useCallback(() => {
    clearChat();
    setFeedbackSent(new Set());
    setShowSources(false);
    setSelectedSourceId(null);
  }, [clearChat]);

  const hasSources = activeSources.length > 0;

  return (
    <div className={`panel ${className}`}>
      <div className="panel-header">
        <h2>
          <Sparkles size={16} />
          Ask Aurora
        </h2>
        <div className="header-actions-row">
          {hasSources && (
            <button
              className={`btn btn-sm ${showSources ? 'btn-ai' : 'btn-ghost'}`}
              onClick={() => setShowSources(!showSources)}
              aria-label={showSources ? 'Hide sources' : 'Show sources'}
            >
              <BookOpen size={14} />
              {activeSources.length} sources
            </button>
          )}
          {messages.length > 0 && (
            <button
              className="btn btn-sm btn-ghost"
              onClick={handleClearChat}
              aria-label="Clear chat"
              title="Clear chat history"
            >
              <Trash2 size={14} />
            </button>
          )}
        </div>
      </div>

      <div className="panel-body chat-panel-body">
        <div className="chat-container">
          {/* Suggestion Chips */}
          {messages.length === 0 && (
            <div className="chat-suggestions stagger-children">
              {SUGGESTIONS.map((suggestion) => (
                <button
                  key={suggestion.prompt}
                  className="suggestion-chip"
                  onClick={() => handleSuggestionClick(suggestion.prompt)}
                  disabled={isLoading}
                >
                  <suggestion.Icon size={15} className="suggestion-icon" />
                  <span>{suggestion.label}</span>
                </button>
              ))}
            </div>
          )}

          {/* Messages Area */}
          <div className="chat-messages">
            {messages.length === 0 ? (
              <div className="chat-empty">
                <div className="chat-empty-icon">
                  <Sparkles size={28} />
                </div>
                <h3>Your AI-powered memory</h3>
                <p>
                  Ask questions and get instant answers with sources from your notes.
                </p>
              </div>
            ) : (
              messages.map((message, idx) => (
                <div key={message.id} className="chat-message-wrapper">
                  <ChatMessage
                    message={message}
                    onSourceClick={handleSourceClick}
                    activeSourceId={selectedSourceId}
                    onRetry={message.isError && idx === messages.length - 1 ? handleRetry : undefined}
                  />
                  {/* Feedback buttons for assistant messages with requestId */}
                  {message.role === 'assistant' &&
                    !message.isError &&
                    !message.isStreaming &&
                    message.meta?.requestId && (
                      <div className="chat-feedback">
                        {feedbackSent.has(message.meta.requestId) ? (
                          <span className="feedback-thanks">Thanks for feedback</span>
                        ) : feedbackCommentFor === message.meta.requestId ? (
                          // Thumbs-down comment input
                          <div className="feedback-comment-form">
                            <input
                              type="text"
                              className="feedback-comment-input"
                              value={feedbackComment}
                              onChange={(e) => setFeedbackComment(e.target.value.slice(0, 1000))}
                              placeholder="What went wrong? (optional)"
                              aria-label="Feedback comment"
                              maxLength={1000}
                              disabled={feedbackSubmitting}
                              autoFocus
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  e.preventDefault();
                                  handleSubmitFeedbackWithComment(message);
                                } else if (e.key === 'Escape') {
                                  handleCancelFeedbackComment();
                                }
                              }}
                            />
                            <button
                              className="btn btn-icon btn-ghost btn-sm"
                              onClick={() => handleSubmitFeedbackWithComment(message)}
                              disabled={feedbackSubmitting}
                              aria-label="Submit feedback"
                              title="Submit feedback"
                            >
                              {feedbackSubmitting ? <span className="spinner" /> : <Send size={14} />}
                            </button>
                            <button
                              className="btn btn-icon btn-ghost btn-sm"
                              onClick={handleCancelFeedbackComment}
                              disabled={feedbackSubmitting}
                              aria-label="Cancel"
                              title="Cancel"
                            >
                              <X size={14} />
                            </button>
                          </div>
                        ) : (
                          <>
                            <button
                              className="btn btn-icon btn-ghost btn-sm feedback-btn"
                              onClick={() => handleFeedback(message, 'up')}
                              aria-label="Good response"
                              title="Good response"
                            >
                              <ThumbsUp size={14} />
                            </button>
                            <button
                              className="btn btn-icon btn-ghost btn-sm feedback-btn"
                              onClick={() => handleFeedback(message, 'down')}
                              aria-label="Poor response"
                              title="Poor response"
                            >
                              <ThumbsDown size={14} />
                            </button>
                          </>
                        )}
                      </div>
                    )}
                </div>
              ))
            )}
            {loadingState === 'sending' && <ChatMessageLoading />}
            <div ref={messagesEndRef} />
          </div>

          {/* Input Area */}
          <div className="chat-input-area">
            {rateLimitCountdown !== null && (
              <div className="rate-limit-notice">
                Rate limited. Try again in {rateLimitCountdown}s
              </div>
            )}
            <div className="chat-input-row">
              <input
                ref={inputRef}
                type="text"
                className={`chat-input ${input.trim().length > MAX_MESSAGE_LENGTH ? 'input-error' : ''}`}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={rateLimitCountdown !== null ? `Wait ${rateLimitCountdown}s...` : 'Ask a question...'}
                aria-label="Chat input"
                disabled={isLoading || rateLimitCountdown !== null}
                maxLength={MAX_MESSAGE_LENGTH + 100}
              />
              {loadingState === 'streaming' ? (
                <button
                  className="btn btn-ghost btn-icon"
                  onClick={handleCancelStream}
                  aria-label="Stop generating"
                  title="Stop generating"
                >
                  <Square size={16} />
                </button>
              ) : (
                <button
                  className="btn btn-primary btn-icon"
                  onClick={() => handleSend()}
                  disabled={!input.trim() || input.trim().length > MAX_MESSAGE_LENGTH || isLoading || rateLimitCountdown !== null}
                  aria-label="Send message"
                >
                  {loadingState === 'sending' ? <span className="spinner" /> : <ArrowUp size={18} />}
                </button>
              )}
            </div>
            {input.trim().length > 0 && (
              <div className={`chat-char-count ${input.trim().length > MAX_MESSAGE_LENGTH ? 'over-limit' : ''}`}>
                {input.trim().length.toLocaleString()} / {MAX_MESSAGE_LENGTH.toLocaleString()}
              </div>
            )}
          </div>
        </div>

        {/* Sources Panel */}
        {showSources && (
          <SourcesPanel
            sources={activeSources}
            selectedSourceId={selectedSourceId}
            onSelectSource={setSelectedSourceId}
            onOpenNote={handleOpenNote}
            onClose={() => setShowSources(false)}
          />
        )}
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/chat/CitationChip.tsx
==================================================

/**
 * Source/Citation chip components
 * Clickable inline chips that replace [1], [2] source tokens
 * Shows tooltip preview and triggers sources panel on click
 */

import { useState, useRef, useEffect, memo, useCallback } from 'react';
import type { Source, Citation } from '../../lib/types';
import { formatPreview, formatSnippet } from '../../lib/citations';
import { cn } from '../../lib/utils';

// ============================================
// New Source-based Components
// ============================================

interface SourceRefChipProps {
  source: Source;
  onClick: (source: Source) => void;
}

/**
 * Inline source reference chip with tooltip
 * Replaces [1], [2] tokens in chat messages
 */
export const SourceRefChip = memo(function SourceRefChip({ source, onClick }: SourceRefChipProps) {
  const [showTooltip, setShowTooltip] = useState(false);
  const chipRef = useRef<HTMLButtonElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);

  // Position tooltip to avoid overflow
  useEffect(() => {
    if (showTooltip && tooltipRef.current && chipRef.current) {
      const tooltip = tooltipRef.current;
      const viewportWidth = window.innerWidth;

      tooltip.style.left = '50%';
      tooltip.style.transform = 'translateX(-50%)';

      const tooltipRect = tooltip.getBoundingClientRect();
      if (tooltipRect.right > viewportWidth - 8) {
        tooltip.style.left = 'auto';
        tooltip.style.right = '0';
        tooltip.style.transform = 'none';
      }
      if (tooltipRect.left < 8) {
        tooltip.style.left = '0';
        tooltip.style.right = 'auto';
        tooltip.style.transform = 'none';
      }
    }
  }, [showTooltip]);

  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onClick(source);
  };

  const preview = formatPreview(source.preview, 100);
  const relevancePercent = Math.round(source.relevance * 100);

  const handleMouseEnter = useCallback(() => setShowTooltip(true), []);
  const handleMouseLeave = useCallback(() => setShowTooltip(false), []);

  return (
    <span className="source-chip-wrapper">
      <button
        ref={chipRef}
        className="source-ref-chip"
        onClick={handleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onFocus={handleMouseEnter}
        onBlur={handleMouseLeave}
        aria-label={`Source ${source.id}: ${preview}`}
        title=""
      >
        [{source.id}]
      </button>

      {showTooltip && (
        <div ref={tooltipRef} className="source-tooltip" role="tooltip">
          <div className="source-tooltip-header">
            <span className="source-tooltip-badge">[{source.id}]</span>
            {source.relevance > 0 && (
              <span className="source-tooltip-score">
                {relevancePercent}% match
              </span>
            )}
          </div>
          <p className="source-tooltip-text">{preview}</p>
          <div className="source-tooltip-footer">
            <span className="source-tooltip-date">{source.date}</span>
            <span className="source-tooltip-hint">Click to view</span>
          </div>
        </div>
      )}
    </span>
  );
});

/**
 * Small badge for source lists
 * variant="context" shows a muted style for context sources (not directly cited)
 */
interface SourceBadgeProps {
  id: string;
  onClick: () => void;
  isActive?: boolean;
  variant?: 'cited' | 'context';
}

export const SourceBadge = memo(function SourceBadge({
  id,
  onClick,
  isActive = false,
  variant = 'cited',
}: SourceBadgeProps) {
  return (
    <button
      className={cn(
        'source-badge-chip',
        isActive && 'active',
        variant === 'context' && 'context'
      )}
      onClick={onClick}
      aria-label={`View source ${id}`}
      title={variant === 'context' ? 'Context source (not directly cited)' : undefined}
    >
      [{id}]
    </button>
  );
});

// ============================================
// Legacy Citation Components (deprecated)
// ============================================

interface CitationChipProps {
  citation: Citation;
  onClick: (citation: Citation) => void;
}

/**
 * @deprecated Use SourceRefChip instead
 */
export const CitationChip = memo(function CitationChip({ citation, onClick }: CitationChipProps) {
  const [showTooltip, setShowTooltip] = useState(false);
  const chipRef = useRef<HTMLButtonElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (showTooltip && tooltipRef.current && chipRef.current) {
      const tooltip = tooltipRef.current;
      const viewportWidth = window.innerWidth;

      tooltip.style.left = '50%';
      tooltip.style.transform = 'translateX(-50%)';

      const tooltipRect = tooltip.getBoundingClientRect();
      if (tooltipRect.right > viewportWidth - 8) {
        tooltip.style.left = 'auto';
        tooltip.style.right = '0';
        tooltip.style.transform = 'none';
      }
      if (tooltipRect.left < 8) {
        tooltip.style.left = '0';
        tooltip.style.right = 'auto';
        tooltip.style.transform = 'none';
      }
    }
  }, [showTooltip]);

  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onClick(citation);
  };

  const snippetPreview = formatSnippet(citation.snippet, 100);

  const handleMouseEnter = useCallback(() => setShowTooltip(true), []);
  const handleMouseLeave = useCallback(() => setShowTooltip(false), []);

  return (
    <span className="citation-chip-wrapper">
      <button
        ref={chipRef}
        className="citation-chip"
        onClick={handleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onFocus={handleMouseEnter}
        onBlur={handleMouseLeave}
        aria-label={`Source ${citation.cid}: ${snippetPreview}`}
        title=""
      >
        {citation.cid}
      </button>

      {showTooltip && (
        <div ref={tooltipRef} className="citation-tooltip" role="tooltip">
          <div className="citation-tooltip-header">
            <span className="citation-tooltip-badge">{citation.cid}</span>
            <span className="citation-tooltip-score">
              {Math.round(citation.score * 100)}% match
            </span>
          </div>
          <p className="citation-tooltip-text">{snippetPreview}</p>
          <div className="citation-tooltip-hint">Click to view source</div>
        </div>
      )}
    </span>
  );
});

/**
 * @deprecated Use SourceBadge instead
 */
interface SourceChipProps {
  cid: string;
  onClick: () => void;
  isActive?: boolean;
}

export const SourceChip = memo(function SourceChip({ cid, onClick, isActive = false }: SourceChipProps) {
  return (
    <button
      className={cn('source-chip', isActive && 'active')}
      onClick={onClick}
      aria-label={`View source ${cid}`}
    >
      {cid}
    </button>
  );
});



==================================================
FILE: ./src/components/chat/ConfidenceIndicator.tsx
==================================================

/**
 * ConfidenceIndicator component
 * Displays confidence level with appropriate icon and styling
 * Based on the API confidence levels: high, medium, low, none
 */

import { memo } from 'react';
import { CheckCircle, Info, HelpCircle, AlertTriangle } from 'lucide-react';
import type { ConfidenceLevel } from '../../lib/types';
import { cn } from '../../lib/utils';

interface ConfidenceIndicatorProps {
  confidence: ConfidenceLevel;
  sourceCount: number;
  className?: string;
  showLabel?: boolean;
}

const confidenceConfig: Record<ConfidenceLevel, {
  Icon: typeof CheckCircle;
  label: string;
  description: (count: number) => string;
  className: string;
}> = {
  high: {
    Icon: CheckCircle,
    label: 'High confidence',
    description: (count) => `Based on ${count} source${count !== 1 ? 's' : ''}`,
    className: 'confidence-high',
  },
  medium: {
    Icon: Info,
    label: 'Medium confidence',
    description: () => 'Partially based on notes',
    className: 'confidence-medium',
  },
  low: {
    Icon: HelpCircle,
    label: 'Low confidence',
    description: () => 'Limited information found',
    className: 'confidence-low',
  },
  none: {
    Icon: AlertTriangle,
    label: 'No sources',
    description: () => 'No relevant notes found',
    className: 'confidence-none',
  },
};

export const ConfidenceIndicator = memo(function ConfidenceIndicator({
  confidence,
  sourceCount,
  className,
  showLabel = true,
}: ConfidenceIndicatorProps) {
  const config = confidenceConfig[confidence];
  const { Icon } = config;

  return (
    <div
      className={cn('confidence-indicator', config.className, className)}
      title={config.label}
      role="status"
      aria-label={`${config.label}: ${config.description(sourceCount)}`}
    >
      <Icon size={14} className="confidence-icon" aria-hidden="true" />
      {showLabel && (
        <span className="confidence-text">
          {config.description(sourceCount)}
        </span>
      )}
    </div>
  );
});

/**
 * Compact confidence badge for inline use
 */
interface ConfidenceBadgeProps {
  confidence: ConfidenceLevel;
  className?: string;
}

export const ConfidenceBadge = memo(function ConfidenceBadge({
  confidence,
  className,
}: ConfidenceBadgeProps) {
  const config = confidenceConfig[confidence];
  const { Icon } = config;

  return (
    <span
      className={cn('confidence-badge', config.className, className)}
      title={config.label}
      role="status"
      aria-label={config.label}
    >
      <Icon size={12} aria-hidden="true" />
    </span>
  );
});



==================================================
FILE: ./src/components/chat/SourcesPanel.tsx
==================================================

/**
 * SourcesPanel component
 * Shows sources in a modal dialog
 * Allows viewing source previews and navigating to full notes
 */

import { useEffect, useRef } from 'react';
import { BookOpen, X, ShieldCheck, ArrowRight } from 'lucide-react';
import type { Source } from '../../lib/types';
import { formatPreview, getConfidenceFromRelevance } from '../../lib/citations';

interface SourcesPanelProps {
  sources: Source[];
  selectedSourceId: string | null;
  onSelectSource: (id: string | null) => void;
  onOpenNote: (noteId: string, preview?: string) => void;
  onClose: () => void;
}

export function SourcesPanel({
  sources,
  selectedSourceId,
  onSelectSource,
  onOpenNote,
  onClose,
}: SourcesPanelProps) {
  const panelRef = useRef<HTMLDivElement>(null);
  const selectedRef = useRef<HTMLDivElement>(null);

  // Scroll to selected source when it changes
  useEffect(() => {
    if (selectedSourceId && selectedRef.current) {
      selectedRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }, [selectedSourceId]);

  // Close on Escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onClose]);

  if (sources.length === 0) return null;

  return (
    <div className="sources-modal-overlay" onClick={onClose}>
      <div
        className="sources-modal animate-scale-in"
        ref={panelRef}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="sources-modal-header">
          <div className="sources-modal-title">
            <BookOpen size={16} />
            <span>Sources</span>
            <span className="sources-count">{sources.length}</span>
          </div>
          <button
            className="btn btn-icon btn-ghost btn-sm"
            onClick={onClose}
            aria-label="Close sources panel"
          >
            <X size={16} />
          </button>
        </div>

        <div className="sources-modal-body">
          <div className="sources-trust-hint">
            <ShieldCheck size={14} />
            Grounded in your notes
          </div>

          <div className="sources-list">
            {sources.map((source) => {
              const isSelected = source.id === selectedSourceId;
              const confidence = getConfidenceFromRelevance(source.relevance);
              const relevancePercent = Math.round(source.relevance * 100);

              return (
                <div
                  key={source.id}
                  ref={isSelected ? selectedRef : null}
                  className={`source-card ${isSelected ? 'selected' : ''} confidence-${confidence}`}
                  onClick={() => onSelectSource(isSelected ? null : source.id)}
                >
                  <div className="source-card-header">
                    <span className="source-badge">[{source.id}]</span>
                    {source.relevance > 0 && (
                      <span className="source-score" title={`Relevance: ${relevancePercent}%`}>
                        {relevancePercent}%
                      </span>
                    )}
                  </div>

                  <p className="source-preview">
                    {formatPreview(source.preview, 200)}
                  </p>

                  <div className="source-card-footer">
                    <span className="source-date">
                      {source.date}
                    </span>
                    <button
                      className="btn btn-sm btn-ghost jump-to-note-btn"
                      onClick={(e) => {
                        e.stopPropagation();
                        onOpenNote(source.noteId, source.preview);
                      }}
                      title="Jump to this note in the notes list"
                    >
                      Jump to note
                      <ArrowRight size={14} />
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/common/ConfirmDialog.tsx
==================================================

/**
 * ConfirmDialog component
 * Modal dialog for confirming destructive actions
 */

import { memo, useEffect, useRef } from 'react';
import { AlertTriangle, X } from 'lucide-react';
import { cn } from '../../lib/utils';

interface ConfirmDialogProps {
  isOpen: boolean;
  title: string;
  message: string;
  confirmLabel?: string;
  cancelLabel?: string;
  variant?: 'danger' | 'warning' | 'default';
  onConfirm: () => void;
  onCancel: () => void;
}

export const ConfirmDialog = memo(function ConfirmDialog({
  isOpen,
  title,
  message,
  confirmLabel = 'Confirm',
  cancelLabel = 'Cancel',
  variant = 'danger',
  onConfirm,
  onCancel,
}: ConfirmDialogProps) {
  const dialogRef = useRef<HTMLDivElement>(null);
  const confirmButtonRef = useRef<HTMLButtonElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  // Handle escape key, focus trap, and focus restoration
  useEffect(() => {
    if (!isOpen) return;

    // Store current focused element for restoration
    previousActiveElement.current = document.activeElement as HTMLElement;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    // Focus the confirm button (first action) by default
    confirmButtonRef.current?.focus();

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, onCancel]);

  // Restore focus when closed
  useEffect(() => {
    if (!isOpen && previousActiveElement.current) {
      previousActiveElement.current.focus();
      previousActiveElement.current = null;
    }
  }, [isOpen]);

  // Handle backdrop click
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onCancel();
    }
  };

  if (!isOpen) return null;

  return (
    <div 
      className="modal-backdrop animate-fade-in" 
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="confirm-dialog-title"
      aria-describedby="confirm-dialog-message"
    >
      <div 
        ref={dialogRef}
        className="modal confirm-dialog animate-scale-in"
        onClick={(e) => e.stopPropagation()}
      >
        <button 
          className="modal-close btn btn-icon btn-ghost"
          onClick={onCancel}
          aria-label="Close dialog"
        >
          <X size={18} />
        </button>

        <div className={cn(
          'confirm-dialog-icon',
          variant === 'danger' && 'bg-danger',
          variant === 'warning' && 'bg-warning'
        )}>
          <AlertTriangle size={24} />
        </div>

        <h3 id="confirm-dialog-title">{title}</h3>
        <p id="confirm-dialog-message">{message}</p>

        <div className="confirm-dialog-actions">
          <button 
            className="btn btn-secondary"
            onClick={onCancel}
          >
            {cancelLabel}
          </button>
          <button 
            ref={confirmButtonRef}
            className={cn(
              'btn',
              variant === 'danger' && 'btn-danger',
              variant === 'warning' && 'btn-warning',
              variant === 'default' && 'btn-primary'
            )}
            onClick={onConfirm}
          >
            {confirmLabel}
          </button>
        </div>
      </div>
    </div>
  );
});



==================================================
FILE: ./src/components/common/EmptyState.tsx
==================================================

/**
 * EmptyState component
 * Displays a friendly empty state with icon and message
 */

import { memo } from 'react';
import type { LucideIcon } from 'lucide-react';
import { FileText, Search } from 'lucide-react';

interface EmptyStateProps {
  /** Type of empty state */
  type: 'no-notes' | 'no-search-results';
  /** Custom message (optional) */
  message?: string;
}

const configs: Record<EmptyStateProps['type'], { icon: LucideIcon; title: string; description: string }> = {
  'no-notes': {
    icon: FileText,
    title: 'No notes yet',
    description: 'Write your first note above to get started. Your notes will appear here.',
  },
  'no-search-results': {
    icon: Search,
    title: 'No results found',
    description: 'Try adjusting your search or filter to find what you\'re looking for.',
  },
};

export const EmptyState = memo(function EmptyState({ type, message }: EmptyStateProps) {
  const config = configs[type];
  const Icon = config.icon;

  return (
    <div className="empty-state-container">
      <div className="empty-state-icon">
        <Icon size={32} strokeWidth={1.5} />
      </div>
      <h3 className="empty-state-title">{config.title}</h3>
      <p className="empty-state-description">{message || config.description}</p>
    </div>
  );
});



==================================================
FILE: ./src/components/common/ErrorBoundary.tsx
==================================================

/**
 * Error Boundary component
 * Catches React component crashes and displays a fallback UI
 */

import { Component, type ReactNode, type ErrorInfo } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    this.setState({ errorInfo });
    
    // Log to console in development
    if (import.meta.env.DEV) {
      console.error('ErrorBoundary caught an error:', error, errorInfo);
    }
    
    // TODO: Send to error reporting service in production
    // e.g., Sentry.captureException(error, { extra: errorInfo });
  }

  handleReset = (): void => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  handleReload = (): void => {
    window.location.reload();
  };

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="error-boundary">
          <div className="error-boundary-content">
            <div className="error-boundary-icon">
              <AlertTriangle size={32} />
            </div>
            <h2>Something went wrong</h2>
            <p>
              We're sorry, but something unexpected happened. 
              Please try refreshing the page.
            </p>
            {import.meta.env.DEV && this.state.error && (
              <details className="error-boundary-details">
                <summary>Error details</summary>
                <pre>{this.state.error.toString()}</pre>
                {this.state.errorInfo && (
                  <pre>{this.state.errorInfo.componentStack}</pre>
                )}
              </details>
            )}
            <div className="error-boundary-actions">
              <button 
                className="btn btn-primary" 
                onClick={this.handleReload}
              >
                <RefreshCw size={16} />
                Reload Page
              </button>
              <button 
                className="btn" 
                onClick={this.handleReset}
              >
                Try Again
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/**
 * Higher-order component for wrapping components with error boundary
 */
export function withErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  name?: string
): React.FC<P> {
  const displayName = name || WrappedComponent.displayName || WrappedComponent.name || 'Component';
  
  const WithErrorBoundary: React.FC<P> = (props) => (
    <ErrorBoundary>
      <WrappedComponent {...props} />
    </ErrorBoundary>
  );
  
  WithErrorBoundary.displayName = `withErrorBoundary(${displayName})`;
  
  return WithErrorBoundary;
}



==================================================
FILE: ./src/components/common/KeyboardShortcutsModal.tsx
==================================================

/**
 * KeyboardShortcutsModal component
 * Shows available keyboard shortcuts
 */

import { memo, useEffect, useRef } from 'react';
import { X, Keyboard } from 'lucide-react';

interface KeyboardShortcutsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface ShortcutItem {
  keys: string[];
  description: string;
}

const shortcuts: { category: string; items: ShortcutItem[] }[] = [
  {
    category: 'Notes',
    items: [
      { keys: ['⌘', 'Enter'], description: 'Save note' },
      { keys: ['Esc'], description: 'Clear note input' },
    ],
  },
  {
    category: 'Chat',
    items: [
      { keys: ['Enter'], description: 'Send message' },
      { keys: ['Shift', 'Enter'], description: 'New line' },
    ],
  },
  {
    category: 'General',
    items: [
      { keys: ['Esc'], description: 'Close modal/dialog' },
      { keys: ['?'], description: 'Show keyboard shortcuts' },
    ],
  },
];

export const KeyboardShortcutsModal = memo(function KeyboardShortcutsModal({
  isOpen,
  onClose,
}: KeyboardShortcutsModalProps) {
  const previousActiveElement = useRef<HTMLElement | null>(null);

  // Store focus and handle escape
  useEffect(() => {
    if (!isOpen) return;

    previousActiveElement.current = document.activeElement as HTMLElement;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  // Restore focus when closed
  useEffect(() => {
    if (!isOpen && previousActiveElement.current) {
      previousActiveElement.current.focus();
      previousActiveElement.current = null;
    }
  }, [isOpen]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="modal-backdrop animate-fade-in"
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="shortcuts-modal-title"
    >
      <div
        className="modal shortcuts-modal animate-scale-in"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="modal-header">
          <h2 id="shortcuts-modal-title">
            <Keyboard size={18} style={{ marginRight: '8px' }} />
            Keyboard Shortcuts
          </h2>
          <button
            className="modal-close btn btn-icon btn-ghost"
            onClick={onClose}
            aria-label="Close"
          >
            <X size={18} />
          </button>
        </div>

        <div className="shortcuts-content">
          {shortcuts.map((section) => (
            <div key={section.category} className="shortcuts-section">
              <h3 className="shortcuts-category">{section.category}</h3>
              <ul className="shortcuts-list">
                {section.items.map((item, i) => (
                  <li key={i} className="shortcut-item">
                    <span className="shortcut-description">{item.description}</span>
                    <span className="shortcut-keys">
                      {item.keys.map((key, j) => (
                        <kbd key={j} className="shortcut-key">{key}</kbd>
                      ))}
                    </span>
                  </li>
                ))}
              </ul>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
});



==================================================
FILE: ./src/components/common/Markdown.tsx
==================================================

/**
 * Markdown component
 * Simple markdown renderer without external dependencies
 * Supports: bold, italic, code, links, headers, lists, blockquotes
 */

import { memo, useMemo } from 'react';
import { FEATURES } from '../../lib/constants';

interface MarkdownProps {
  content: string;
  className?: string;
}

/**
 * Escape HTML entities to prevent XSS
 */
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Validate and sanitize URLs to prevent XSS via javascript: or data: URLs
 * Only allows http, https, and mailto protocols
 */
function sanitizeUrl(url: string): string | null {
  const trimmedUrl = url.trim().toLowerCase();

  // Block javascript:, data:, vbscript:, and other dangerous protocols
  if (
    trimmedUrl.startsWith('javascript:') ||
    trimmedUrl.startsWith('data:') ||
    trimmedUrl.startsWith('vbscript:') ||
    trimmedUrl.startsWith('file:')
  ) {
    return null;
  }

  // Allow only safe protocols
  if (
    trimmedUrl.startsWith('http://') ||
    trimmedUrl.startsWith('https://') ||
    trimmedUrl.startsWith('mailto:') ||
    trimmedUrl.startsWith('/') || // Relative URLs
    trimmedUrl.startsWith('#') // Anchor links
  ) {
    return escapeHtml(url);
  }

  // If no protocol, assume https
  if (!trimmedUrl.includes(':')) {
    return escapeHtml(url);
  }

  // Block unknown protocols
  return null;
}

/**
 * Parse inline markdown elements
 */
function parseInline(text: string): string {
  let result = escapeHtml(text);

  // Code (inline) - must be before other patterns
  result = result.replace(/`([^`]+)`/g, '<code>$1</code>');

  // Bold
  result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');

  // Italic
  result = result.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  result = result.replace(/_([^_]+)_/g, '<em>$1</em>');

  // Links - with URL sanitization to prevent XSS
  result = result.replace(
    /\[([^\]]+)\]\(([^)]+)\)/g,
    (_match, linkText, url) => {
      const sanitizedUrl = sanitizeUrl(url);
      if (sanitizedUrl) {
        return `<a href="${sanitizedUrl}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
      }
      // If URL is unsafe, just show the link text
      return linkText;
    }
  );

  return result;
}

/**
 * Parse markdown content to HTML
 */
function parseMarkdown(content: string): string {
  const lines = content.split('\n');
  const result: string[] = [];
  let inCodeBlock = false;
  let inList = false;
  let listType: 'ul' | 'ol' = 'ul';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Code blocks
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        result.push('</code></pre>');
        inCodeBlock = false;
      } else {
        result.push('<pre><code>');
        inCodeBlock = true;
      }
      continue;
    }
    
    if (inCodeBlock) {
      result.push(escapeHtml(line));
      continue;
    }
    
    // Close list if needed
    if (inList && !line.match(/^[\s]*[-*+]|^\d+\./)) {
      result.push(listType === 'ul' ? '</ul>' : '</ol>');
      inList = false;
    }
    
    // Headers
    if (line.startsWith('### ')) {
      result.push(`<h3>${parseInline(line.slice(4))}</h3>`);
      continue;
    }
    if (line.startsWith('## ')) {
      result.push(`<h2>${parseInline(line.slice(3))}</h2>`);
      continue;
    }
    if (line.startsWith('# ')) {
      result.push(`<h1>${parseInline(line.slice(2))}</h1>`);
      continue;
    }
    
    // Blockquotes
    if (line.startsWith('> ')) {
      result.push(`<blockquote>${parseInline(line.slice(2))}</blockquote>`);
      continue;
    }
    
    // Unordered lists
    const ulMatch = line.match(/^[\s]*[-*+]\s+(.+)/);
    if (ulMatch) {
      if (!inList || listType !== 'ul') {
        if (inList) result.push('</ol>');
        result.push('<ul>');
        inList = true;
        listType = 'ul';
      }
      result.push(`<li>${parseInline(ulMatch[1])}</li>`);
      continue;
    }
    
    // Ordered lists
    const olMatch = line.match(/^\d+\.\s+(.+)/);
    if (olMatch) {
      if (!inList || listType !== 'ol') {
        if (inList) result.push('</ul>');
        result.push('<ol>');
        inList = true;
        listType = 'ol';
      }
      result.push(`<li>${parseInline(olMatch[1])}</li>`);
      continue;
    }
    
    // Empty line
    if (line.trim() === '') {
      result.push('<br/>');
      continue;
    }
    
    // Regular paragraph
    result.push(`<p>${parseInline(line)}</p>`);
  }
  
  // Close any open lists
  if (inList) {
    result.push(listType === 'ul' ? '</ul>' : '</ol>');
  }
  if (inCodeBlock) {
    result.push('</code></pre>');
  }
  
  return result.join('\n');
}

export const Markdown = memo(function Markdown({ content, className = '' }: MarkdownProps) {
  const html = useMemo(() => {
    if (!FEATURES.ENABLE_MARKDOWN) {
      return escapeHtml(content);
    }
    return parseMarkdown(content);
  }, [content]);

  return (
    <div 
      className={`markdown-content ${className}`}
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
});



==================================================
FILE: ./src/components/common/OfflineBanner.tsx
==================================================

/**
 * OfflineBanner component
 * Shows a prominent banner when the user is offline
 */

import { WifiOff } from 'lucide-react';
import { useOnlineStatus } from '../../hooks/useOnlineStatus';
import { FEATURES } from '../../lib/constants';

export function OfflineBanner() {
  const { isOnline } = useOnlineStatus();

  // Don't render if feature is disabled or user is online
  if (!FEATURES.ENABLE_OFFLINE_BANNER || isOnline) {
    return null;
  }

  return (
    <div className="offline-banner" role="alert" aria-live="polite">
      <WifiOff size={16} />
      <span>You're offline. Some features may not work.</span>
    </div>
  );
}



==================================================
FILE: ./src/components/common/SkipLink.tsx
==================================================

/**
 * SkipLink component
 * Allows keyboard users to skip to main content
 */

interface SkipLinkProps {
  targetId: string;
  label?: string;
}

export function SkipLink({ targetId, label = 'Skip to main content' }: SkipLinkProps) {
  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    e.preventDefault();
    const target = document.getElementById(targetId);
    if (target) {
      target.focus();
      target.scrollIntoView({ behavior: 'smooth' });
    }
  };

  return (
    <a 
      href={`#${targetId}`}
      className="skip-link"
      onClick={handleClick}
    >
      {label}
    </a>
  );
}



==================================================
FILE: ./src/components/common/Toast.tsx
==================================================

/**
 * Toast notification system
 * Lightweight context-based toast for showing ephemeral messages
 */

import { useState, useCallback, type ReactNode } from 'react';
import { Check, X, Info, AlertTriangle } from 'lucide-react';
import { ToastContext, type ToastType } from './ToastContext';
import { UI } from '../../lib/constants';
import { cn } from '../../lib/utils';

interface Toast {
  id: string;
  message: string;
  type: ToastType;
}

interface ToastProviderProps {
  children: ReactNode;
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const showToast = useCallback((message: string, type: ToastType = 'info') => {
    const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    setToasts((prev) => [...prev, { id, message, type }]);

    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, UI.TOAST_DURATION_MS);
  }, []);

  const getIcon = (type: ToastType) => {
    switch (type) {
      case 'success': return <Check size={14} />;
      case 'error': return <X size={14} />;
      case 'warning': return <AlertTriangle size={14} />;
      case 'info': default: return <Info size={14} />;
    }
  };

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      <div className="toast-container" role="status" aria-live="polite">
        {toasts.map((toast) => (
          <div key={toast.id} className={cn('toast', toast.type)}>
            <span className="toast-icon">
              {getIcon(toast.type)}
            </span>
            {toast.message}
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}



==================================================
FILE: ./src/components/common/ToastContext.ts
==================================================

/**
 * Toast context - separated for fast refresh compatibility
 */

import { createContext } from 'react';

export type ToastType = 'success' | 'error' | 'info' | 'warning';

export interface ToastContextValue {
  showToast: (message: string, type?: ToastType) => void;
}

export const ToastContext = createContext<ToastContextValue | null>(null);



==================================================
FILE: ./src/components/common/useToast.ts
==================================================

/**
 * useToast hook - extracted for fast refresh compatibility
 */

import { useContext } from 'react';
import { ToastContext, type ToastContextValue } from './ToastContext';

export function useToast(): ToastContextValue {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}



==================================================
FILE: ./src/components/common/VirtualList.tsx
==================================================

/**
 * VirtualList component
 * Simple virtualized list for rendering large lists efficiently
 * Only renders items that are visible in the viewport
 */

import { useState, useRef, useEffect, useCallback, memo, type ReactNode } from 'react';

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  overscan?: number;
  renderItem: (item: T, index: number) => ReactNode;
  keyExtractor: (item: T, index: number) => string;
  className?: string;
  emptyState?: ReactNode;
}

interface VisibleRange {
  start: number;
  end: number;
}

function VirtualListInner<T>({
  items,
  itemHeight,
  overscan = 3,
  renderItem,
  keyExtractor,
  className = '',
  emptyState,
}: VirtualListProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState<VisibleRange>({ start: 0, end: 10 });

  const calculateVisibleRange = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const scrollTop = container.scrollTop;
    const viewportHeight = container.clientHeight;

    const start = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
    const visibleCount = Math.ceil(viewportHeight / itemHeight);
    const end = Math.min(items.length, start + visibleCount + overscan * 2);

    setVisibleRange({ start, end });
  }, [items.length, itemHeight, overscan]);

  // Calculate initial visible range and on resize
  useEffect(() => {
    calculateVisibleRange();
    
    const resizeObserver = new ResizeObserver(calculateVisibleRange);
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => resizeObserver.disconnect();
  }, [calculateVisibleRange]);

  // Handle scroll
  const handleScroll = useCallback(() => {
    requestAnimationFrame(calculateVisibleRange);
  }, [calculateVisibleRange]);

  if (items.length === 0 && emptyState) {
    return <div className={className}>{emptyState}</div>;
  }

  const totalHeight = items.length * itemHeight;
  const visibleItems = items.slice(visibleRange.start, visibleRange.end);
  const offsetY = visibleRange.start * itemHeight;

  return (
    <div
      ref={containerRef}
      className={`virtual-list ${className}`}
      onScroll={handleScroll}
      style={{ overflow: 'auto', position: 'relative' }}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            position: 'absolute',
            top: offsetY,
            left: 0,
            right: 0,
          }}
        >
          {visibleItems.map((item, index) => {
            const actualIndex = visibleRange.start + index;
            return (
              <div
                key={keyExtractor(item, actualIndex)}
                style={{ height: itemHeight }}
              >
                {renderItem(item, actualIndex)}
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}

// Memo wrapper that preserves generic type
export const VirtualList = memo(VirtualListInner) as typeof VirtualListInner;

/**
 * Hook for determining if virtualization should be used
 * Based on item count threshold
 */
export function useVirtualization(itemCount: number, threshold = 50): boolean {
  return itemCount > threshold;
}



==================================================
FILE: ./src/components/landing/HowItWorks.tsx
==================================================

/**
 * HowItWorks Landing Page
 * Explains how the AuroraNotes AI chatbot backend and RAG process works
 *
 * This is a mostly-static component. We use React.memo to prevent
 * unnecessary re-renders since the content doesn't change.
 */

import { memo } from 'react';
import {
  Sparkles, FileText, Search, Brain, MessageSquare, Database,
  Zap, ArrowRight, CheckCircle, Layers, GitMerge, Shield,
  Clock, Server, Cpu, ArrowDown
} from 'lucide-react';

interface HowItWorksProps {
  onClose?: () => void;
  onEnterApp?: () => void;
}

export const HowItWorks = memo(function HowItWorks({ onClose, onEnterApp }: HowItWorksProps) {
  // Determine if this is the landing page (has onEnterApp) or modal view (has onClose)
  const isLandingPage = !!onEnterApp;

  return (
    <div className="how-it-works-page">
      <div className="how-it-works-container">
        {/* Header */}
        <header className="how-it-works-header">
          <div className="how-it-works-logo">
            <Sparkles size={28} />
          </div>
          <h1>How AuroraNotes AI Works</h1>
          <p className="how-it-works-subtitle">
            Your personal knowledge assistant powered by Retrieval-Augmented Generation (RAG)
          </p>
          {onClose && (
            <button className="btn btn-ghost how-it-works-close" onClick={onClose}>
              Back to App
            </button>
          )}
        </header>

        {/* Hero CTA for landing page */}
        {isLandingPage && (
          <div className="landing-hero-cta">
            <button className="btn btn-primary btn-lg landing-cta-btn" onClick={onEnterApp}>
              <Sparkles size={20} />
              Enter AuroraNotes
              <ArrowRight size={20} />
            </button>
            <p className="landing-cta-hint">Start taking AI-powered notes</p>
          </div>
        )}

        {/* Overview */}
        <section className="how-it-works-intro">
          <h2>Overview</h2>
          <p>
            AuroraNotes stores your notes and lets you ask questions about them using{' '}
            <strong>Retrieval-Augmented Generation (RAG)</strong> — a pattern where the system
            first finds relevant notes, then asks an AI to answer your question using only that context.
          </p>
          <div className="rag-flow">
            <span className="rag-flow-item">Your Question</span>
            <ArrowRight size={16} />
            <span className="rag-flow-item">Find Relevant Notes</span>
            <ArrowRight size={16} />
            <span className="rag-flow-item">AI Generates Answer</span>
            <ArrowRight size={16} />
            <span className="rag-flow-item">Verified Citations</span>
          </div>
        </section>

        {/* Core Technologies */}
        <section className="how-it-works-section">
          <h2><Server size={20} /> Core Technologies</h2>
          <div className="tech-table">
            <div className="tech-row">
              <span className="tech-label">Runtime</span>
              <span className="tech-value">Node.js + TypeScript on Google Cloud Run</span>
            </div>
            <div className="tech-row">
              <span className="tech-label">Database</span>
              <span className="tech-value">Google Firestore (NoSQL document store)</span>
            </div>
            <div className="tech-row">
              <span className="tech-label">Embeddings</span>
              <span className="tech-value">Google Vertex AI (text-embedding-004)</span>
            </div>
            <div className="tech-row">
              <span className="tech-label">Vector Search</span>
              <span className="tech-value">Vertex AI Vector Search / Firestore fallback</span>
            </div>
            <div className="tech-row">
              <span className="tech-label">LLM</span>
              <span className="tech-value">Google Gemini 2.0 Flash</span>
            </div>
          </div>
        </section>

        {/* Data Pipeline */}
        <section className="how-it-works-section">
          <h2><Database size={20} /> The Data Pipeline</h2>
          <p className="section-intro">When you save a note, it goes through several processing stages to become searchable.</p>

          <div className="pipeline-steps">
            <div className="pipeline-step">
              <div className="pipeline-step-header">
                <span className="pipeline-number">1</span>
                <FileText size={18} />
                <h3>Note Storage</h3>
              </div>
              <p>Notes are stored in Firestore with metadata (tenant ID, timestamps) for organization and retrieval.</p>
            </div>

            <div className="pipeline-connector"><ArrowDown size={16} /></div>

            <div className="pipeline-step">
              <div className="pipeline-step-header">
                <span className="pipeline-number">2</span>
                <Layers size={18} />
                <h3>Chunking</h3>
              </div>
              <p>Long notes are split into ~450-character "chunks" at natural boundaries (paragraphs, sentences).
                 Each chunk maintains <strong>75-character overlap</strong> with adjacent chunks for context continuity.</p>
            </div>

            <div className="pipeline-connector"><ArrowDown size={16} /></div>

            <div className="pipeline-step">
              <div className="pipeline-step-header">
                <span className="pipeline-number">3</span>
                <Cpu size={18} />
                <h3>Embedding Generation</h3>
              </div>
              <p>Each chunk is converted to a <strong>768-dimensional vector</strong> using Google's embedding model.
                 This vector captures the semantic meaning — similar ideas produce similar vectors.</p>
            </div>

            <div className="pipeline-connector"><ArrowDown size={16} /></div>

            <div className="pipeline-step">
              <div className="pipeline-step-header">
                <span className="pipeline-number">4</span>
                <Database size={18} />
                <h3>Indexing</h3>
              </div>
              <p>Chunks are stored with: vector embedding (semantic search), extracted terms (keyword search),
                 and position & context (citation accuracy).</p>
            </div>
          </div>
        </section>

        {/* Retrieval Pipeline */}
        <section className="how-it-works-section">
          <h2><Search size={20} /> The Retrieval Pipeline</h2>
          <p className="section-intro">When you ask a question, multiple search strategies work in parallel to find the best matches.</p>

          <div className="retrieval-stages">
            <div className="retrieval-stage">
              <div className="stage-header">
                <span className="stage-badge">Stage 1</span>
                <h3>Query Analysis</h3>
              </div>
              <p>The system analyzes your question to detect:</p>
              <ul>
                <li><strong>Intent</strong> — question, search, summary, brainstorm</li>
                <li><strong>Entities</strong> — names, dates, unique identifiers</li>
                <li><strong>Time constraints</strong> — recent vs. all-time</li>
              </ul>
            </div>

            <div className="retrieval-stage">
              <div className="stage-header">
                <span className="stage-badge">Stage 2</span>
                <h3>Multi-Signal Candidate Retrieval</h3>
              </div>
              <p>Three parallel search strategies run simultaneously:</p>
              <div className="strategy-cards">
                <div className="strategy-card">
                  <Brain size={16} />
                  <strong>Vector Search</strong>
                  <span>Finds semantically similar chunks (meaning match)</span>
                </div>
                <div className="strategy-card">
                  <Search size={16} />
                  <strong>Lexical Search</strong>
                  <span>BM25-style keyword matching (exact term match)</span>
                </div>
                <div className="strategy-card">
                  <Clock size={16} />
                  <strong>Recency Boost</strong>
                  <span>Prioritizes recently-created notes</span>
                </div>
              </div>
            </div>

            <div className="retrieval-stage">
              <div className="stage-header">
                <span className="stage-badge">Stage 3</span>
                <h3>Fusion & Scoring</h3>
              </div>
              <p>Results are merged using <strong>Reciprocal Rank Fusion (RRF)</strong>, combining all signals
                 into a unified score. This ensures both "conceptually similar" and "keyword exact" matches surface.</p>
            </div>

            <div className="retrieval-stage">
              <div className="stage-header">
                <span className="stage-badge">Stage 4</span>
                <h3>Cross-Encoder Reranking</h3>
              </div>
              <p>A neural reranker (Vertex AI) compares each candidate directly against the query for
                 <strong> more accurate relevance scoring</strong> — more expensive but much more precise than embeddings alone.</p>
            </div>

            <div className="retrieval-stage">
              <div className="stage-header">
                <span className="stage-badge">Stage 5</span>
                <h3>MMR Diversity</h3>
              </div>
              <p><strong>Maximal Marginal Relevance</strong> prevents redundancy by penalizing chunks that are
                 too similar to already-selected ones, ensuring diverse coverage of your notes.</p>
            </div>
          </div>
        </section>

        {/* Answer Generation */}
        <section className="how-it-works-section">
          <h2><MessageSquare size={20} /> Answer Generation Pipeline</h2>
          <p className="section-intro">Once relevant chunks are found, the AI generates a grounded, verified response.</p>

          <div className="generation-steps">
            <div className="generation-step">
              <div className="generation-step-icon"><Layers size={20} /></div>
              <div className="generation-step-content">
                <h3>1. Context Assembly</h3>
                <p>Top-ranked chunks are formatted with source IDs ([1], [2], etc.) and packed into the LLM prompt,
                   respecting a ~100K character budget.</p>
              </div>
            </div>

            <div className="generation-step">
              <div className="generation-step-icon"><Zap size={20} /></div>
              <div className="generation-step-content">
                <h3>2. LLM Generation</h3>
                <p>Gemini 2.0 Flash generates an answer with inline citations, following strict instructions:</p>
                <ul>
                  <li><CheckCircle size={14} /> Only cite what's in the sources</li>
                  <li><CheckCircle size={14} /> Use [n] format for citations</li>
                  <li><CheckCircle size={14} /> Admit uncertainty when sources are insufficient</li>
                </ul>
              </div>
            </div>

            <div className="generation-step">
              <div className="generation-step-icon"><Shield size={20} /></div>
              <div className="generation-step-content">
                <h3>3. Citation Validation</h3>
                <p>A multi-stage verification pipeline ensures accuracy:</p>
                <ul>
                  <li><CheckCircle size={14} /> <strong>Text overlap scoring</strong> — does the cited claim appear in the source?</li>
                  <li><CheckCircle size={14} /> <strong>Semantic grounding</strong> — does the claim meaning match the source?</li>
                  <li><CheckCircle size={14} /> <strong>Contradiction detection</strong> — are sources being misrepresented?</li>
                </ul>
                <p className="note">Invalid citations are removed; low-confidence answers are flagged.</p>
              </div>
            </div>

            <div className="generation-step">
              <div className="generation-step-icon"><GitMerge size={20} /></div>
              <div className="generation-step-content">
                <h3>4. Response Post-Processing</h3>
                <ul>
                  <li><CheckCircle size={14} /> Confidence scoring (low/medium/high/very_high)</li>
                  <li><CheckCircle size={14} /> Citation repair (fix broken references)</li>
                  <li><CheckCircle size={14} /> Consistency enforcement (remove orphaned citations)</li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        {/* Architectural Decisions */}
        <section className="how-it-works-section">
          <h2><Cpu size={20} /> Key Architectural Decisions</h2>
          <div className="decisions-grid">
            <div className="decision-card">
              <h4>Synchronous Chunking</h4>
              <p>Notes are immediately searchable with no async lag</p>
            </div>
            <div className="decision-card">
              <h4>Hybrid Retrieval</h4>
              <p>Vector + keyword covers both conceptual and exact matches</p>
            </div>
            <div className="decision-card">
              <h4>Cross-Encoder Reranking</h4>
              <p>Neural reranking dramatically improves precision</p>
            </div>
            <div className="decision-card">
              <h4>Citation Verification</h4>
              <p>Prevents hallucinated sources (common RAG failure mode)</p>
            </div>
            <div className="decision-card">
              <h4>Multi-Tenant Isolation</h4>
              <p>tenantId field enables secure data separation</p>
            </div>
            <div className="decision-card">
              <h4>Chunk Overlap</h4>
              <p>75-char overlap preserves context across chunk boundaries</p>
            </div>
          </div>
        </section>

        {/* Scale Targets */}
        <section className="how-it-works-section scale-section">
          <h2><Zap size={20} /> Scale & Performance</h2>
          <div className="scale-stats">
            <div className="scale-stat">
              <span className="scale-number">100K+</span>
              <span className="scale-label">Notes supported</span>
            </div>
            <div className="scale-stat">
              <span className="scale-number">&lt;1s</span>
              <span className="scale-label">Retrieval latency</span>
            </div>
            <div className="scale-stat">
              <span className="scale-number">~4s</span>
              <span className="scale-label">End-to-end response</span>
            </div>
          </div>
          <p className="scale-note">
            Embedding + retrieval + LLM generation + citation validation
          </p>
        </section>

        {/* Footer CTA for landing page */}
        {isLandingPage && (
          <footer className="landing-footer">
            <button className="btn btn-primary btn-lg landing-cta-btn" onClick={onEnterApp}>
              <Sparkles size={20} />
              Get Started
              <ArrowRight size={20} />
            </button>
          </footer>
        )}
      </div>
    </div>
  );
});


==================================================
FILE: ./src/components/layout/AppShell.tsx
==================================================

/**
 * AppShell component
 * Main layout with header, responsive grid, and mobile tabs
 * Manages cross-pane communication for note highlighting from chat citations
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { Sparkles, FileText, Link2, Sun, Moon, Keyboard, HelpCircle } from 'lucide-react';
import { getHealth, getApiBaseUrl } from '../../lib/api';
import { useToast } from '../common/useToast';
import { useTheme } from '../../lib/ThemeContext';
import { NotesPanel } from '../notes/NotesPanel';
import { ChatPanel } from '../chat/ChatPanel';
import { NoteDetailDrawer } from '../notes/NoteDetailDrawer';
import { SkipLink } from '../common/SkipLink';
import { KeyboardShortcutsModal } from '../common/KeyboardShortcutsModal';
import { HowItWorks } from '../landing/HowItWorks';
import type { Note } from '../../lib/types';

type Tab = 'notes' | 'chat';

// Maximum pages to search when looking for a note
const MAX_SEARCH_PAGES = 10;

interface AppShellProps {
  onShowHowItWorks?: () => void;
}

export function AppShell({ onShowHowItWorks }: AppShellProps) {
  const [isConnected, setIsConnected] = useState(false);
  const [activeTab, setActiveTab] = useState<Tab>('notes');
  const [highlightNoteId, setHighlightNoteId] = useState<string | null>(null);
  const [drawerNote, setDrawerNote] = useState<Note | null>(null);
  const [drawerHighlight, setDrawerHighlight] = useState<string | undefined>();
  const [searchingForNote, setSearchingForNote] = useState(false);
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [showHowItWorks, setShowHowItWorks] = useState(false);
  const { showToast } = useToast();
  const { theme, toggleTheme } = useTheme();

  // Store notes state from NotesPanel for lookup
  const notesRef = useRef<Note[]>([]);
  const hasMoreRef = useRef<boolean>(false);
  const loadMoreRef = useRef<(() => Promise<void>) | null>(null);

  // Global keyboard shortcut for showing help
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Show shortcuts modal on ? key (Shift + /)
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        const target = e.target as HTMLElement;
        const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
        if (!isInput) {
          e.preventDefault();
          setShowShortcuts(true);
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  const checkHealth = useCallback(async () => {
    const health = await getHealth();
    setIsConnected(health.status === 'healthy');
  }, []);

  const handleCopyApi = useCallback(async () => {
    const apiBase = getApiBaseUrl();
    if (!apiBase) return;

    try {
      await navigator.clipboard.writeText(apiBase);
      showToast('API URL copied', 'success');
    } catch {
      showToast('Failed to copy', 'error');
    }
  }, [showToast]);

  // Handle notes loaded from NotesPanel
  const handleNotesLoaded = useCallback((notes: Note[], hasMore: boolean, loadMore: () => Promise<void>) => {
    notesRef.current = notes;
    hasMoreRef.current = hasMore;
    loadMoreRef.current = loadMore;
  }, []);

  // Handle opening a note from chat citation with bounded search
  const handleOpenNote = useCallback(async (noteId: string, snippet?: string) => {
    // Switch to notes tab
    setActiveTab('notes');
    setDrawerHighlight(snippet);

    // Check if note is already loaded
    let foundNote = notesRef.current.find(n => n.id === noteId);

    if (foundNote) {
      // Note is loaded - highlight it and show drawer with full content
      setDrawerNote(foundNote);
      setHighlightNoteId(noteId);
      return;
    }

    // Note not loaded - show drawer with snippet as placeholder
    const tempNote: Note = {
      id: noteId,
      text: snippet || 'Loading note content...',
      tenantId: 'public',
      createdAt: null,
      updatedAt: null,
    };
    setDrawerNote(tempNote);

    // Try to load more pages to find the note (bounded search)
    if (hasMoreRef.current && loadMoreRef.current) {
      setSearchingForNote(true);
      let pagesSearched = 0;

      while (pagesSearched < MAX_SEARCH_PAGES && hasMoreRef.current) {
        try {
          await loadMoreRef.current();
          pagesSearched++;

          // Check if we found the note
          foundNote = notesRef.current.find(n => n.id === noteId);
          if (foundNote) {
            setDrawerNote(foundNote);
            setHighlightNoteId(noteId);
            setSearchingForNote(false);
            return;
          }
        } catch {
          // Stop searching on error
          break;
        }
      }

      setSearchingForNote(false);

      // Still not found after max pages
      if (!foundNote) {
        showToast('Note not found in loaded pages. Showing snippet only.', 'info');
      }
    }
  }, [showToast]);

  const handleNoteHighlighted = useCallback(() => {
    setTimeout(() => setHighlightNoteId(null), 2500);
  }, []);

  const handleCloseDrawer = useCallback(() => {
    setDrawerNote(null);
    setDrawerHighlight(undefined);
  }, []);

  useEffect(() => {
    const initialTimeout = setTimeout(checkHealth, 0);
    const interval = setInterval(checkHealth, 30000);
    return () => {
      clearTimeout(initialTimeout);
      clearInterval(interval);
    };
  }, [checkHealth]);

  return (
    <div className="app-shell">
      <SkipLink targetId="main-content" />
      <div className="app-container">
        {/* Header */}
        <header className="app-header">
          <button
            className="app-title"
            onClick={onShowHowItWorks}
            title="About AuroraNotes"
            aria-label="Go to landing page"
          >
            <div className="app-logo">
              <Sparkles size={18} />
            </div>
            <h1>Aurora</h1>
            <span className="tagline">Intelligent notes</span>
          </button>

          <div className="header-actions">
            <div className="status-indicator">
              <span className={`status-dot${isConnected ? ' connected' : ''}`} />
              {isConnected ? 'Online' : 'Offline'}
            </div>

            <button
              className="btn btn-icon btn-ghost"
              onClick={onShowHowItWorks ?? (() => setShowHowItWorks(true))}
              title="How it works"
              aria-label="Learn how AuroraNotes AI works"
            >
              <HelpCircle size={18} />
            </button>

            <button
              className="btn btn-icon btn-ghost"
              onClick={handleCopyApi}
              title="Copy API URL"
              aria-label="Copy API URL"
            >
              <Link2 size={18} />
            </button>

            <button
              className="btn btn-icon btn-ghost"
              onClick={() => setShowShortcuts(true)}
              title="Keyboard shortcuts (?)"
              aria-label="Show keyboard shortcuts"
            >
              <Keyboard size={18} />
            </button>

            <button
              className="theme-toggle"
              onClick={toggleTheme}
              title={theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'}
              aria-label={theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'}
            >
              {theme === 'light' ? <Moon size={18} /> : <Sun size={18} />}
            </button>
          </div>
        </header>

        {/* Mobile Tabs */}
        <div className="mobile-tabs" role="tablist">
          <button
            role="tab"
            aria-selected={activeTab === 'notes'}
            className={activeTab === 'notes' ? 'active' : ''}
            onClick={() => setActiveTab('notes')}
          >
            <FileText size={16} />
            Notes
          </button>
          <button
            role="tab"
            aria-selected={activeTab === 'chat'}
            className={activeTab === 'chat' ? 'active' : ''}
            onClick={() => setActiveTab('chat')}
          >
            <Sparkles size={16} />
            Ask AI
          </button>
        </div>

        {/* Main Grid */}
        <main id="main-content" className="main-grid" tabIndex={-1}>
          <NotesPanel
            className={activeTab !== 'notes' ? 'hidden' : ''}
            highlightNoteId={highlightNoteId}
            onNoteHighlighted={handleNoteHighlighted}
            onNotesLoaded={handleNotesLoaded}
          />
          <ChatPanel
            className={activeTab !== 'chat' ? 'hidden' : ''}
            onOpenNote={handleOpenNote}
          />
        </main>

        {/* Loading overlay when searching for note */}
        {searchingForNote && (
          <div className="searching-note-overlay">
            <div className="searching-note-content">
              <span className="spinner" />
              <span>Finding note...</span>
            </div>
          </div>
        )}

        <NoteDetailDrawer
          note={drawerNote}
          onClose={handleCloseDrawer}
          highlightText={drawerHighlight}
        />

        <KeyboardShortcutsModal
          isOpen={showShortcuts}
          onClose={() => setShowShortcuts(false)}
        />

        {/* How It Works Modal */}
        {showHowItWorks && (
          <div className="how-it-works-modal-overlay">
            <HowItWorks onClose={() => setShowHowItWorks(false)} />
          </div>
        )}
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/notes/EditNoteModal.tsx
==================================================

/**
 * EditNoteModal component
 * Modal for editing an existing note
 */

import { memo, useState, useEffect, useRef } from 'react';
import { X, Save } from 'lucide-react';
import type { Note } from '../../lib/types';
import { NOTES } from '../../lib/constants';

interface EditNoteModalProps {
  note: Note | null;
  isOpen: boolean;
  isSaving?: boolean;
  onSave: (id: string, text: string) => void;
  onClose: () => void;
}

export const EditNoteModal = memo(function EditNoteModal({
  note,
  isOpen,
  isSaving = false,
  onSave,
  onClose,
}: EditNoteModalProps) {
  const [text, setText] = useState('');
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  // Store focus and sync text when opened
  useEffect(() => {
    if (note && isOpen) {
      // Store current focused element for restoration
      previousActiveElement.current = document.activeElement as HTMLElement;
      setText(note.text);
      // Focus textarea after a brief delay to ensure modal is visible
      setTimeout(() => textareaRef.current?.focus(), 100);
    }
  }, [note, isOpen]);

  // Restore focus when closed
  useEffect(() => {
    if (!isOpen && previousActiveElement.current) {
      previousActiveElement.current.focus();
      previousActiveElement.current = null;
    }
  }, [isOpen]);

  // Handle escape key
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!note || !text.trim() || isSaving) return;
    onSave(note.id, text.trim());
  };

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  const charCount = text.length;
  const isOverLimit = charCount > NOTES.MAX_LENGTH;
  const hasChanges = note?.text !== text;
  const canSave = hasChanges && text.trim() && !isOverLimit && !isSaving;

  if (!isOpen || !note) return null;

  return (
    <div 
      className="modal-backdrop animate-fade-in" 
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="edit-note-title"
    >
      <div 
        className="modal edit-note-modal animate-scale-in"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="modal-header">
          <h2 id="edit-note-title">Edit Note</h2>
          <button 
            className="modal-close btn btn-icon btn-ghost"
            onClick={onClose}
            aria-label="Close"
          >
            <X size={18} />
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          <textarea
            ref={textareaRef}
            className="edit-note-textarea"
            value={text}
            onChange={(e) => setText(e.target.value)}
            placeholder="Edit your note..."
            maxLength={NOTES.MAX_LENGTH + 100} // Allow some overflow for warning
            disabled={isSaving}
          />

          <div className={`chat-char-count ${isOverLimit ? 'over-limit' : ''}`}>
            {charCount} / {NOTES.MAX_LENGTH}
          </div>

          <div className="modal-footer">
            <button 
              type="button"
              className="btn btn-secondary"
              onClick={onClose}
              disabled={isSaving}
            >
              Cancel
            </button>
            <button 
              type="submit"
              className="btn btn-primary"
              disabled={!canSave}
            >
              <Save size={16} />
              {isSaving ? 'Saving...' : 'Save Changes'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
});



==================================================
FILE: ./src/components/notes/NoteCard.tsx
==================================================

/**
 * NoteCard component
 * Compact note display with expandable text, hover actions, and relative time
 * Supports search highlighting and external highlight state
 */

import { useState, useCallback, useEffect, memo } from 'react';
import { Copy, Pencil, Trash2 } from 'lucide-react';
import type { Note } from '../../lib/types';
import { formatRelativeTime, formatFullTimestamp, shortId } from '../../lib/format';
import { escapeRegex, cn, copyToClipboard } from '../../lib/utils';
import { useToast } from '../common/useToast';
import { NOTES } from '../../lib/constants';

interface NoteCardProps {
  note: Note;
  isPending?: boolean;
  isHighlighted?: boolean;
  searchQuery?: string;
  onEdit?: (note: Note) => void;
  onDelete?: (note: Note) => void;
}

export const NoteCard = memo(function NoteCard({
  note,
  isPending = false,
  isHighlighted = false,
  searchQuery = '',
  onEdit,
  onDelete,
}: NoteCardProps) {
  const [expanded, setExpanded] = useState(false);
  const [highlightActive, setHighlightActive] = useState(false);
  const { showToast } = useToast();

  // Flash highlight effect - triggered when isHighlighted prop changes
  useEffect(() => {
    if (!isHighlighted) {
      return;
    }
    // Start highlight animation after a microtask to avoid synchronous setState
    const startTimeout = setTimeout(() => setHighlightActive(true), 0);
    const endTimeout = setTimeout(() => setHighlightActive(false), NOTES.HIGHLIGHT_DURATION_MS);
    return () => {
      clearTimeout(startTimeout);
      clearTimeout(endTimeout);
    };
  }, [isHighlighted]);

  const showHighlight = isHighlighted || highlightActive;

  const needsExpansion = note.text.length > 200 || note.text.split('\n').length > 2;

  const handleToggle = useCallback(() => {
    if (needsExpansion) {
      setExpanded((prev) => !prev);
    }
  }, [needsExpansion]);

  const handleCopy = useCallback(async (e: React.MouseEvent) => {
    e.stopPropagation();
    const success = await copyToClipboard(note.text);
    showToast(success ? 'Copied' : 'Failed to copy', success ? 'success' : 'error');
  }, [note.text, showToast]);

  const handleEdit = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onEdit?.(note);
  }, [note, onEdit]);

  const handleDelete = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onDelete?.(note);
  }, [note, onDelete]);

  const displayId = shortId(note.id);
  const relativeTime = formatRelativeTime(note.createdAt);
  const fullTime = formatFullTimestamp(note.createdAt);

  // Render text with optional search highlighting
  const renderText = () => {
    if (!searchQuery || !note.text.toLowerCase().includes(searchQuery.toLowerCase())) {
      return note.text;
    }

    // Simple case-insensitive highlight
    const parts = note.text.split(new RegExp(`(${escapeRegex(searchQuery)})`, 'gi'));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === searchQuery.toLowerCase() ? (
            <mark key={i} className="search-highlight">{part}</mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  const cardClasses = cn(
    'note-card',
    isPending && 'pending',
    showHighlight && 'highlighted'
  );

  return (
    <div
      className={cardClasses}
      onClick={handleToggle}
      role={needsExpansion ? 'button' : undefined}
      tabIndex={needsExpansion ? 0 : undefined}
      onKeyDown={(e) => {
        if (needsExpansion && (e.key === 'Enter' || e.key === ' ')) {
          e.preventDefault();
          handleToggle();
        }
      }}
    >
      <div className={`note-text${!expanded && needsExpansion ? ' clamped' : ''}`}>
        {renderText()}
      </div>

      <div className="note-meta">
        <span className="note-time" title={fullTime}>
          {isPending ? 'Saving…' : relativeTime}
        </span>

        <div className="note-actions">
          {onEdit && (
            <button
              className="btn btn-icon btn-ghost btn-sm"
              onClick={handleEdit}
              title="Edit note"
              aria-label="Edit note"
            >
              <Pencil size={14} />
            </button>
          )}
          <button
            className="btn btn-icon btn-ghost btn-sm"
            onClick={handleCopy}
            title="Copy note"
            aria-label="Copy note text"
          >
            <Copy size={14} />
          </button>
          {onDelete && (
            <button
              className="btn btn-icon btn-ghost btn-sm btn-danger"
              onClick={handleDelete}
              title="Delete note"
              aria-label="Delete note"
            >
              <Trash2 size={14} />
            </button>
          )}
        </div>

        {displayId && (
          <span className="note-id" title={`ID: ${note.id}`}>
            {displayId}
          </span>
        )}
      </div>
    </div>
  );
});



==================================================
FILE: ./src/components/notes/NoteCardSkeleton.tsx
==================================================

/**
 * NoteCardSkeleton component
 * Loading placeholder that matches NoteCard layout
 */

import { memo } from 'react';

interface NoteCardSkeletonProps {
  /** Number of skeleton cards to render */
  count?: number;
}

export const NoteCardSkeleton = memo(function NoteCardSkeleton({ count = 1 }: NoteCardSkeletonProps) {
  return (
    <>
      {Array.from({ length: count }).map((_, i) => (
        <div key={i} className="note-card-skeleton" aria-hidden="true">
          <div className="skeleton-text">
            <div className="skeleton-line skeleton-line-full" />
            <div className="skeleton-line skeleton-line-medium" />
          </div>
          <div className="skeleton-meta">
            <div className="skeleton-time" />
            <div className="skeleton-id" />
          </div>
        </div>
      ))}
    </>
  );
});



==================================================
FILE: ./src/components/notes/NoteDetailDrawer.tsx
==================================================

/**
 * NoteDetailDrawer component
 * Modal/drawer for viewing full note content when navigating from citations
 */

import { useEffect, useCallback, useRef } from 'react';
import { FileText, X, Copy } from 'lucide-react';
import type { Note } from '../../lib/types';
import { formatFullTimestamp, formatRelativeTime, shortId } from '../../lib/format';
import { escapeRegex, copyToClipboard } from '../../lib/utils';
import { useToast } from '../common/useToast';
import { useFocusTrap } from '../../lib/hooks/useFocusTrap';

interface NoteDetailDrawerProps {
  note: Note | null;
  onClose: () => void;
  highlightText?: string;
}

export function NoteDetailDrawer({ note, onClose, highlightText }: NoteDetailDrawerProps) {
  const { showToast } = useToast();
  const drawerRef = useFocusTrap<HTMLDivElement>(!!note);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  const handleCopy = useCallback(async () => {
    if (!note) return;
    const success = await copyToClipboard(note.text);
    showToast(success ? 'Copied to clipboard' : 'Failed to copy', success ? 'success' : 'error');
  }, [note, showToast]);

  // Store the element that had focus before opening, and restore on close
  useEffect(() => {
    if (note) {
      // Store current focused element
      previousActiveElement.current = document.activeElement as HTMLElement;
    } else if (previousActiveElement.current) {
      // Restore focus when closing
      previousActiveElement.current.focus();
      previousActiveElement.current = null;
    }
  }, [note]);

  // Close on Escape key
  useEffect(() => {
    if (!note) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [note, onClose]);

  // Prevent body scroll when drawer is open
  useEffect(() => {
    if (note) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = '';
      };
    }
  }, [note]);

  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  }, [onClose]);

  if (!note) return null;

  const displayId = shortId(note.id);
  const relativeTime = formatRelativeTime(note.createdAt);
  const fullTime = formatFullTimestamp(note.createdAt);

  // Highlight matching text if provided
  const renderText = () => {
    if (!highlightText || !note.text.toLowerCase().includes(highlightText.toLowerCase())) {
      return <p className="note-detail-text">{note.text}</p>;
    }

    // Simple case-insensitive highlight
    const parts = note.text.split(new RegExp(`(${escapeRegex(highlightText)})`, 'gi'));
    return (
      <p className="note-detail-text">
        {parts.map((part, i) => 
          part.toLowerCase() === highlightText.toLowerCase() ? (
            <mark key={i} className="highlight">{part}</mark>
          ) : (
            part
          )
        )}
      </p>
    );
  };

  return (
    <div className="note-drawer-backdrop" onClick={handleBackdropClick}>
      <div
        ref={drawerRef}
        className="note-drawer"
        role="dialog"
        aria-modal="true"
        aria-labelledby="note-drawer-title"
      >
        <div className="note-drawer-header">
          <h3 id="note-drawer-title">
            <FileText size={18} style={{ marginRight: '8px' }} />
            Note
          </h3>
          <button
            className="btn btn-icon btn-ghost"
            onClick={onClose}
            aria-label="Close"
          >
            <X size={18} />
          </button>
        </div>

        <div className="note-drawer-body">
          {renderText()}
        </div>

        <div className="note-drawer-footer">
          <div className="note-drawer-meta">
            <span className="note-drawer-time" title={fullTime}>
              {relativeTime}
            </span>
            {displayId && (
              <span className="note-drawer-id">{displayId}</span>
            )}
          </div>
          <div className="note-drawer-actions">
            <button className="btn btn-sm" onClick={handleCopy}>
              <Copy size={14} />
              Copy
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}






==================================================
FILE: ./src/components/notes/NotesPanel.tsx
==================================================

/**
 * NotesPanel component
 * Sticky composer, scrollable notes list, keyboard shortcuts, optimistic updates
 * Now with cursor-based pagination for 100k+ notes support
 * Includes search and quick filters (Today/This week/All)
 */

import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { FileText, Search, Plus } from 'lucide-react';
import type { Note } from '../../lib/types';
import { normalizeNote } from '../../lib/format';
import { listNotes, createNote, deleteNote, updateNote, ApiRequestError } from '../../lib/api';
import { useToast } from '../common/useToast';
import { NoteCard } from './NoteCard';
import { NoteCardSkeleton } from './NoteCardSkeleton';
import { ConfirmDialog } from '../common/ConfirmDialog';
import { EditNoteModal } from './EditNoteModal';
import { EmptyState } from '../common/EmptyState';

const MAX_NOTE_LENGTH = 5000;
const PAGE_SIZE = 50;
const SEARCH_DEBOUNCE_MS = 300;

type FilterType = 'all' | 'today' | 'week';

interface NotesPanelProps {
  className?: string;
  highlightNoteId?: string | null;
  onNoteHighlighted?: () => void;
  onNotesLoaded?: (notes: Note[], hasMore: boolean, loadMore: () => Promise<void>) => void;
}

export function NotesPanel({ className = '', highlightNoteId, onNoteHighlighted, onNotesLoaded }: NotesPanelProps) {
  const [notes, setNotes] = useState<Note[]>([]);
  const [pendingNotes, setPendingNotes] = useState<Note[]>([]);
  const [text, setText] = useState('');
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [cursor, setCursor] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(false);

  // Search and filter state
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  const [activeFilter, setActiveFilter] = useState<FilterType>('all');
  const [composerFocused, setComposerFocused] = useState(false);

  // Edit and delete state
  const [editingNote, setEditingNote] = useState<Note | null>(null);
  const [isEditSaving, setIsEditSaving] = useState(false);
  const [deleteConfirmNote, setDeleteConfirmNote] = useState<Note | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const scrollRef = useRef<HTMLDivElement>(null);
  const highlightRef = useRef<HTMLDivElement>(null);
  const searchTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const mountedRef = useRef(true);
  const loadMoreRef = useRef<(() => Promise<void>) | null>(null);
  const initialLoadRef = useRef(false);
  const loadingRef = useRef(false);
  const loadingMoreRef = useRef(false);
  const { showToast } = useToast();

  // Track mounted state for cleanup
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  // Debounce search input
  useEffect(() => {
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }
    searchTimeoutRef.current = setTimeout(() => {
      setDebouncedSearch(searchQuery);
    }, SEARCH_DEBOUNCE_MS);

    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, [searchQuery]);

  const trimmed = text.trim();
  const canSubmit = useMemo(
    () => trimmed.length > 0 && trimmed.length <= MAX_NOTE_LENGTH && !saving,
    [trimmed, saving]
  );

  const loadNotes = useCallback(async (loadCursor?: string, append = false) => {
    // Guard against concurrent requests using refs to avoid stale closures
    if (append && loadingMoreRef.current) return;
    if (!append && loadingRef.current) return;

    // Update both ref and state
    if (append) {
      loadingMoreRef.current = true;
      setLoadingMore(true);
    } else {
      loadingRef.current = true;
      setLoading(true);
    }
    setError(null);

    try {
      const response = await listNotes(loadCursor, PAGE_SIZE);

      // Prevent state updates if component unmounted during fetch
      if (!mountedRef.current) return;

      const normalized = response.notes.map(normalizeNote);

      if (append) {
        setNotes(prev => [...prev, ...normalized]);
      } else {
        setNotes(normalized);
      }

      setCursor(response.cursor);
      setHasMore(response.hasMore);
    } catch (err) {
      // Prevent state updates if component unmounted during fetch
      if (!mountedRef.current) return;

      const message = err instanceof ApiRequestError
        ? err.getUserMessage()
        : err instanceof Error ? err.message : 'Failed to load notes';
      setError(message);
      showToast(message, 'error');
    } finally {
      if (mountedRef.current) {
        loadingRef.current = false;
        loadingMoreRef.current = false;
        setLoading(false);
        setLoadingMore(false);
      }
    }
  }, [showToast]);

  const loadMore = useCallback(async () => {
    if (cursor && !loadingMoreRef.current && hasMore) {
      await loadNotes(cursor, true);
    }
  }, [cursor, hasMore, loadNotes]);

  // Keep loadMoreRef in sync with the latest loadMore function
  useEffect(() => {
    loadMoreRef.current = loadMore;
  }, [loadMore]);

  // Stable wrapper function that always calls the latest loadMore
  // This prevents the parent from re-rendering when loadMore changes
  const stableLoadMore = useCallback(async () => {
    await loadMoreRef.current?.();
  }, []);

  // Notify parent when notes change - uses stableLoadMore to prevent flicker
  // Only notify when loading completes (not during loading) to prevent flickering
  useEffect(() => {
    if (!loading) {
      onNotesLoaded?.(notes, hasMore, stableLoadMore);
    }
  }, [notes, hasMore, loading, stableLoadMore, onNotesLoaded]);

  const handleCreate = useCallback(async () => {
    if (!canSubmit) return;

    // Create optimistic note
    const optimisticNote: Note = {
      id: `temp-${Date.now()}`,
      text: trimmed,
      tenantId: 'public',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    setPendingNotes((prev) => [optimisticNote, ...prev]);
    setText('');
    setSaving(true);
    setError(null);

    try {
      const createdNote = await createNote(trimmed);
      // Replace optimistic note with the real one from API (more efficient than reloading all)
      const normalizedNote = normalizeNote(createdNote);
      setPendingNotes([]);
      setNotes((prev) => [normalizedNote, ...prev]);
      showToast('Saved', 'success');
    } catch (err) {
      const message = err instanceof ApiRequestError
        ? err.getUserMessage()
        : err instanceof Error ? err.message : 'Failed to save note';
      setError(message);
      showToast(message, 'error');
      // Restore text on failure
      setText(optimisticNote.text);
      setPendingNotes([]);
    } finally {
      setSaving(false);
    }
  }, [canSubmit, trimmed, showToast]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        handleCreate();
      }
    },
    [handleCreate]
  );

  // Handle infinite scroll - use ref for loadingMore to avoid stale closure
  const handleScroll = useCallback(() => {
    const scrollEl = scrollRef.current;
    if (!scrollEl || loadingMoreRef.current || !hasMore) return;

    const { scrollTop, scrollHeight, clientHeight } = scrollEl;
    // Load more when within 200px of bottom
    if (scrollHeight - scrollTop - clientHeight < 200) {
      loadMore();
    }
  }, [loadMore, hasMore]);

  // Handle edit note
  const handleEdit = useCallback((note: Note) => {
    setEditingNote(note);
  }, []);

  const handleEditSave = useCallback(async (id: string, newText: string) => {
    setIsEditSaving(true);
    try {
      const updated = await updateNote(id, newText);
      const normalizedNote = normalizeNote(updated);
      setNotes(prev => prev.map(n => n.id === id ? normalizedNote : n));
      setEditingNote(null);
      showToast('Note updated', 'success');
    } catch (err) {
      const message = err instanceof ApiRequestError
        ? err.getUserMessage()
        : err instanceof Error ? err.message : 'Failed to update note';
      showToast(message, 'error');
    } finally {
      setIsEditSaving(false);
    }
  }, [showToast]);

  const handleEditClose = useCallback(() => {
    setEditingNote(null);
  }, []);

  // Handle delete note
  const handleDeleteClick = useCallback((note: Note) => {
    setDeleteConfirmNote(note);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (!deleteConfirmNote) return;

    setIsDeleting(true);
    const noteId = deleteConfirmNote.id;

    try {
      await deleteNote(noteId);
      setNotes(prev => prev.filter(n => n.id !== noteId));
      setDeleteConfirmNote(null);
      showToast('Note deleted', 'success');
    } catch (err) {
      const message = err instanceof ApiRequestError
        ? err.getUserMessage()
        : err instanceof Error ? err.message : 'Failed to delete note';
      showToast(message, 'error');
    } finally {
      setIsDeleting(false);
    }
  }, [deleteConfirmNote, showToast]);

  const handleDeleteCancel = useCallback(() => {
    setDeleteConfirmNote(null);
  }, []);

  // Initial load - only runs once on mount
  useEffect(() => {
    if (!initialLoadRef.current) {
      initialLoadRef.current = true;
      loadNotes();
    }
  }, [loadNotes]);

  // Attach scroll listener
  useEffect(() => {
    const scrollEl = scrollRef.current;
    if (!scrollEl) return;

    scrollEl.addEventListener('scroll', handleScroll);
    return () => scrollEl.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  // Scroll to highlighted note when requested
  useEffect(() => {
    if (highlightNoteId && highlightRef.current) {
      highlightRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
      onNoteHighlighted?.();
    }
  }, [highlightNoteId, onNoteHighlighted]);

  // Filter notes client-side
  const filteredNotes = useMemo(() => {
    const allNotes = [...pendingNotes, ...notes];

    let result = allNotes;

    // Apply time filter
    if (activeFilter !== 'all') {
      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfWeek = new Date(startOfDay);
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());

      result = result.filter(note => {
        if (!note.createdAt) return false;
        if (activeFilter === 'today') {
          return note.createdAt >= startOfDay;
        }
        if (activeFilter === 'week') {
          return note.createdAt >= startOfWeek;
        }
        return true;
      });
    }

    // Apply search filter
    if (debouncedSearch) {
      const query = debouncedSearch.toLowerCase();
      result = result.filter(note =>
        note.text.toLowerCase().includes(query)
      );
    }

    return result;
  }, [pendingNotes, notes, activeFilter, debouncedSearch]);

  const totalLoaded = notes.length;
  const isFiltered = activeFilter !== 'all' || debouncedSearch.length > 0;

  return (
    <div className={`panel ${className}`}>
      <div className="panel-header">
        <h2>
          <FileText size={16} />
          Your Notes
        </h2>
        <div className="text-muted text-xs">
          {loading ? (
            <span className="spinner" />
          ) : isFiltered ? (
            <>{filteredNotes.length} found</>
          ) : (
            <>
              {totalLoaded.toLocaleString()}{hasMore && '+'} notes
            </>
          )}
        </div>
      </div>

      <div className="panel-body">
        {/* Floating Composer */}
        <div className={`composer ${composerFocused || text ? 'composer-expanded' : ''}`}>
          <textarea
            ref={textareaRef}
            className="composer-input"
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={handleKeyDown}
            onFocus={() => setComposerFocused(true)}
            onBlur={() => setComposerFocused(false)}
            placeholder="Capture a thought..."
            aria-label="Write a note"
            disabled={saving}
          />
          <div className="composer-row">
            <div className="composer-hint">
              {trimmed.length > 0 ? (
                <>{trimmed.length.toLocaleString()} / {MAX_NOTE_LENGTH.toLocaleString()}</>
              ) : (
                <span className="keyboard-hint">
                  <kbd>{navigator.platform.includes('Mac') ? '⌘' : 'Ctrl'}</kbd>
                  <kbd>Enter</kbd>
                  <span>to save</span>
                </span>
              )}
            </div>
            <button
              className="btn btn-primary"
              onClick={handleCreate}
              disabled={!canSubmit}
            >
              {saving ? (
                <span className="spinner" />
              ) : (
                <Plus size={16} />
              )}
              Save
            </button>
          </div>
        </div>

        {/* Search and Filters */}
        <div className="notes-toolbar">
          <div className="search-box">
            <Search size={16} />
            <input
              type="text"
              className="search-input"
              placeholder="Search..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              aria-label="Search notes"
            />
            {searchQuery && (
              <button
                className="search-clear"
                onClick={() => setSearchQuery('')}
                aria-label="Clear search"
              >
                ✕
              </button>
            )}
          </div>
          <div className="filter-tabs">
            {(['all', 'today', 'week'] as FilterType[]).map((filter) => (
              <button
                key={filter}
                className={`filter-tab ${activeFilter === filter ? 'active' : ''}`}
                onClick={() => setActiveFilter(filter)}
              >
                {filter === 'all' ? 'All' : filter === 'today' ? 'Today' : 'Week'}
              </button>
            ))}
          </div>
        </div>

        {error && <div className="error-inline">{error}</div>}

        {/* Scrollable Notes List with Infinite Scroll */}
        <div className="notes-scroll" ref={scrollRef}>
          <div className="notes-list" role="list" aria-label="Notes list">
            {loading && notes.length === 0 ? (
              <NoteCardSkeleton count={3} />
            ) : filteredNotes.length === 0 ? (
              <EmptyState type={isFiltered ? 'no-search-results' : 'no-notes'} />
            ) : (
              <>
                {filteredNotes.map((note) => (
                  <div
                    key={note.id}
                    ref={note.id === highlightNoteId ? highlightRef : null}
                  >
                    <NoteCard
                      note={note}
                      isPending={note.id.startsWith('temp-')}
                      isHighlighted={note.id === highlightNoteId}
                      searchQuery={debouncedSearch}
                      onEdit={handleEdit}
                      onDelete={handleDeleteClick}
                    />
                  </div>
                ))}
                {!isFiltered && loadingMore && (
                  <div className="loading-more">
                    <span className="spinner" /> Loading more...
                  </div>
                )}
                {!isFiltered && hasMore && !loadingMore && (
                  <button
                    className="btn load-more-btn"
                    onClick={loadMore}
                  >
                    Load more notes
                  </button>
                )}
              </>
            )}
          </div>
        </div>
      </div>

      {/* Edit Note Modal */}
      <EditNoteModal
        note={editingNote}
        isOpen={!!editingNote}
        isSaving={isEditSaving}
        onSave={handleEditSave}
        onClose={handleEditClose}
      />

      {/* Delete Confirmation Dialog */}
      <ConfirmDialog
        isOpen={!!deleteConfirmNote}
        title="Delete Note"
        message="Are you sure you want to delete this note? This action cannot be undone."
        confirmLabel={isDeleting ? 'Deleting...' : 'Delete'}
        cancelLabel="Cancel"
        variant="danger"
        onConfirm={handleDeleteConfirm}
        onCancel={handleDeleteCancel}
      />
    </div>
  );
}



==================================================
FILE: ./src/hooks/index.ts
==================================================

/**
 * Custom hooks index
 */

export { useChat, type ChatLoadingState } from './useChat';
export { useOnlineStatus } from './useOnlineStatus';
export { useKeyboardShortcuts, commonShortcuts } from './useKeyboardShortcuts';
export { useFocusTrap } from './useFocusTrap';



==================================================
FILE: ./src/hooks/useChat.ts
==================================================

/**
 * useChat hook
 * Manages chat state, message history, and API interactions
 * Supports both streaming and non-streaming modes
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import type { ChatMessage, Source, StreamSource } from '../lib/types';
import { sendChatMessage, sendChatMessageStreaming, ApiRequestError } from '../lib/api';
import { CHAT, STORAGE_KEYS } from '../lib/constants';

export type ChatLoadingState = 'idle' | 'sending' | 'streaming' | 'error';

interface UseChatOptions {
  streaming?: boolean;
}

interface UseChatReturn {
  messages: ChatMessage[];
  loadingState: ChatLoadingState;
  activeSource: Source | null;
  setActiveSource: (source: Source | null) => void;
  sendMessage: (text: string) => Promise<void>;
  retryLastMessage: () => Promise<void>;
  clearChat: () => void;
  cancelStream: () => void;
}

/**
 * Generate a unique message ID
 */
function generateMessageId(): string {
  return `msg-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

/**
 * Load chat history from localStorage
 */
function loadChatHistory(): ChatMessage[] {
  try {
    const stored = localStorage.getItem(STORAGE_KEYS.CHAT_HISTORY);
    if (stored) {
      const messages = JSON.parse(stored) as ChatMessage[];
      // Limit to max history size
      return messages.slice(-CHAT.MAX_HISTORY_MESSAGES);
    }
  } catch {
    // Ignore parse errors
  }
  return [];
}

/**
 * Save chat history to localStorage
 */
function saveChatHistory(messages: ChatMessage[]): void {
  try {
    const toSave = messages.slice(-CHAT.MAX_HISTORY_MESSAGES);
    localStorage.setItem(STORAGE_KEYS.CHAT_HISTORY, JSON.stringify(toSave));
  } catch {
    // Ignore storage errors
  }
}

/**
 * Convert StreamSource to Source by adding default relevance
 */
function streamSourceToSource(ss: StreamSource): Source {
  return {
    ...ss,
    relevance: 0, // Will be updated when done event arrives with full meta
  };
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  // Default to non-streaming mode for better compatibility
  const { streaming = false } = options;

  const [messages, setMessages] = useState<ChatMessage[]>(() => loadChatHistory());
  const [loadingState, setLoadingState] = useState<ChatLoadingState>('idle');
  const [activeSource, setActiveSource] = useState<Source | null>(null);

  // Ref to track the current stream controller
  const streamControllerRef = useRef<AbortController | null>(null);
  // Ref to track the current streaming message ID
  const streamingMessageIdRef = useRef<string | null>(null);

  // Persist messages to localStorage
  useEffect(() => {
    saveChatHistory(messages);
  }, [messages]);

  // Cancel any active stream
  const cancelStream = useCallback(() => {
    if (streamControllerRef.current) {
      streamControllerRef.current.abort();
      streamControllerRef.current = null;
    }
    if (streamingMessageIdRef.current) {
      // Mark streaming message as complete
      setMessages(prev =>
        prev.map(m =>
          m.id === streamingMessageIdRef.current ? { ...m, isStreaming: false } : m
        )
      );
      streamingMessageIdRef.current = null;
    }
    setLoadingState('idle');
  }, []);

  // Send a message (streaming or non-streaming)
  const sendMessage = useCallback(async (text: string) => {
    // Cancel any existing stream
    cancelStream();

    const userMessage: ChatMessage = {
      id: generateMessageId(),
      role: 'user',
      content: text,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);

    if (streaming) {
      // Streaming mode
      const assistantMessageId = generateMessageId();
      streamingMessageIdRef.current = assistantMessageId;

      // Add initial streaming message
      const initialMessage: ChatMessage = {
        id: assistantMessageId,
        role: 'assistant',
        content: '',
        timestamp: new Date(),
        isStreaming: true,
        sources: [],
      };
      setMessages(prev => [...prev, initialMessage]);
      setLoadingState('streaming');

      try {
        const controller = await sendChatMessageStreaming(text, {
          onSources: (sources) => {
            // Update message with sources immediately
            setMessages(prev =>
              prev.map(m =>
                m.id === assistantMessageId
                  ? { ...m, sources: sources.map(streamSourceToSource) }
                  : m
              )
            );
          },
          onToken: (token) => {
            // Append token to content
            setMessages(prev =>
              prev.map(m =>
                m.id === assistantMessageId
                  ? { ...m, content: m.content + token }
                  : m
              )
            );
          },
          onDone: (meta) => {
            // Finalize message with meta
            setMessages(prev =>
              prev.map(m =>
                m.id === assistantMessageId
                  ? { ...m, meta, isStreaming: false }
                  : m
              )
            );
            streamingMessageIdRef.current = null;
            streamControllerRef.current = null;
            setLoadingState('idle');
          },
          onError: (error) => {
            // Update message to show error
            setMessages(prev =>
              prev.map(m =>
                m.id === assistantMessageId
                  ? { ...m, content: error, isError: true, isStreaming: false }
                  : m
              )
            );
            streamingMessageIdRef.current = null;
            streamControllerRef.current = null;
            setLoadingState('error');
          },
        });

        streamControllerRef.current = controller;
      } catch (err) {
        const isApiError = err instanceof ApiRequestError;
        // Update the streaming message to show error
        setMessages(prev =>
          prev.map(m =>
            m.id === assistantMessageId
              ? {
                  ...m,
                  content: isApiError ? err.getUserMessage() : 'Something went wrong. Please try again.',
                  isError: true,
                  isStreaming: false,
                  errorCode: isApiError ? err.status : undefined,
                }
              : m
          )
        );
        streamingMessageIdRef.current = null;
        setLoadingState('error');
      }
    } else {
      // Non-streaming mode
      setLoadingState('sending');

      try {
        const response = await sendChatMessage(text);

        const assistantMessage: ChatMessage = {
          id: generateMessageId(),
          role: 'assistant',
          content: response.answer,
          sources: response.sources,
          contextSources: response.contextSources,
          timestamp: new Date(),
          meta: response.meta,
        };

        setMessages(prev => [...prev, assistantMessage]);
        setLoadingState('idle');
      } catch (err) {
        const isApiError = err instanceof ApiRequestError;
        const errorMessage: ChatMessage = {
          id: generateMessageId(),
          role: 'assistant',
          content: isApiError ? err.getUserMessage() : 'Something went wrong. Please try again.',
          timestamp: new Date(),
          isError: true,
          errorCode: isApiError ? err.status : undefined,
        };

        setMessages(prev => [...prev, errorMessage]);
        setLoadingState('error');
      }
    }
  }, [streaming, cancelStream]);

  // Retry the last failed message
  const retryLastMessage = useCallback(async () => {
    // Find the last user message before the error
    let lastUserMessageIndex = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === 'user') {
        lastUserMessageIndex = i;
        break;
      }
    }
    if (lastUserMessageIndex === -1) return;

    const lastUserMessage = messages[lastUserMessageIndex];

    // Remove BOTH the error message AND the last user message
    // sendMessage will re-add the user message, avoiding duplicates
    setMessages(prev => prev.filter((m, idx) => !m.isError && idx !== lastUserMessageIndex));

    // Re-send using the existing sendMessage logic
    await sendMessage(lastUserMessage.content);
  }, [messages, sendMessage]);

  // Clear all messages
  const clearChat = useCallback(() => {
    cancelStream();
    setMessages([]);
    setActiveSource(null);
    setLoadingState('idle');
    localStorage.removeItem(STORAGE_KEYS.CHAT_HISTORY);
  }, [cancelStream]);

  return {
    messages,
    loadingState,
    activeSource,
    setActiveSource,
    sendMessage,
    retryLastMessage,
    clearChat,
    cancelStream,
  };
}



==================================================
FILE: ./src/hooks/useFocusTrap.ts
==================================================

/**
 * useFocusTrap hook
 * Traps focus within a container for modals and drawers
 */

import { useEffect, useRef, useCallback } from 'react';

const FOCUSABLE_SELECTORS = [
  'button:not([disabled])',
  'a[href]',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
].join(', ');

interface UseFocusTrapOptions {
  enabled?: boolean;
  onEscape?: () => void;
  restoreFocus?: boolean;
}

export function useFocusTrap<T extends HTMLElement>(
  options: UseFocusTrapOptions = {}
) {
  const { enabled = true, onEscape, restoreFocus = true } = options;
  const containerRef = useRef<T>(null);
  const previousActiveElement = useRef<Element | null>(null);

  // Get all focusable elements within the container
  const getFocusableElements = useCallback((): HTMLElement[] => {
    if (!containerRef.current) return [];
    return Array.from(
      containerRef.current.querySelectorAll<HTMLElement>(FOCUSABLE_SELECTORS)
    ).filter(el => el.offsetParent !== null); // Filter hidden elements
  }, []);

  // Handle tab key navigation
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (!enabled || !containerRef.current) return;

    if (event.key === 'Escape' && onEscape) {
      event.preventDefault();
      onEscape();
      return;
    }

    if (event.key !== 'Tab') return;

    const focusableElements = getFocusableElements();
    if (focusableElements.length === 0) return;

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    // Shift+Tab on first element -> go to last
    if (event.shiftKey && document.activeElement === firstElement) {
      event.preventDefault();
      lastElement.focus();
      return;
    }

    // Tab on last element -> go to first
    if (!event.shiftKey && document.activeElement === lastElement) {
      event.preventDefault();
      firstElement.focus();
      return;
    }
  }, [enabled, onEscape, getFocusableElements]);

  // Set up focus trap when enabled
  useEffect(() => {
    if (!enabled || !containerRef.current) return;

    // Store the previously focused element
    previousActiveElement.current = document.activeElement;

    // Focus the first focusable element or the container itself
    const focusableElements = getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
    } else if (containerRef.current) {
      containerRef.current.focus();
    }

    // Add keydown listener
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);

      // Restore focus when trap is disabled
      if (restoreFocus && previousActiveElement.current instanceof HTMLElement) {
        previousActiveElement.current.focus();
      }
    };
  }, [enabled, getFocusableElements, handleKeyDown, restoreFocus]);

  return containerRef;
}



==================================================
FILE: ./src/hooks/useKeyboardShortcuts.ts
==================================================

/**
 * useKeyboardShortcuts hook
 * Handles global keyboard shortcuts
 */

import { useEffect, useCallback } from 'react';
import { FEATURES } from '../lib/constants';

interface KeyboardShortcut {
  key: string;
  ctrl?: boolean;
  meta?: boolean;
  shift?: boolean;
  handler: () => void;
  description: string;
}

interface UseKeyboardShortcutsOptions {
  shortcuts: KeyboardShortcut[];
  enabled?: boolean;
}

/**
 * Check if the event target is an input element
 */
function isInputElement(target: EventTarget | null): boolean {
  if (!target || !(target instanceof HTMLElement)) return false;
  const tagName = target.tagName.toLowerCase();
  return tagName === 'input' || tagName === 'textarea' || target.isContentEditable;
}

export function useKeyboardShortcuts({ shortcuts, enabled = true }: UseKeyboardShortcutsOptions) {
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    // Skip if feature is disabled
    if (!FEATURES.ENABLE_KEYBOARD_SHORTCUTS || !enabled) return;
    
    // Skip if focused on an input (unless Escape)
    if (event.key !== 'Escape' && isInputElement(event.target)) return;

    for (const shortcut of shortcuts) {
      const keyMatches = event.key.toLowerCase() === shortcut.key.toLowerCase();
      const ctrlMatches = !shortcut.ctrl || (event.ctrlKey || event.metaKey);
      const metaMatches = !shortcut.meta || event.metaKey;
      const shiftMatches = !shortcut.shift || event.shiftKey;

      if (keyMatches && ctrlMatches && metaMatches && shiftMatches) {
        event.preventDefault();
        shortcut.handler();
        break;
      }
    }
  }, [shortcuts, enabled]);

  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
}

/**
 * Common shortcut configurations
 */
export const commonShortcuts = {
  escape: (handler: () => void): KeyboardShortcut => ({
    key: 'Escape',
    handler,
    description: 'Close dialog/drawer',
  }),
  
  focusSearch: (handler: () => void): KeyboardShortcut => ({
    key: '/',
    handler,
    description: 'Focus search',
  }),
  
  showHelp: (handler: () => void): KeyboardShortcut => ({
    key: '?',
    shift: true,
    handler,
    description: 'Show keyboard shortcuts',
  }),
  
  newNote: (handler: () => void): KeyboardShortcut => ({
    key: 'n',
    ctrl: true,
    handler,
    description: 'New note',
  }),
};



==================================================
FILE: ./src/hooks/useOnlineStatus.ts
==================================================

/**
 * useOnlineStatus hook
 * Tracks browser online/offline status
 */

import { useState, useEffect, useCallback } from 'react';

interface UseOnlineStatusReturn {
  isOnline: boolean;
  wasOffline: boolean;
  resetWasOffline: () => void;
}

export function useOnlineStatus(): UseOnlineStatusReturn {
  const [isOnline, setIsOnline] = useState(() => 
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );
  const [wasOffline, setWasOffline] = useState(false);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // Keep wasOffline true so we can show "back online" message
    };

    const handleOffline = () => {
      setIsOnline(false);
      setWasOffline(true);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const resetWasOffline = useCallback(() => {
    setWasOffline(false);
  }, []);

  return {
    isOnline,
    wasOffline,
    resetWasOffline,
  };
}



==================================================
FILE: ./src/lib/api.ts
==================================================

/**
 * API client wrapper for AuroraNotes backend
 * Optimized for the AuroraNotes API specification with:
 * - Multi-tenant support via tenantId
 * - Rate limit header parsing
 * - X-Request-Id capture for debugging
 * - Client-side validation
 * - Exponential backoff with retry
 */

import type {
  RawNote,
  HealthResponse,
  ApiError,
  NotesListResponse,
  ChatResponse,
  RateLimitInfo,
  StreamSource,
  StreamEvent,
  ChatMeta,
  FeedbackRating,
  FeedbackResponse,
} from './types';
import { API, NOTES, CHAT } from './constants';

// ============================================
// Configuration
// ============================================

/** Current tenant ID for API requests */
let currentTenantId: string = 'public';

function getApiBase(): string {
  return (import.meta.env.VITE_API_BASE as string) || '';
}

function getApiKey(): string | null {
  return (import.meta.env.VITE_API_KEY as string) || null;
}

function getDefaultHeaders(): Record<string, string> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  const apiKey = getApiKey();
  if (apiKey) {
    headers['Authorization'] = `Bearer ${apiKey}`;
    headers['X-API-Key'] = apiKey;
  }

  return headers;
}

// ============================================
// Tenant Management
// ============================================

/**
 * Set the tenant ID for all subsequent API requests
 * Use this for user-scoped or organization-scoped data isolation
 */
export function setTenantId(tenantId: string): void {
  if (!isValidTenantId(tenantId)) {
    throw new Error('Invalid tenantId format. Must be alphanumeric with hyphens/underscores, max 64 chars.');
  }
  currentTenantId = tenantId;
}

/**
 * Get the current tenant ID
 */
export function getTenantId(): string {
  return currentTenantId;
}

/**
 * Validate tenant ID format per API spec
 * Alphanumeric with hyphens/underscores, max 64 chars
 */
function isValidTenantId(tenantId: string): boolean {
  if (!tenantId || tenantId.length > 64) return false;
  return /^[a-zA-Z0-9_-]+$/.test(tenantId);
}

// ============================================
// Validation Helpers
// ============================================

/**
 * Validate note text before sending to API
 */
export function validateNoteText(text: string): { valid: boolean; error?: string } {
  const trimmed = text.trim();
  if (!trimmed) {
    return { valid: false, error: 'Note text is required' };
  }
  if (trimmed.length > NOTES.MAX_LENGTH) {
    return { valid: false, error: `Note text too long (max ${NOTES.MAX_LENGTH} characters)` };
  }
  return { valid: true };
}

/**
 * Validate chat message before sending to API
 */
export function validateChatMessage(message: string): { valid: boolean; error?: string } {
  const trimmed = message.trim();
  if (!trimmed) {
    return { valid: false, error: 'Message is required' };
  }
  if (trimmed.length > CHAT.MAX_MESSAGE_LENGTH) {
    return { valid: false, error: `Message too long (max ${CHAT.MAX_MESSAGE_LENGTH} characters)` };
  }
  return { valid: true };
}

// ============================================
// Error Handling
// ============================================

/**
 * Custom error class for API errors with enhanced metadata
 */
export class ApiRequestError extends Error {
  status?: number;
  code?: string;
  retryAfterSeconds?: number;
  requestId?: string;

  constructor(
    message: string,
    status?: number,
    code?: string,
    retryAfterSeconds?: number,
    requestId?: string
  ) {
    super(message);
    this.name = 'ApiRequestError';
    this.status = status;
    this.code = code;
    this.retryAfterSeconds = retryAfterSeconds;
    this.requestId = requestId;
  }

  /**
   * Get user-friendly error message based on status code
   */
  getUserMessage(): string {
    switch (this.status) {
      case 400:
        return this.message || 'Invalid request. Please check your input.';
      case 401:
      case 403:
        return 'Authentication error. Please check your API key configuration.';
      case 429:
        return `Too many requests. Please wait ${this.retryAfterSeconds || 30} seconds.`;
      case 503:
        return 'Service temporarily unavailable. Please try again later.';
      case 500:
      default:
        if (this.status && this.status >= 500) {
          return 'The server is experiencing issues. Please try again in a few moments.';
        }
        return this.message || 'An unexpected error occurred.';
    }
  }
}

// ============================================
// Rate Limit Handling
// ============================================

/** Last known rate limit info from API */
let lastRateLimitInfo: RateLimitInfo | null = null;

/**
 * Get the last known rate limit info
 */
export function getRateLimitInfo(): RateLimitInfo | null {
  return lastRateLimitInfo;
}

/**
 * Parse rate limit headers from response
 */
function parseRateLimitHeaders(res: Response): RateLimitInfo | null {
  const limit = res.headers.get('X-RateLimit-Limit');
  const remaining = res.headers.get('X-RateLimit-Remaining');
  const reset = res.headers.get('X-RateLimit-Reset');

  if (limit && remaining && reset) {
    return {
      limit: parseInt(limit, 10),
      remaining: parseInt(remaining, 10),
      resetSeconds: parseInt(reset, 10),
    };
  }
  return null;
}

/**
 * Get X-Request-Id from response for debugging
 */
function getRequestId(res: Response): string | null {
  return res.headers.get('X-Request-Id');
}

// ============================================
// Request Helpers
// ============================================

/**
 * Safe JSON parsing
 */
async function safeJson<T>(res: Response): Promise<T | null> {
  try {
    return await res.json();
  } catch {
    return null;
  }
}

/**
 * Make a single API request attempt
 */
async function singleRequest<T>(
  path: string,
  options: RequestInit,
  timeout: number,
  apiBase: string
): Promise<T> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const res = await fetch(`${apiBase}${path}`, {
      ...options,
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    // Parse and store rate limit info
    const rateLimitInfo = parseRateLimitHeaders(res);
    if (rateLimitInfo) {
      lastRateLimitInfo = rateLimitInfo;
    }

    // Get request ID for debugging
    const requestId = getRequestId(res);

    if (!res.ok) {
      const body = await safeJson<ApiError>(res);

      // For 429, get retryAfter from body (in seconds per API spec)
      const retryAfterSeconds = body?.retryAfter ?? (res.status === 429 ? 30 : undefined);

      const error = new ApiRequestError(
        body?.error || `Request failed: ${res.status}`,
        res.status,
        body?.code,
        retryAfterSeconds,
        requestId ?? undefined
      );

      // Log error with request ID for debugging
      if (requestId) {
        console.error(`API Error [${requestId}]:`, body);
      }

      throw error;
    }

    return await res.json();
  } catch (err) {
    clearTimeout(timeoutId);

    if (err instanceof ApiRequestError) {
      throw err;
    }

    if (err instanceof Error) {
      if (err.name === 'AbortError') {
        throw new ApiRequestError('Request timed out', 0, 'TIMEOUT');
      }
      throw new ApiRequestError(err.message, 0, 'NETWORK_ERROR');
    }

    throw new ApiRequestError('An unexpected error occurred');
  }
}

/**
 * Check if an error is retryable
 */
function isRetryable(error: ApiRequestError): boolean {
  // Retry on network errors, timeouts, and 5xx server errors
  if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT') {
    return true;
  }
  if (error.status && error.status >= 500 && error.status < 600) {
    return true;
  }
  // 429 is retryable (we have retryAfterSeconds from API)
  if (error.status === 429) {
    return true;
  }
  return false;
}

/**
 * Get retry delay for an error (in milliseconds)
 */
function getRetryDelay(error: ApiRequestError, attempt: number): number {
  // If 429 with retryAfterSeconds, convert to ms (capped at 30s for sanity)
  if (error.status === 429 && error.retryAfterSeconds) {
    return Math.min(error.retryAfterSeconds * 1000, API.RETRY.MAX_DELAY);
  }
  // Otherwise exponential backoff: 300ms, 600ms, 1200ms...
  return API.RETRY.BASE_DELAY * Math.pow(2, attempt);
}

/**
 * Make API request with timeout, error handling, and retry for transient failures
 */
async function request<T>(
  path: string,
  options: RequestInit = {},
  timeout: number = API.TIMEOUTS.DEFAULT,
  maxRetries: number = API.RETRY.MAX_RETRIES
): Promise<T> {
  const apiBase = getApiBase();

  if (!apiBase) {
    throw new ApiRequestError(
      'Missing VITE_API_BASE. Add it to .env.local and restart the dev server.',
      0,
      'MISSING_CONFIG'
    );
  }

  let lastError: ApiRequestError | null = null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await singleRequest<T>(path, options, timeout, apiBase);
    } catch (err) {
      if (err instanceof ApiRequestError) {
        lastError = err;

        // Only retry if it's a retryable error and we have retries left
        if (attempt < maxRetries && isRetryable(err)) {
          // Wait before retrying (uses retryAfterMs for 429 or exponential backoff)
          const delay = getRetryDelay(err, attempt);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
      }
      throw err;
    }
  }

  // Should not reach here, but just in case
  throw lastError || new ApiRequestError('Request failed after retries');
}

// ============================================
// API Endpoints
// ============================================

/**
 * Check API health
 * Typical latency: <50ms
 */
export async function getHealth(): Promise<HealthResponse> {
  try {
    const response = await request<HealthResponse>(API.ENDPOINTS.HEALTH, {}, API.TIMEOUTS.HEALTH);
    // Backend returns status: 'healthy' on success
    if (response.status === 'healthy') {
      return response;
    }
    return { ...response, status: 'unhealthy' };
  } catch {
    return { status: 'unhealthy' };
  }
}

/**
 * List notes with pagination
 * Typical latency: 100-300ms
 *
 * @param cursor - Base64 pagination cursor from previous response
 * @param limit - Results per page (1-100, default 50)
 * @param tenantId - Optional tenant ID override (uses current tenant if not provided)
 */
export async function listNotes(
  cursor?: string,
  limit = 50,
  tenantId?: string
): Promise<NotesListResponse> {
  const params = new URLSearchParams();
  params.set('limit', String(Math.min(Math.max(1, limit), 100))); // Clamp 1-100
  if (cursor) params.set('cursor', cursor);
  params.set('tenantId', tenantId || currentTenantId);

  const path = `${API.ENDPOINTS.NOTES}?${params.toString()}`;
  return await request<NotesListResponse>(path);
}

/**
 * Create a new note
 * Typical latency: 200-500ms (includes async chunking for RAG)
 *
 * @param text - Note content (required, max 5000 chars)
 * @param tenantId - Optional tenant ID override
 * @throws {ApiRequestError} If validation fails or server error
 */
export async function createNote(text: string, tenantId?: string): Promise<RawNote> {
  // Client-side validation
  const validation = validateNoteText(text);
  if (!validation.valid) {
    throw new ApiRequestError(validation.error!, 400, 'VALIDATION_ERROR');
  }

  return await request<RawNote>(API.ENDPOINTS.NOTES, {
    method: 'POST',
    headers: getDefaultHeaders(),
    body: JSON.stringify({
      text: text.trim(),
      tenantId: tenantId || currentTenantId,
    }),
  });
}

/**
 * Update an existing note
 *
 * @param id - Note ID
 * @param text - New note content (required, max 5000 chars)
 * @throws {ApiRequestError} If validation fails or server error
 */
export async function updateNote(id: string, text: string): Promise<RawNote> {
  // Client-side validation
  const validation = validateNoteText(text);
  if (!validation.valid) {
    throw new ApiRequestError(validation.error!, 400, 'VALIDATION_ERROR');
  }

  return await request<RawNote>(`${API.ENDPOINTS.NOTES}/${id}`, {
    method: 'PUT',
    headers: getDefaultHeaders(),
    body: JSON.stringify({ text: text.trim() }),
  });
}

/** Response from delete note endpoint */
export interface DeleteNoteResponse {
  success: boolean;
  id: string;
  deletedAt: string;
  chunksDeleted: number;
}

/**
 * Delete a note
 *
 * @param id - Note ID to delete
 * @param tenantId - Optional tenant ID override
 */
export async function deleteNote(id: string, tenantId?: string): Promise<DeleteNoteResponse> {
  const params = new URLSearchParams();
  params.set('tenantId', tenantId || currentTenantId);

  return await request<DeleteNoteResponse>(`${API.ENDPOINTS.NOTES}/${id}?${params.toString()}`, {
    method: 'DELETE',
    headers: getDefaultHeaders(),
  });
}

/**
 * Send a chat message and get RAG-powered response with sources
 * Typical latency: 1000-3500ms (RAG pipeline + LLM generation)
 *
 * @param message - Question to ask (required, max 2000 chars)
 * @param tenantId - Optional tenant ID override
 * @throws {ApiRequestError} If validation fails, rate limited, or server error
 */
export async function sendChatMessage(message: string, tenantId?: string): Promise<ChatResponse> {
  // Client-side validation
  const validation = validateChatMessage(message);
  if (!validation.valid) {
    throw new ApiRequestError(validation.error!, 400, 'VALIDATION_ERROR');
  }

  const response = await request<ChatResponse>(
    API.ENDPOINTS.CHAT,
    {
      method: 'POST',
      headers: getDefaultHeaders(),
      body: JSON.stringify({
        message: message.trim(),
        tenantId: tenantId || currentTenantId,
      }),
    },
    API.TIMEOUTS.CHAT
  );

  // Backward compatibility: convert legacy citations to sources
  if (!response.sources && response.citations) {
    response.sources = response.citations.map((c, idx) => ({
      id: String(idx + 1),
      noteId: c.noteId,
      preview: c.snippet,
      date: formatDateForSource(c.createdAt),
      relevance: c.score,
    }));
    // Also update answer to use new citation format [1] instead of [N1]
    response.answer = response.answer.replace(/\[N(\d+)\]/g, '[$1]');
  }

  return response;
}

/**
 * Format date string for source display
 */
function formatDateForSource(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
  } catch {
    return isoDate;
  }
}

// ============================================
// Streaming Chat
// ============================================

export interface StreamCallbacks {
  onSources?: (sources: StreamSource[]) => void;
  onToken?: (token: string) => void;
  onDone?: (meta: ChatMeta) => void;
  onError?: (error: string) => void;
}

/**
 * Send a chat message with streaming response (SSE)
 * Delivers sources immediately, then streams tokens
 *
 * @param message - Question to ask (required, max 2000 chars)
 * @param callbacks - Event handlers for stream events
 * @param tenantId - Optional tenant ID override
 * @returns AbortController to cancel the stream
 */
export async function sendChatMessageStreaming(
  message: string,
  callbacks: StreamCallbacks,
  tenantId?: string
): Promise<AbortController> {
  const apiBase = getApiBase();

  if (!apiBase) {
    throw new ApiRequestError(
      'Missing VITE_API_BASE. Add it to .env.local and restart the dev server.',
      0,
      'MISSING_CONFIG'
    );
  }

  // Client-side validation
  const validation = validateChatMessage(message);
  if (!validation.valid) {
    throw new ApiRequestError(validation.error!, 400, 'VALIDATION_ERROR');
  }

  const controller = new AbortController();

  try {
    const response = await fetch(`${apiBase}${API.ENDPOINTS.CHAT}`, {
      method: 'POST',
      headers: {
        ...getDefaultHeaders(),
        'Accept': 'text/event-stream',
      },
      body: JSON.stringify({
        message: message.trim(),
        tenantId: tenantId || currentTenantId,
        stream: true,
      }),
      signal: controller.signal,
    });

    // Handle error responses
    if (!response.ok) {
      const body = await safeJson<ApiError>(response);
      const retryAfterSeconds = body?.retryAfter ?? body?.retryAfterMs ? Math.ceil((body?.retryAfterMs || 0) / 1000) : undefined;

      throw new ApiRequestError(
        body?.error || `Request failed: ${response.status}`,
        response.status,
        body?.code,
        retryAfterSeconds,
        getRequestId(response) ?? undefined
      );
    }

    // Process SSE stream
    const reader = response.body?.getReader();
    if (!reader) {
      throw new ApiRequestError('Response body not available', 0, 'STREAM_ERROR');
    }

    const decoder = new TextDecoder();
    let buffer = '';

    // Process stream in background
    (async () => {
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          // Split on newlines - SSE events can be separated by \n or \n\n
          const lines = buffer.split('\n');
          // Keep the last potentially incomplete line in buffer
          buffer = lines.pop() || '';

          for (const line of lines) {
            // Skip empty lines (SSE uses blank lines as event separators)
            if (!line.trim()) continue;
            if (!line.startsWith('data: ')) continue;

            try {
              const event: StreamEvent = JSON.parse(line.slice(6));

              switch (event.type) {
                case 'sources':
                  callbacks.onSources?.(event.sources || []);
                  break;
                case 'token':
                  callbacks.onToken?.(event.content || '');
                  break;
                case 'done':
                  callbacks.onDone?.(event.meta!);
                  break;
                case 'error':
                  callbacks.onError?.(event.error || 'Stream error');
                  break;
              }
            } catch {
              // Skip malformed JSON lines
            }
          }
        }
      } catch (err) {
        if (err instanceof Error && err.name !== 'AbortError') {
          callbacks.onError?.(err.message);
        }
      }
    })();

    return controller;
  } catch (err) {
    if (err instanceof ApiRequestError) {
      throw err;
    }
    if (err instanceof Error) {
      if (err.name === 'AbortError') {
        throw new ApiRequestError('Stream aborted', 0, 'ABORTED');
      }
      throw new ApiRequestError(err.message, 0, 'NETWORK_ERROR');
    }
    throw new ApiRequestError('An unexpected error occurred');
  }
}

// ============================================
// Feedback
// ============================================

/**
 * Submit feedback for a chat response
 *
 * @param requestId - The requestId from chat response meta
 * @param rating - 'up' or 'down'
 * @param comment - Optional feedback comment (max 1000 chars)
 * @param tenantId - Optional tenant ID override
 */
export async function submitFeedback(
  requestId: string,
  rating: FeedbackRating,
  comment?: string,
  tenantId?: string
): Promise<FeedbackResponse> {
  if (!requestId) {
    throw new ApiRequestError('requestId is required', 400, 'VALIDATION_ERROR');
  }

  if (comment && comment.length > 1000) {
    throw new ApiRequestError('Comment too long (max 1000 characters)', 400, 'VALIDATION_ERROR');
  }

  return await request<FeedbackResponse>(
    API.ENDPOINTS.FEEDBACK,
    {
      method: 'POST',
      headers: getDefaultHeaders(),
      body: JSON.stringify({
        requestId,
        rating,
        comment: comment?.trim(),
        tenantId: tenantId || currentTenantId,
      }),
    }
  );
}

/**
 * Get API base URL (for display/copy)
 */
export function getApiBaseUrl(): string {
  return getApiBase();
}



==================================================
FILE: ./src/lib/citations.ts
==================================================

/**
 * Citation/Source parsing and handling utilities
 * Parses [1], [2] citation tokens from RAG responses and maps to source objects
 * Also supports legacy [N1], [N2] format for backward compatibility
 */

import type { Source, Citation, ConfidenceLevel } from './types';

/** Regex pattern to match new citation tokens like [1], [2], etc. */
const SOURCE_PATTERN = /\[(\d+)\]/g;

/** Regex pattern to match legacy citation tokens like [N1], [N2], etc. */
const LEGACY_CITATION_PATTERN = /\[N(\d+)\]/g;

/** Represents a segment of parsed text - either plain text or a source reference */
export interface TextSegment {
  type: 'text' | 'source';
  content: string;
  source?: Source;
  /** @deprecated Use source instead */
  citation?: Citation;
}

/**
 * Parse answer text and identify source tokens [1], [2], etc.
 * Also supports legacy [N1], [N2] format for backward compatibility
 * Returns an array of segments for rendering
 */
export function parseSources(
  text: string,
  sources: Source[] | undefined
): TextSegment[] {
  if (!text) return [];
  if (!sources || sources.length === 0) {
    return [{ type: 'text', content: text }];
  }

  // Build a lookup map for faster access
  const sourceMap = new Map<string, Source>();
  for (const s of sources) {
    sourceMap.set(s.id, s);
  }

  const segments: TextSegment[] = [];
  let lastIndex = 0;

  // Find all source matches
  const matches = text.matchAll(SOURCE_PATTERN);

  for (const match of matches) {
    const fullMatch = match[0]; // e.g., "[1]"
    const id = match[1]; // e.g., "1"
    const matchIndex = match.index!;

    // Add text before this source
    if (matchIndex > lastIndex) {
      segments.push({
        type: 'text',
        content: text.slice(lastIndex, matchIndex),
      });
    }

    // Add source segment
    const source = sourceMap.get(id);
    if (source) {
      segments.push({
        type: 'source',
        content: fullMatch,
        source,
      });
    } else {
      // Source not found in list - render as plain text
      segments.push({
        type: 'text',
        content: fullMatch,
      });
    }

    lastIndex = matchIndex + fullMatch.length;
  }

  // Add remaining text after last source
  if (lastIndex < text.length) {
    segments.push({
      type: 'text',
      content: text.slice(lastIndex),
    });
  }

  return segments;
}

/**
 * Get unique sources referenced in the text
 * Useful for building a summary list of sources
 */
export function getReferencedSources(
  text: string,
  sources: Source[] | undefined
): Source[] {
  if (!text || !sources || sources.length === 0) return [];

  const sourceMap = new Map<string, Source>();
  for (const s of sources) {
    sourceMap.set(s.id, s);
  }

  const referenced: Source[] = [];
  const seen = new Set<string>();

  const matches = text.matchAll(SOURCE_PATTERN);
  for (const match of matches) {
    const id = match[1];
    if (!seen.has(id)) {
      seen.add(id);
      const source = sourceMap.get(id);
      if (source) {
        referenced.push(source);
      }
    }
  }

  return referenced;
}

/**
 * Check if text contains any source tokens [1], [2], etc.
 */
export function hasSources(text: string): boolean {
  SOURCE_PATTERN.lastIndex = 0;
  return SOURCE_PATTERN.test(text);
}

/**
 * Format source preview for display (truncate if needed)
 */
export function formatPreview(preview: string, maxLength = 120): string {
  if (!preview) return '';
  if (preview.length <= maxLength) return preview;
  return preview.slice(0, maxLength).trim() + '…';
}

/**
 * Calculate confidence level from relevance score
 */
export function getConfidenceFromRelevance(relevance: number): ConfidenceLevel {
  if (relevance >= 0.7) return 'high';
  if (relevance >= 0.4) return 'medium';
  if (relevance > 0) return 'low';
  return 'none';
}

// ============================================
// Legacy Support Functions (deprecated)
// ============================================

/**
 * @deprecated Use parseSources instead
 * Parse answer text and identify citation tokens
 */
export function parseCitations(
  text: string,
  citations: Citation[] | undefined
): TextSegment[] {
  if (!text) return [];
  if (!citations || citations.length === 0) {
    return [{ type: 'text', content: text }];
  }

  const citationMap = new Map<string, Citation>();
  for (const c of citations) {
    citationMap.set(c.cid, c);
  }

  const segments: TextSegment[] = [];
  let lastIndex = 0;
  const matches = text.matchAll(LEGACY_CITATION_PATTERN);

  for (const match of matches) {
    const fullMatch = match[0];
    const num = match[1];
    const cid = `N${num}`;
    const matchIndex = match.index!;

    if (matchIndex > lastIndex) {
      segments.push({ type: 'text', content: text.slice(lastIndex, matchIndex) });
    }

    const citation = citationMap.get(cid);
    if (citation) {
      segments.push({ type: 'source', content: fullMatch, citation });
    } else {
      segments.push({ type: 'text', content: fullMatch });
    }

    lastIndex = matchIndex + fullMatch.length;
  }

  if (lastIndex < text.length) {
    segments.push({ type: 'text', content: text.slice(lastIndex) });
  }

  return segments;
}

/**
 * @deprecated Use getReferencedSources instead
 */
export function getReferencedCitations(
  text: string,
  citations: Citation[] | undefined
): Citation[] {
  if (!text || !citations || citations.length === 0) return [];

  const citationMap = new Map<string, Citation>();
  for (const c of citations) {
    citationMap.set(c.cid, c);
  }

  const referenced: Citation[] = [];
  const seen = new Set<string>();

  const matches = text.matchAll(LEGACY_CITATION_PATTERN);
  for (const match of matches) {
    const cid = `N${match[1]}`;
    if (!seen.has(cid)) {
      seen.add(cid);
      const citation = citationMap.get(cid);
      if (citation) {
        referenced.push(citation);
      }
    }
  }

  return referenced;
}

/**
 * @deprecated Use hasSources instead
 */
export function hasCitations(text: string): boolean {
  LEGACY_CITATION_PATTERN.lastIndex = 0;
  return LEGACY_CITATION_PATTERN.test(text);
}

/**
 * @deprecated Use formatPreview instead
 */
export function formatSnippet(snippet: string, maxLength = 200): string {
  if (!snippet) return '';
  if (snippet.length <= maxLength) return snippet;
  return snippet.slice(0, maxLength).trim() + '…';
}

/**
 * @deprecated Use getConfidenceFromRelevance instead
 */
export function getConfidenceLevel(score: number): 'high' | 'medium' | 'low' {
  if (score >= 0.7) return 'high';
  if (score >= 0.4) return 'medium';
  return 'low';
}



==================================================
FILE: ./src/lib/constants.ts
==================================================

/**
 * Application constants and configuration
 * Centralized location for magic numbers and strings
 */

// ===========================================
// API Configuration
// ===========================================

export const API = {
  ENDPOINTS: {
    HEALTH: '/health',
    NOTES: '/notes',
    CHAT: '/chat',
    FEEDBACK: '/feedback',
  },
  TIMEOUTS: {
    DEFAULT: 10000,      // 10 seconds
    HEALTH: 5000,        // 5 seconds
    CHAT: 30000,         // 30 seconds for AI responses
    STREAM: 60000,       // 60 seconds for streaming responses
  },
  RETRY: {
    MAX_RETRIES: 1,
    BASE_DELAY: 300,     // ms
    MAX_DELAY: 30000,    // 30 seconds max for rate limit retry
  },
} as const;

// ===========================================
// Notes Configuration  
// ===========================================

export const NOTES = {
  MAX_LENGTH: 5000,
  PAGE_SIZE: 50,
  SEARCH_DEBOUNCE_MS: 300,
  HIGHLIGHT_DURATION_MS: 2500,
  MAX_SEARCH_PAGES: 10,
} as const;

// ===========================================
// Chat Configuration
// ===========================================

export const CHAT = {
  MAX_MESSAGE_LENGTH: 2000,
  HISTORY_STORAGE_KEY: 'aurora-chat-history',
  MAX_HISTORY_MESSAGES: 100,
} as const;

// ===========================================
// UI Configuration
// ===========================================

export const UI = {
  TOAST_DURATION_MS: 3000,
  ANIMATION: {
    FAST: 150,
    NORMAL: 200,
    SLOW: 300,
  },
  HEALTH_CHECK_INTERVAL_MS: 30000,
  SKELETON_COUNT: 3,
} as const;

// ===========================================
// Storage Keys
// ===========================================

export const STORAGE_KEYS = {
  THEME: 'aurora-theme',
  CHAT_HISTORY: 'aurora-chat-history',
  USER_PREFERENCES: 'aurora-preferences',
} as const;

// ===========================================
// Keyboard Shortcuts
// ===========================================

export const SHORTCUTS = {
  SAVE_NOTE: { key: 'Enter', modifier: 'meta' },
  FOCUS_SEARCH: { key: '/', modifier: null },
  SHOW_HELP: { key: '?', modifier: 'shift' },
  CLOSE_MODAL: { key: 'Escape', modifier: null },
  CLEAR_INPUT: { key: 'Escape', modifier: null },
} as const;

// ===========================================
// Validation
// ===========================================

export const VALIDATION = {
  MIN_SEARCH_LENGTH: 1,
  MAX_SEARCH_LENGTH: 200,
} as const;

// ===========================================
// Feature Flags
// ===========================================

export const FEATURES = {
  ENABLE_MARKDOWN: true,
  ENABLE_CHAT_PERSISTENCE: true,
  ENABLE_NOTE_EDITING: true,
  ENABLE_NOTE_DELETION: true,
  ENABLE_KEYBOARD_SHORTCUTS: true,
  ENABLE_OFFLINE_BANNER: true,
} as const;



==================================================
FILE: ./src/lib/env.ts
==================================================

/**
 * Environment validation and configuration
 * Validates required environment variables at runtime
 */

interface EnvConfig {
  apiBase: string;
  apiKey: string | null;
  isDev: boolean;
  isProd: boolean;
}

interface EnvValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Get environment configuration
 */
export function getEnvConfig(): EnvConfig {
  return {
    apiBase: (import.meta.env.VITE_API_BASE as string) || '',
    apiKey: (import.meta.env.VITE_API_KEY as string) || null,
    isDev: import.meta.env.DEV,
    isProd: import.meta.env.PROD,
  };
}

/**
 * Validate environment configuration
 */
export function validateEnv(): EnvValidationResult {
  const config = getEnvConfig();
  const errors: string[] = [];
  const warnings: string[] = [];

  // Required: API base URL
  if (!config.apiBase) {
    errors.push(
      'VITE_API_BASE is not set. Add it to your .env.local file:\n' +
      'VITE_API_BASE=http://localhost:8787'
    );
  } else if (!isValidUrl(config.apiBase)) {
    errors.push(`VITE_API_BASE is not a valid URL: ${config.apiBase}`);
  }

  // Optional but recommended: API key
  if (!config.apiKey && config.isProd) {
    warnings.push('VITE_API_KEY is not set. API requests may fail if authentication is required.');
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Check if a string is a valid URL
 */
function isValidUrl(str: string): boolean {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}

/**
 * Log environment validation results to console
 */
export function logEnvValidation(): void {
  const result = validateEnv();
  const config = getEnvConfig();

  if (config.isDev) {
    console.group('🔧 Environment Configuration');
    console.log('API Base:', config.apiBase || '(not set)');
    console.log('API Key:', config.apiKey ? '(set)' : '(not set)');
    console.log('Mode:', config.isDev ? 'development' : 'production');
    
    if (result.errors.length > 0) {
      console.error('❌ Errors:');
      result.errors.forEach(err => console.error('  -', err));
    }
    
    if (result.warnings.length > 0) {
      console.warn('⚠️ Warnings:');
      result.warnings.forEach(warn => console.warn('  -', warn));
    }
    
    if (result.isValid && result.warnings.length === 0) {
      console.log('✅ All environment variables are valid');
    }
    
    console.groupEnd();
  }
}

/**
 * Assert environment is valid, throw if not
 */
export function assertEnvValid(): void {
  const result = validateEnv();
  
  if (!result.isValid) {
    throw new Error(
      'Environment configuration is invalid:\n' + 
      result.errors.join('\n')
    );
  }
}



==================================================
FILE: ./src/lib/format.ts
==================================================

/**
 * Formatting utilities for timestamps and notes
 */

import type { RawTimestamp, RawNote, Note } from './types';

/**
 * Convert raw timestamp value to Date object
 */
export function toDate(value: RawTimestamp): Date | null {
  if (!value) return null;
  
  if (typeof value === 'string') {
    const d = new Date(value);
    return isNaN(d.getTime()) ? null : d;
  }
  
  if (typeof value === 'object' && '_seconds' in value) {
    return new Date(value._seconds * 1000);
  }
  
  return null;
}

/**
 * Format a date as relative time (e.g., "Just now", "5m", "2h", "3d")
 */
export function formatRelativeTime(d: Date | null): string {
  if (!d) return '';
  
  try {
    const now = Date.now();
    const diffMs = now - d.getTime();
    const diffMin = Math.floor(diffMs / 60000);
    
    if (diffMin < 1) return 'Just now';
    if (diffMin < 60) return `${diffMin}m`;
    
    const diffHr = Math.floor(diffMin / 60);
    if (diffHr < 24) return `${diffHr}h`;
    
    const diffDay = Math.floor(diffHr / 24);
    if (diffDay < 7) return `${diffDay}d`;
    
    // For older, show short date
    return d.toLocaleDateString(undefined, { 
      month: 'short', 
      day: 'numeric' 
    });
  } catch {
    return '';
  }
}

/**
 * Format a date as full timestamp for tooltips
 */
export function formatFullTimestamp(d: Date | null): string {
  if (!d) return 'Unknown time';
  
  try {
    return d.toLocaleString(undefined, {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
    });
  } catch {
    return 'Unknown time';
  }
}

/**
 * Normalize a raw note from API to consistent format
 */
export function normalizeNote(raw: RawNote): Note {
  return {
    id: raw.id || `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    text: raw.text || '',
    tenantId: raw.tenantId || 'public',
    createdAt: toDate(raw.createdAt),
    updatedAt: toDate(raw.updatedAt),
  };
}

/**
 * Truncate text to specified length with ellipsis
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength).trim() + '…';
}

/**
 * Get short ID for display (first 8 chars)
 */
export function shortId(id: string): string {
  if (!id || id.startsWith('temp-')) return '';
  return id.slice(0, 8);
}



==================================================
FILE: ./src/lib/hooks/useFocusTrap.ts
==================================================

/**
 * Focus trap hook for modal accessibility
 * Traps focus within a container element
 */

import { useEffect, useRef, type RefObject } from 'react';

const FOCUSABLE_ELEMENTS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
].join(', ');

export function useFocusTrap<T extends HTMLElement>(
  isActive: boolean = true
): RefObject<T | null> {
  const containerRef = useRef<T>(null);
  const previousActiveElement = useRef<Element | null>(null);

  useEffect(() => {
    if (!isActive) return;

    const container = containerRef.current;
    if (!container) return;

    // Store the previously focused element
    previousActiveElement.current = document.activeElement;

    // Get all focusable elements
    const getFocusableElements = () => {
      return Array.from(
        container.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENTS)
      ).filter((el) => el.offsetParent !== null);
    };

    // Focus the first focusable element
    const focusableElements = getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
    }

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key !== 'Tab') return;

      const elements = getFocusableElements();
      if (elements.length === 0) return;

      const firstElement = elements[0];
      const lastElement = elements[elements.length - 1];

      if (event.shiftKey) {
        // Shift + Tab
        if (document.activeElement === firstElement) {
          event.preventDefault();
          lastElement.focus();
        }
      } else {
        // Tab
        if (document.activeElement === lastElement) {
          event.preventDefault();
          firstElement.focus();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      
      // Restore focus to the previously focused element
      if (previousActiveElement.current instanceof HTMLElement) {
        previousActiveElement.current.focus();
      }
    };
  }, [isActive]);

  return containerRef;
}

/**
 * Hook to close a modal on Escape key press
 */
export function useEscapeKey(onEscape: () => void, isActive: boolean = true): void {
  useEffect(() => {
    if (!isActive) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        onEscape();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [onEscape, isActive]);
}

/**
 * Hook to prevent body scroll when modal is open
 */
export function useLockBodyScroll(isLocked: boolean = true): void {
  useEffect(() => {
    if (!isLocked) return;

    const originalStyle = window.getComputedStyle(document.body).overflow;
    document.body.style.overflow = 'hidden';

    return () => {
      document.body.style.overflow = originalStyle;
    };
  }, [isLocked]);
}



==================================================
FILE: ./src/lib/ThemeContext.tsx
==================================================

/**
 * Theme Context
 * Provides dark/light mode toggle functionality with localStorage persistence
 * Respects system preference (prefers-color-scheme) as default
 */

import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: Theme) => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

const STORAGE_KEY = 'aurora-theme';

/**
 * Get system color scheme preference
 */
function getSystemTheme(): Theme {
  if (typeof window !== 'undefined' && window.matchMedia) {
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
  }
  return 'light';
}

function getInitialTheme(): Theme {
  // Check localStorage first (user's explicit preference)
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored === 'dark' || stored === 'light') {
      return stored;
    }
  }
  // Fall back to system preference
  return getSystemTheme();
}

interface ThemeProviderProps {
  children: ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(getInitialTheme);
  // Track whether user has explicitly set a preference
  const [hasUserPreference, setHasUserPreference] = useState<boolean>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem(STORAGE_KEY) !== null;
    }
    return false;
  });

  // Apply theme class to document
  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(theme);
    if (hasUserPreference) {
      localStorage.setItem(STORAGE_KEY, theme);
    }
  }, [theme, hasUserPreference]);

  // Listen for system theme changes (only if user hasn't set a preference)
  useEffect(() => {
    if (hasUserPreference) return;

    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

    const handleChange = (e: MediaQueryListEvent) => {
      setThemeState(e.matches ? 'dark' : 'light');
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [hasUserPreference]);

  const toggleTheme = useCallback(() => {
    setHasUserPreference(true);
    setThemeState((prev) => (prev === 'light' ? 'dark' : 'light'));
  }, []);

  const setTheme = useCallback((newTheme: Theme) => {
    setHasUserPreference(true);
    setThemeState(newTheme);
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}



==================================================
FILE: ./src/lib/types.ts
==================================================

/**
 * Shared types for AuroraNotes
 * Types aligned with API specification (2024-12 version)
 */

/** Firestore timestamp shape when serialized from backend */
export type FirestoreTs = { _seconds: number; _nanoseconds?: number };

/** Raw timestamp value that can come from API */
export type RawTimestamp = string | FirestoreTs | undefined | null;

/** Note as returned from API (with raw timestamps) */
export interface RawNote {
  id: string;
  text: string;
  tenantId: string;
  createdAt: string;  // ISO 8601 timestamp
  updatedAt: string;  // ISO 8601 timestamp
}

/** Normalized note with JS Date objects */
export interface Note {
  id: string;
  text: string;
  tenantId: string;
  createdAt: Date | null;
  updatedAt: Date | null;
}

/** Request body for creating a note */
export interface CreateNoteRequest {
  text: string;
  tenantId?: string;
}

/** Request body for chat */
export interface ChatRequest {
  message: string;
  tenantId?: string;
  stream?: boolean;
}

/** Paginated notes list response from API */
export interface NotesListResponse {
  notes: RawNote[];
  cursor: string | null;
  hasMore: boolean;
}

/** Rate limit information from API headers */
export interface RateLimitInfo {
  limit: number;        // Max requests per window
  remaining: number;    // Requests remaining in current window
  resetSeconds: number; // Seconds until window resets
}

// ============================================
// Chat Types (Updated for new API spec)
// ============================================

/** Source in chat response - maps citation markers to source details */
export interface Source {
  id: string;        // "1", "2", etc. - matches [1], [2] in answer
  noteId: string;    // For deep-linking to the original note
  preview: string;   // ~120 char preview of the source
  date: string;      // Human-readable: "Dec 15, 2024"
  relevance: number; // 0-1 confidence score
}

/** Query intent classification */
export type QueryIntent = 'summarize' | 'list' | 'decision' | 'action_item' | 'search' | 'question' | 'creative';

/** Confidence level for chat responses */
export type ConfidenceLevel = 'high' | 'medium' | 'low' | 'none';

/** Enhanced confidence breakdown from API */
export interface EnhancedConfidence {
  overall: number;           // 0-1 overall confidence score
  level: ConfidenceLevel;    // high, medium, low
  isReliable: boolean;       // Whether answer should be trusted
  breakdown?: {
    citationDensity?: number;
    sourceRelevance?: number;
    answerCoherence?: number;
    claimSupport?: number;
  };
}

/** Chat response metadata */
export interface ChatMeta {
  model: string;
  requestId?: string;
  responseTimeMs: number;
  intent: QueryIntent;
  confidence: ConfidenceLevel;
  sourceCount: number;
  debug?: {
    strategy: string;
    candidateCount?: number;
    rerankCount?: number;
    enhancedConfidence?: EnhancedConfidence;
  };
}

/** Chat response from API (new format) */
export interface ChatResponse {
  answer: string;      // Contains [1], [2] citation markers
  sources: Source[];   // Maps citation markers to source details (cited in answer)
  contextSources?: Source[]; // All relevant sources used as context (may not be cited)
  meta: ChatMeta;
  /** @deprecated Use sources instead */
  citations?: Citation[];
}

/** @deprecated Legacy citation format - use Source instead */
export interface Citation {
  cid: string;          // e.g., "N1", "N2"
  noteId: string;
  chunkId: string;
  createdAt: string;    // ISO string
  snippet: string;
  score: number;
}

/** @deprecated Use ChatMeta instead */
export interface RetrievalMeta {
  model: string;
  retrieval: {
    k: number;
    strategy: string;
    candidateCount?: number;
    rerankCount?: number;
    timeMs?: number;
  };
}

/** Chat message for UI state */
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  sources?: Source[];
  contextSources?: Source[]; // All relevant sources used as context (may not be cited)
  meta?: ChatMeta;
  isError?: boolean;
  errorCode?: number;
  isStreaming?: boolean;
  /** @deprecated Use sources instead */
  citations?: Citation[];
}

// ============================================
// Streaming Types
// ============================================

/** Stream event types from SSE */
export type StreamEventType = 'sources' | 'token' | 'done' | 'error';

/** Source event in streaming (without relevance) */
export type StreamSource = Omit<Source, 'relevance'>;

/** Stream event from SSE */
export interface StreamEvent {
  type: StreamEventType;
  content?: string;              // For 'token' events
  sources?: StreamSource[];      // For 'sources' event
  meta?: ChatMeta;               // For 'done' event
  error?: string;                // For 'error' event
}

// ============================================
// Feedback Types
// ============================================

/** Feedback rating options */
export type FeedbackRating = 'up' | 'down';

/** Request body for submitting feedback */
export interface FeedbackRequest {
  requestId: string;         // Required. From chat response meta.requestId
  rating: FeedbackRating;    // Required.
  comment?: string;          // Optional. Max 1000 chars.
  tenantId?: string;
}

/** Feedback response */
export interface FeedbackResponse {
  status: 'recorded';
  requestId: string;
}

// ============================================
// Other Types
// ============================================

/** Health check response */
export interface HealthResponse {
  status: 'healthy' | 'unhealthy';
  timestamp?: string;
  service?: string;
  project?: string;
  version?: string;
}

/** API error response */
export interface ApiError {
  error: string;
  code?: string;
  retryAfter?: number;       // Seconds until retry allowed (for 429 responses)
  retryAfterMs?: number;     // Milliseconds until retry (alternative format)
}

/** Enhanced API response with metadata */
export interface ApiResponse<T> {
  data: T;
  requestId: string | null;
  rateLimit: RateLimitInfo | null;
}



==================================================
FILE: ./src/lib/utils.ts
==================================================

/**
 * Shared utility functions
 * Common helpers used across the application
 */

/**
 * Escape special regex characters in a string
 * Used for safe string matching in search/highlight features
 */
export function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Generate a unique ID
 */
export function generateId(prefix = ''): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).slice(2, 8);
  return prefix ? `${prefix}-${timestamp}-${random}` : `${timestamp}-${random}`;
}

/**
 * Debounce a function
 */
export function debounce<T extends (...args: unknown[]) => unknown>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout> | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn(...args);
      timeoutId = null;
    }, delay);
  };
}

/**
 * Throttle a function
 */
export function throttle<T extends (...args: unknown[]) => unknown>(
  fn: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle = false;
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

/**
 * Clamp a number between min and max
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

/**
 * Check if we're running in a browser environment
 */
export function isBrowser(): boolean {
  return typeof window !== 'undefined';
}

/**
 * Check if the device supports touch
 */
export function isTouchDevice(): boolean {
  if (!isBrowser()) return false;
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

/**
 * Check if the user prefers reduced motion
 */
export function prefersReducedMotion(): boolean {
  if (!isBrowser()) return false;
  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}

/**
 * Copy text to clipboard with fallback
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  if (!isBrowser()) return false;
  
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    }
    
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-9999px';
    document.body.appendChild(textArea);
    textArea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textArea);
    return success;
  } catch {
    return false;
  }
}

/**
 * Format a number with locale-aware separators
 */
export function formatNumber(num: number): string {
  return num.toLocaleString();
}

/**
 * Pluralize a word based on count
 */
export function pluralize(count: number, singular: string, plural?: string): string {
  const word = count === 1 ? singular : (plural || `${singular}s`);
  return `${formatNumber(count)} ${word}`;
}

/**
 * Check if a value is a non-empty string
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === 'string' && value.trim().length > 0;
}

/**
 * Sleep for a given number of milliseconds
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Create a class name string from conditionals
 */
export function cn(...classes: (string | boolean | undefined | null)[]): string {
  return classes.filter(Boolean).join(' ');
}



==================================================
FILE: ./src/main.tsx
==================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


==================================================
FILE: ./src/styles/app.css
==================================================

@import "tailwindcss";

/**
 * AuroraNotes Design System v7.0
 * Tailwind CSS + Custom Properties for theming
 * Red accent theme
 */

/* ============================================
   Theme Variables (CSS Custom Properties)
   ============================================ */
:root,
:root.light {
  /* Brand - Red Theme */
  --color-primary: #dc2626;
  --color-primary-hover: #b91c1c;
  --color-accent: #e11d48;
  --color-accent-hover: #be123c;

  /* Surfaces */
  --color-bg: #ffffff;
  --color-bg-subtle: #fafafa;
  --color-bg-muted: #f5f5f5;
  --color-surface: #ffffff;
  --color-surface-elevated: #ffffff;
  --color-surface-hover: #f9f9f9;

  /* Text */
  --color-text: #171717;
  --color-text-secondary: #525252;
  --color-text-tertiary: #737373;
  --color-text-muted: #a3a3a3;
  --color-muted: #9a9a9a;

  /* Borders */
  --color-border: #e5e5e5;
  --color-border-subtle: #f0f0f0;
  --color-border-strong: #d4d4d4;
  --color-primary-muted: rgba(220, 38, 38, 0.1);

  /* Status Colors */
  --color-success: #16a34a;
  --color-success-bg: #f0fdf4;
  --color-success-border: #bbf7d0;
  --color-danger: #dc2626;
  --color-danger-bg: #fef2f2;
  --color-danger-border: #fecaca;
  --color-warning: #d97706;
  --color-warning-bg: #fffbeb;

  /* AI Accent - Rose/Red gradient */
  --color-ai: #e11d48;
  --color-ai-hover: #be123c;
  --color-ai-bg: #fff1f2;
  --color-ai-border: #fecdd3;
  --color-ai-muted: rgba(225, 29, 72, 0.1);

  /* Brand gradient */
  --brand-aurora: linear-gradient(135deg, #dc2626 0%, #e11d48 100%);

  /* Shadows - Refined, subtle */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.2);
  --shadow-inner: inset 0 2px 4px rgba(0, 0, 0, 0.04);
  --shadow-focus: 0 0 0 3px rgba(220, 38, 38, 0.15);
  --shadow-focus-ai: 0 0 0 3px rgba(225, 29, 72, 0.15);

  /* Focus ring */
  --ring: var(--shadow-focus);
  --ring-ai: var(--shadow-focus-ai);

  /* Radii */
  --radius-xs: 4px;
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  --radius-2xl: 20px;
  --radius-full: 9999px;

  /* Transitions */
  --ease-out: cubic-bezier(0.33, 1, 0.68, 1);
  --ease-in-out: cubic-bezier(0.65, 0, 0.35, 1);
  --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
  --transition-fast: 0.15s var(--ease-out);
  --transition-normal: 0.2s var(--ease-out);
  --transition-slow: 0.3s var(--ease-out);

  /* Typography */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-mono: 'SF Mono', 'JetBrains Mono', ui-monospace, monospace;

  /* Font weights */
  --font-normal: 400;
  --font-medium: 500;
  --font-semibold: 600;
  --font-bold: 700;

  /* Letter spacing */
  --tracking-tighter: -0.03em;
  --tracking-tight: -0.015em;
  --tracking-normal: 0;
  --tracking-wide: 0.015em;

  /* Line heights */
  --leading-none: 1;
  --leading-tight: 1.25;
  --leading-snug: 1.375;
  --leading-normal: 1.5;
  --leading-relaxed: 1.625;

  /* Spacing */
  --space-0: 0;
  --space-0-5: 2px;
  --space-1: 4px;
  --space-1-5: 6px;
  --space-2: 8px;
  --space-2-5: 10px;
  --space-3: 12px;
  --space-4: 16px;
  --space-5: 20px;
  --space-6: 24px;
  --space-8: 32px;
  --space-10: 40px;
  --space-12: 48px;
  --space-16: 64px;
  --space-20: 80px;
}

/* Dark Mode - Premium dark theme with excellent readability */
:root.dark {
  /* Backgrounds - Layered depth with subtle warmth */
  --color-bg: #0c0c0c;
  --color-bg-subtle: #111111;
  --color-bg-muted: #181818;
  --color-surface: #161616;
  --color-surface-elevated: #1c1c1c;
  --color-surface-hover: #222222;

  /* Text - High contrast for readability */
  --color-text: #f5f5f5;
  --color-text-secondary: #b3b3b3;
  --color-text-tertiary: #8a8a8a;
  --color-muted: #666666;

  /* Borders - Subtle but visible */
  --color-border: #2a2a2a;
  --color-border-subtle: #202020;
  --color-border-strong: #3a3a3a;

  /* Primary - Softer red for dark mode */
  --color-primary: #f87171;
  --color-primary-hover: #fca5a5;
  --color-primary-light: rgba(248, 113, 113, 0.18);
  --color-primary-muted: rgba(248, 113, 113, 0.12);

  /* Status colors - Better visibility */
  --color-success: #4ade80;
  --color-success-bg: rgba(74, 222, 128, 0.12);
  --color-success-border: rgba(74, 222, 128, 0.25);
  --color-danger: #f87171;
  --color-danger-bg: rgba(248, 113, 113, 0.12);
  --color-danger-border: rgba(248, 113, 113, 0.25);

  /* AI Accent - Vibrant but readable */
  --color-ai: #f472b6;
  --color-ai-hover: #f9a8d4;
  --color-ai-bg: rgba(244, 114, 182, 0.15);
  --color-ai-border: rgba(244, 114, 182, 0.30);
  --color-ai-muted: rgba(244, 114, 182, 0.12);

  /* Brand gradient - Dark mode optimized */
  --brand-aurora: linear-gradient(135deg, #f87171 0%, #f472b6 100%);

  /* Shadows - Softer for dark mode */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.25);
  --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.35);
  --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.4);
  --shadow-xl: 0 16px 32px rgba(0, 0, 0, 0.45);
  --shadow-2xl: 0 24px 48px rgba(0, 0, 0, 0.5);

  --shadow-focus: 0 0 0 3px rgba(248, 113, 113, 0.25);
  --shadow-focus-ai: 0 0 0 3px rgba(244, 114, 182, 0.25);
}

/* ============================================
   Reset & Base
   ============================================ */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  -webkit-text-size-adjust: 100%;
  font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
}

body {
  min-height: 100vh;
  min-height: 100dvh;
  background: var(--color-bg);
  color: var(--color-text);
  font-family: var(--font-sans);
  font-size: 14px;
  line-height: var(--leading-normal);
  font-weight: var(--font-normal);
  letter-spacing: var(--tracking-normal);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow-x: hidden;
  text-rendering: optimizeLegibility;
  transition: background-color var(--transition-normal), color var(--transition-normal);
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* ============================================
   Typography
   ============================================ */
.text-muted { color: var(--color-muted); }
.text-secondary { color: var(--color-text-secondary); }
.text-tertiary { color: var(--color-text-tertiary); }
.text-primary { color: var(--color-primary); }
.text-sm { font-size: 13px; }
.text-xs { font-size: 11px; letter-spacing: 0.02em; }

.font-medium { font-weight: var(--font-medium); }
.font-semibold { font-weight: var(--font-semibold); }
.font-bold { font-weight: var(--font-bold); }
.font-mono { font-family: var(--font-mono); font-size: 0.9em; }

/* ============================================
   Layout - Clean, spacious
   ============================================ */
.app-shell {
  min-height: 100vh;
  min-height: 100dvh;
  padding: var(--space-4);
  background: var(--color-bg-subtle);
  transition: background-color var(--transition-normal);
}

@media (min-width: 640px) {
  .app-shell {
    padding: var(--space-5);
  }
}

@media (min-width: 1024px) {
  .app-shell {
    padding: var(--space-6);
  }
}

@media (min-width: 1400px) {
  .app-shell {
    padding: var(--space-8);
  }
}

.app-container {
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* ============================================
   Header - Ultra-clean, premium design
   ============================================ */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-4);
  margin-bottom: var(--space-5);
  padding: var(--space-3) var(--space-5);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-xs);
}

@media (min-width: 640px) {
  .app-header {
    padding: var(--space-3) var(--space-6);
  }
}

button.app-title {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  font: inherit;
  border-radius: var(--radius-lg);
  transition: opacity var(--transition-fast);
}

button.app-title:hover {
  opacity: 0.8;
}

button.app-title:focus-visible {
  outline: 2px solid var(--color-ai);
  outline-offset: 4px;
}

.app-logo {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--brand-aurora);
  border-radius: var(--radius-lg);
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
  box-shadow: 0 2px 8px rgba(220, 38, 38, 0.25);
}

.app-logo:hover {
  transform: scale(1.05) rotate(-2deg);
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.35);
}

.app-logo svg {
  width: 20px;
  height: 20px;
  color: white;
}

.app-title h1 {
  font-size: 18px;
  font-weight: var(--font-bold);
  letter-spacing: var(--tracking-tight);
  color: var(--color-text);
  background: var(--brand-aurora);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.app-title .tagline {
  display: none;
}

@media (min-width: 768px) {
  .app-title .tagline {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    color: var(--color-text-tertiary);
    font-size: 13px;
    font-weight: var(--font-medium);
    padding-left: var(--space-4);
    margin-left: var(--space-4);
    border-left: 1px solid var(--color-border);
    letter-spacing: 0.01em;
  }
}

.header-actions {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.header-actions-row {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

/* Status indicator */
.status-indicator {
  display: none;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  font-size: 12px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
  background: var(--color-bg-muted);
  border-radius: var(--radius-full);
  transition: all var(--transition-fast);
}

@media (min-width: 640px) {
  .status-indicator {
    display: flex;
  }
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: var(--radius-full);
  background: var(--color-muted);
  transition: all var(--transition-fast);
}

.status-dot.connected {
  background: var(--color-success);
}

/* Theme toggle button */
.theme-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  padding: 0;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  background: var(--color-surface);
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.theme-toggle:hover {
  background: var(--color-surface-hover);
  color: var(--color-text);
  border-color: var(--color-border-strong);
}

.theme-toggle svg {
  width: 18px;
  height: 18px;
}

/* Main grid */
.main-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-4);
}

@media (min-width: 900px) {
  .main-grid {
    grid-template-columns: 0.9fr 1.1fr;
    gap: var(--space-5);
    align-items: stretch;
  }
}

@media (min-width: 1200px) {
  .main-grid {
    grid-template-columns: 0.85fr 1.15fr;
    gap: var(--space-6);
  }
}

/* ============================================
   Mobile Tabs - Premium segmented control
   ============================================ */
.mobile-tabs {
  display: flex;
  gap: 6px;
  padding: 5px;
  margin-bottom: var(--space-4);
  background: var(--color-bg-muted);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-inner);
}

.mobile-tabs button {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-4);
  font-size: 14px;
  font-weight: var(--font-medium);
  border: none;
  border-radius: var(--radius-lg);
  background: transparent;
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-normal);
}

.mobile-tabs button svg {
  width: 16px;
  height: 16px;
}

.mobile-tabs button:hover:not(.active) {
  color: var(--color-text);
  background: var(--color-surface-hover);
}

.mobile-tabs button.active {
  background: var(--brand-aurora);
  color: white;
  box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
}

.mobile-tabs button:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

@media (min-width: 900px) {
  .mobile-tabs {
    display: none;
  }
}

/* ============================================
   Panels - Premium card design with depth
   ============================================ */
.panel {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 500px;
  max-height: calc(100vh - 160px);
  max-height: calc(100dvh - 160px);
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-md);
}

.panel.hidden {
  display: none;
}

@media (min-width: 900px) {
  .panel.hidden {
    display: flex;
  }

  .panel {
    min-height: 560px;
    max-height: calc(100vh - 140px);
    max-height: calc(100dvh - 140px);
  }
}

.panel-header {
  padding: var(--space-4) var(--space-6);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-4);
  flex-shrink: 0;
  background: var(--color-surface);
}

.panel-header h2 {
  font-size: 14px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  display: flex;
  align-items: center;
  gap: var(--space-2-5);
  letter-spacing: var(--tracking-tight);
}

.panel-header h2 svg {
  width: 16px;
  height: 16px;
  color: var(--color-primary);
}

.panel-body {
  padding: var(--space-5);
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  background: var(--color-bg-subtle);
}

@media (max-width: 640px) {
  .panel-body {
    padding: var(--space-4);
  }
}

/* ============================================
   Buttons - Clean, modern design
   ============================================ */
.btn {
  appearance: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  color: var(--color-text);
  border-radius: var(--radius-md);
  padding: var(--space-2) var(--space-4);
  font-family: inherit;
  font-size: 13px;
  font-weight: var(--font-medium);
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
  user-select: none;
}

.btn svg {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
}

.btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-border-strong);
}

.btn:active {
  background: var(--color-bg-muted);
}

.btn:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

.btn-primary {
  background: var(--brand-aurora);
  border-color: transparent;
  color: white;
  box-shadow: 0 2px 8px rgba(220, 38, 38, 0.25);
  font-weight: var(--font-semibold);
}

.btn-primary:hover {
  filter: brightness(1.08);
  box-shadow: 0 4px 16px rgba(220, 38, 38, 0.35);
  transform: translateY(-2px);
}

.btn-primary:active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(220, 38, 38, 0.25);
}

.btn-icon {
  padding: var(--space-2);
  min-width: 36px;
  min-height: 36px;
}

.btn-ghost {
  background: transparent;
  border-color: transparent;
}

.btn-ghost:hover {
  background: var(--color-bg-muted);
  border-color: transparent;
}

.btn-sm {
  padding: var(--space-1-5) var(--space-3);
  font-size: 12px;
  min-height: 28px;
  border-radius: var(--radius-sm);
}

.btn-sm svg {
  width: 14px;
  height: 14px;
}

/* AI button variant - Gradient with shine */
.btn-ai {
  background: var(--brand-aurora);
  border-color: transparent;
  color: white;
  box-shadow: var(--shadow-sm);
}

.btn-ai:hover {
  filter: brightness(1.1);
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

/* ============================================
   Composer - Premium note creation experience
   ============================================ */
.composer {
  padding-bottom: var(--space-4);
  flex-shrink: 0;
}

.composer-input {
  width: 100%;
  min-height: 72px;
  max-height: 180px;
  resize: none;
  padding: var(--space-4);
  border-radius: var(--radius-xl);
  border: 1.5px solid var(--color-border);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 15px;
  line-height: var(--leading-relaxed);
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-sm);
}

/* Expanded composer state */
.composer-expanded .composer-input {
  min-height: 120px;
}

.composer-input::placeholder {
  color: var(--color-muted);
  font-weight: var(--font-normal);
}

.composer-input:hover {
  border-color: var(--color-border-strong);
  box-shadow: var(--shadow-md);
}

.composer-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--shadow-md), var(--ring);
  background: var(--color-surface-elevated);
}

.composer-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  margin-top: var(--space-3);
}

.composer-hint {
  color: var(--color-muted);
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.keyboard-hint {
  display: flex;
  align-items: center;
  gap: 4px;
  opacity: 0.7;
}

.keyboard-hint span {
  margin-left: 2px;
}

.composer-hint kbd {
  padding: 2px 6px;
  margin: 0 2px;
  border-radius: var(--radius-xs);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
}

/* ============================================
   Notes List - Clean, scannable
   ============================================ */
.notes-scroll {
  flex: 1;
  overflow-y: auto;
  margin-top: var(--space-3);
  scroll-behavior: smooth;
  padding-right: 4px;
}

.notes-scroll::-webkit-scrollbar {
  width: 6px;
}

.notes-scroll::-webkit-scrollbar-track {
  background: transparent;
}

.notes-scroll::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-full);
}

.notes-scroll::-webkit-scrollbar-thumb:hover {
  background: var(--color-border-strong);
}

.notes-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.note-card {
  padding: var(--space-4) var(--space-5);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  border-radius: var(--radius-xl);
  cursor: pointer;
  transition: all var(--transition-normal);
  position: relative;
  box-shadow: var(--shadow-sm);
}

.note-card::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 0;
  background: var(--brand-aurora);
  border-radius: 0 var(--radius-full) var(--radius-full) 0;
  transition: height var(--transition-fast);
}

.note-card:hover {
  border-color: var(--color-border-strong);
  background: var(--color-surface-elevated);
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.note-card:hover::before {
  height: 60%;
}

.note-card:hover .note-actions {
  opacity: 1;
}

.note-text {
  font-size: 14px;
  line-height: var(--leading-relaxed);
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--color-text);
}

.note-text.clamped {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.note-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  margin-top: var(--space-3);
  padding-top: var(--space-3);
  border-top: 1px solid var(--color-border-subtle);
  color: var(--color-muted);
  font-size: 12px;
}

.note-time {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--color-text-tertiary);
}

.note-time svg {
  width: 12px;
  height: 12px;
}

.note-id {
  opacity: 0;
  font-family: var(--font-mono);
  font-size: 10px;
  padding: 2px 6px;
  background: var(--color-bg-muted);
  border-radius: var(--radius-xs);
  color: var(--color-muted);
  transition: opacity var(--transition-fast);
}

.note-card:hover .note-id {
  opacity: 1;
}

.note-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.note-actions .btn-icon {
  min-width: 28px;
  min-height: 28px;
  padding: 6px;
}

/* Pending state */
.note-card.pending {
  opacity: 0.6;
  border-style: dashed;
}

/* Empty state */
.empty-state {
  padding: var(--space-12) var(--space-6);
  text-align: center;
  color: var(--color-text-tertiary);
  font-size: 14px;
}

.empty-state-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-12) var(--space-6);
  text-align: center;
}

.empty-state-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 64px;
  height: 64px;
  margin-bottom: var(--space-4);
  border-radius: var(--radius-full);
  background: var(--color-bg-muted);
  color: var(--color-text-tertiary);
}

.empty-state-title {
  margin: 0 0 var(--space-2) 0;
  font-size: var(--text-base);
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
}

.empty-state-description {
  margin: 0;
  font-size: var(--text-sm);
  color: var(--color-text-tertiary);
  max-width: 240px;
  line-height: var(--leading-relaxed);
}

/* Skeleton */
.skeleton {
  height: 80px;
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  position: relative;
  overflow: hidden;
}

.skeleton::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, var(--color-bg-muted), transparent);
  background-size: 200% 100%;
  animation: shimmer 1.5s ease-in-out infinite;
}

.skeleton + .skeleton {
  margin-top: var(--space-2);
}

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* Note Card Skeleton - matches NoteCard layout */
.note-card-skeleton {
  padding: var(--space-4);
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
}

.note-card-skeleton + .note-card-skeleton {
  margin-top: var(--space-2);
}

.skeleton-text {
  margin-bottom: var(--space-3);
}

.skeleton-line {
  height: 14px;
  border-radius: var(--radius-sm);
  background: var(--color-bg-muted);
  position: relative;
  overflow: hidden;
}

.skeleton-line::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, var(--color-surface), transparent);
  background-size: 200% 100%;
  animation: shimmer 1.5s ease-in-out infinite;
}

.skeleton-line + .skeleton-line {
  margin-top: var(--space-2);
}

.skeleton-line-full {
  width: 100%;
}

.skeleton-line-medium {
  width: 65%;
}

.skeleton-meta {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.skeleton-time {
  width: 60px;
  height: 12px;
  border-radius: var(--radius-sm);
  background: var(--color-bg-muted);
}

.skeleton-id {
  width: 40px;
  height: 12px;
  border-radius: var(--radius-sm);
  background: var(--color-bg-muted);
}

/* ============================================
   Chat Panel - AI-focused design
   ============================================ */
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 320px;
}

.chat-suggestions {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-2);
  padding-bottom: var(--space-4);
}

@media (max-width: 480px) {
  .chat-suggestions {
    grid-template-columns: 1fr;
  }
}

.suggestion-chip {
  display: flex;
  align-items: center;
  gap: var(--space-2-5);
  padding: var(--space-3) var(--space-4);
  font-size: 13px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  cursor: pointer;
  transition: all var(--transition-normal);
  text-align: left;
  box-shadow: var(--shadow-xs);
}

.suggestion-icon {
  flex-shrink: 0;
  color: var(--color-muted);
  transition: color var(--transition-fast);
}

.suggestion-chip:hover .suggestion-icon {
  color: var(--color-ai);
}

.suggestion-chip:hover {
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-color: var(--color-ai-border);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.suggestion-chip:active {
  transform: translateY(0);
}

.suggestion-chip:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  scroll-behavior: smooth;
  padding-right: 4px;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: transparent;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-full);
}

.chat-empty {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: var(--space-10);
  color: var(--color-muted);
}

.chat-empty-icon {
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: var(--space-6);
  background: var(--brand-aurora);
  border-radius: var(--radius-2xl);
  box-shadow: 0 8px 32px rgba(220, 38, 38, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
  animation: gentle-float 4s ease-in-out infinite;
}

@keyframes gentle-float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-6px); }
}

.chat-empty-icon svg {
  width: 36px;
  height: 36px;
  color: white;
}

.chat-empty h3 {
  margin-bottom: var(--space-3);
  font-size: 20px;
  font-weight: var(--font-bold);
  color: var(--color-text);
  letter-spacing: var(--tracking-tight);
}

.chat-empty p {
  font-size: 15px;
  max-width: 320px;
  color: var(--color-text-secondary);
  line-height: var(--leading-relaxed);
}

.chat-input-area {
  display: flex;
  flex-direction: column;
  gap: 0;
  padding-top: var(--space-4);
  margin-top: auto;
}

.chat-input {
  flex: 1;
  padding: var(--space-3) var(--space-4);
  border: 1.5px solid var(--color-border);
  border-radius: var(--radius-xl);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 14px;
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-sm);
}

.chat-input:hover {
  border-color: var(--color-border-strong);
  box-shadow: var(--shadow-md);
}

.chat-input:focus {
  outline: none;
  border-color: var(--color-ai);
  box-shadow: var(--shadow-md), var(--ring-ai);
  background: var(--color-surface-elevated);
}

.chat-input:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chat-input::placeholder {
  color: var(--color-muted);
}

.chat-input.input-error {
  border-color: var(--color-danger);
}

.chat-input-row {
  display: flex;
  gap: var(--space-2);
  flex: 1;
}

.rate-limit-notice {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  background: var(--color-warning-bg, rgba(234, 179, 8, 0.1));
  border: 1px solid var(--color-warning, #eab308);
  border-radius: var(--radius-md);
  color: var(--color-warning, #eab308);
  font-size: 13px;
  text-align: center;
  margin-bottom: var(--space-2);
}

.chat-char-count {
  font-size: 12px;
  color: var(--color-muted);
  text-align: right;
  padding-top: var(--space-1);
}

.chat-char-count.over-limit {
  color: var(--color-danger);
  font-weight: 500;
}

/* Chat Messages */
.chat-message {
  display: flex;
  flex-direction: column;
  gap: 4px;
  animation: message-in 0.2s var(--ease-out);
}

.chat-message-meta {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  flex-wrap: wrap;
  padding: 0 var(--space-1);
}

.chat-timestamp {
  font-size: 11px;
  color: var(--color-muted);
}

.chat-copy-btn {
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.chat-message:hover .chat-copy-btn {
  opacity: 1;
}

@keyframes message-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chat-message.user {
  align-items: flex-end;
}

.chat-message.assistant {
  align-items: flex-start;
}

.chat-bubble {
  max-width: 85%;
  padding: var(--space-4) var(--space-5);
  border-radius: var(--radius-xl);
  font-size: 14px;
  line-height: var(--leading-relaxed);
  word-break: break-word;
  box-shadow: var(--shadow-sm);
}

.chat-message.user .chat-bubble {
  background: var(--brand-aurora);
  color: white;
  border-bottom-right-radius: var(--radius-sm);
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.2);
}

.chat-message.assistant .chat-bubble {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  color: var(--color-text);
  border-bottom-left-radius: var(--radius-sm);
  box-shadow: var(--shadow-md);
}

/* Citation badges - Premium pill design */
.citation-link {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  padding: 3px 8px;
  margin: 0 4px;
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
  font-size: 10px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all var(--transition-normal);
  vertical-align: middle;
  box-shadow: var(--shadow-xs);
}

.citation-link:hover {
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-color: var(--color-ai-border);
  transform: scale(1.1);
  box-shadow: var(--shadow-sm);
}

/* Sources summary */
.chat-sources-summary {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  flex-wrap: wrap;
  font-size: 12px;
  color: var(--color-text-tertiary);
  margin-top: var(--space-1);
}

.sources-label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-weight: var(--font-medium);
}

.sources-label svg {
  width: 14px;
  height: 14px;
}

.sources-chips {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.retrieval-time {
  margin-left: auto;
  font-size: 11px;
  font-family: var(--font-mono);
  color: var(--color-muted);
  cursor: help;
}

.source-chip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  padding: 4px 10px;
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
  font-size: 11px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.source-chip:hover,
.source-chip.active {
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-color: var(--color-ai-border);
}

/* New Source Reference Chip (inline in messages) */
.source-chip-wrapper {
  position: relative;
  display: inline;
}

.source-ref-chip {
  display: inline;
  padding: 1px 4px;
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border: none;
  border-radius: var(--radius-sm);
  font-size: inherit;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.source-ref-chip:hover {
  background: var(--color-ai);
  color: white;
}

.source-tooltip {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  width: max-content;
  max-width: 280px;
  padding: var(--space-3);
  background: var(--color-surface-elevated);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  animation: fade-in 0.15s var(--ease-out);
}

.source-tooltip-header {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  margin-bottom: var(--space-2);
}

.source-tooltip-badge {
  padding: 2px 6px;
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-sm);
  font-size: 11px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
}

.source-tooltip-score {
  font-size: 11px;
  color: var(--color-success);
  font-weight: var(--font-medium);
}

.source-tooltip-text {
  margin: 0;
  font-size: 12px;
  line-height: 1.5;
  color: var(--color-text-secondary);
}

.source-tooltip-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: var(--space-2);
  font-size: 11px;
  color: var(--color-text-tertiary);
}

.source-tooltip-hint {
  font-weight: var(--font-medium);
}

/* Source Badge (for source lists) */
.source-badge-chip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
  font-size: 11px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.source-badge-chip:hover,
.source-badge-chip.active {
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-color: var(--color-ai-border);
}

/* Context source badges (not directly cited) */
.source-badge-chip.context {
  background: transparent;
  border-style: dashed;
  color: var(--color-muted);
  opacity: 0.8;
}

.source-badge-chip.context:hover,
.source-badge-chip.context.active {
  background: var(--color-surface-elevated);
  color: var(--color-text);
  opacity: 1;
}

/* Sources label for context sources */
.sources-label-context {
  color: var(--color-muted);
}

/* Confidence Indicator */
.confidence-indicator {
  display: inline-flex;
  align-items: center;
  gap: var(--space-1);
  padding: 4px 8px;
  border-radius: var(--radius-full);
  font-size: 11px;
  font-weight: var(--font-medium);
}

.confidence-indicator.confidence-high {
  background: color-mix(in srgb, var(--color-success) 15%, transparent);
  color: var(--color-success);
}

.confidence-indicator.confidence-medium {
  background: color-mix(in srgb, var(--color-warning) 15%, transparent);
  color: var(--color-warning);
}

.confidence-indicator.confidence-low {
  background: color-mix(in srgb, var(--color-muted) 15%, transparent);
  color: var(--color-muted);
}

.confidence-indicator.confidence-none {
  background: color-mix(in srgb, var(--color-error) 15%, transparent);
  color: var(--color-error);
}

.confidence-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: var(--radius-full);
}

.confidence-badge.confidence-high { color: var(--color-success); }
.confidence-badge.confidence-medium { color: var(--color-warning); }
.confidence-badge.confidence-low { color: var(--color-muted); }
.confidence-badge.confidence-none { color: var(--color-error); }

/* Chat Feedback */
.chat-message-wrapper {
  display: flex;
  flex-direction: column;
}

.chat-feedback {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  padding-left: var(--space-2);
  margin-top: var(--space-1);
}

.chat-feedback .feedback-btn {
  opacity: 0.5;
  transition: opacity var(--transition-fast), color var(--transition-fast);
}

.chat-feedback .feedback-btn:hover {
  opacity: 1;
}

.chat-feedback .feedback-btn:hover:first-of-type {
  color: var(--color-success);
}

.chat-feedback .feedback-btn:hover:last-of-type {
  color: var(--color-error);
}

.feedback-thanks {
  font-size: 11px;
  color: var(--color-text-tertiary);
  font-style: italic;
}

/* Feedback comment form (for thumbs-down) */
.feedback-comment-form {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  width: 100%;
  max-width: 320px;
}

.feedback-comment-input {
  flex: 1;
  min-width: 0;
  padding: var(--space-1-5) var(--space-2);
  font-size: 12px;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  background: var(--color-surface);
  color: var(--color-text);
  transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
}

.feedback-comment-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--shadow-focus);
}

.feedback-comment-input::placeholder {
  color: var(--color-text-tertiary);
}

.feedback-comment-input:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Streaming cursor animation */
.streaming-cursor {
  display: inline-block;
  width: 2px;
  height: 1em;
  background: var(--color-ai);
  margin-left: 2px;
  animation: blink 1s steps(2) infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

.chat-message.streaming .chat-bubble {
  border-color: var(--color-ai-border);
}

/* Response time display */
.response-time {
  font-size: 11px;
  color: var(--color-text-tertiary);
  font-family: var(--font-mono);
}

/* Loading */
.loading-more {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-4);
  color: var(--color-text-tertiary);
  font-size: 13px;
}

.load-more-btn {
  width: 100%;
  margin-top: var(--space-3);
}

/* ============================================
   Searching Note Overlay
   ============================================ */
.searching-note-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(2px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 900;
  animation: fade-in 0.15s var(--ease-out);
}

.searching-note-content {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-4) var(--space-6);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-lg);
  font-size: 14px;
  font-weight: var(--font-medium);
  color: var(--color-text);
}

/* ============================================
   Toast - Clean notifications
   ============================================ */
.toast-container {
  position: fixed;
  bottom: var(--space-5);
  right: var(--space-5);
  z-index: 1100;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  pointer-events: none;
}

@media (max-width: 640px) {
  .toast-container {
    left: var(--space-4);
    right: var(--space-4);
    bottom: var(--space-4);
  }
}

.toast {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3) var(--space-5);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  font-size: 14px;
  font-weight: var(--font-medium);
  color: var(--color-text);
  pointer-events: auto;
  animation: toast-in 0.25s var(--ease-spring);
  backdrop-filter: blur(12px);
}

.toast-icon {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-full);
  flex-shrink: 0;
}

.toast-icon svg {
  width: 14px;
  height: 14px;
}

.toast.success .toast-icon {
  color: var(--color-success);
}

.toast.error .toast-icon {
  color: var(--color-danger);
}

.toast.info .toast-icon {
  color: var(--color-primary);
}

@keyframes toast-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Error display */
.error-inline {
  margin-top: var(--space-3);
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-md);
  background: var(--color-danger-bg);
  border: 1px solid var(--color-danger-border);
  color: var(--color-danger);
  font-size: 13px;
}

/* Spinner */
.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--color-border);
  border-top-color: var(--color-primary);
  border-radius: var(--radius-full);
  animation: spin 0.6s linear infinite;
}

.btn-ai .spinner {
  border-color: rgba(255, 255, 255, 0.3);
  border-top-color: white;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* AI typing indicator */
.ai-typing {
  display: flex;
  align-items: center;
  gap: 4px;
}

.ai-typing span {
  width: 6px;
  height: 6px;
  background: var(--color-ai);
  border-radius: var(--radius-full);
  animation: typing-wave 1.2s ease-in-out infinite;
}

.ai-typing span:nth-child(2) {
  animation-delay: 0.1s;
}

.ai-typing span:nth-child(3) {
  animation-delay: 0.2s;
}

@keyframes typing-wave {
  0%, 60%, 100% {
    opacity: 0.4;
    transform: translateY(0);
  }
  30% {
    opacity: 1;
    transform: translateY(-3px);
  }
}

/* ============================================
   Notes Toolbar - Clean, functional
   ============================================ */
.notes-toolbar {
  display: flex;
  align-items: center;
  gap: 10px;
  padding-bottom: var(--space-4);
}

.search-box {
  position: relative;
  flex: 1;
}

.search-box svg {
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--color-muted);
  pointer-events: none;
  width: 15px;
  height: 15px;
  transition: color var(--transition-fast);
}

.search-box:focus-within svg {
  color: var(--color-primary);
}

.search-input {
  width: 100%;
  padding: 10px 36px 10px 40px;
  border: 1.5px solid transparent;
  border-radius: var(--radius-xl);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 13px;
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-normal);
}

.search-input::placeholder {
  color: var(--color-muted);
}

.search-input:hover {
  box-shadow: var(--shadow-md);
  border-color: var(--color-border);
}

.search-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--shadow-md), var(--ring);
  background: var(--color-surface-elevated);
}

.search-clear {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--color-bg-muted);
  border: none;
  border-radius: var(--radius-full);
  color: var(--color-muted);
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 10px;
  transition: all var(--transition-fast);
}

.search-clear:hover {
  background: var(--color-text);
  color: white;
}

.filter-tabs {
  display: flex;
  gap: 3px;
  padding: 4px;
  background: var(--color-bg-muted);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-inner);
}

.filter-tab {
  padding: 7px 16px;
  font-size: 12px;
  font-weight: var(--font-medium);
  border: none;
  border-radius: var(--radius-lg);
  background: transparent;
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-normal);
}

.filter-tab:hover:not(.active) {
  background: var(--color-surface-hover);
  color: var(--color-text);
}

.filter-tab.active {
  background: var(--color-surface);
  color: var(--color-text);
  box-shadow: var(--shadow-sm);
  font-weight: var(--font-semibold);
}

/* Note highlighted */
.note-card.highlighted {
  border-color: var(--color-ai);
  background: var(--color-ai-bg);
  animation: highlight-pulse 2s ease-out;
}

@keyframes highlight-pulse {
  0% {
    box-shadow: 0 0 0 0 var(--color-ai-muted);
    transform: scale(1.01);
  }
  30% {
    box-shadow: 0 0 0 4px var(--color-ai-muted);
  }
  100% {
    box-shadow: 0 0 0 0 transparent;
    transform: scale(1);
  }
}

.note-card.highlighted::before {
  background: var(--color-ai);
  height: 100%;
}

/* Search highlight */
.search-highlight,
mark.highlight {
  background: rgba(251, 191, 36, 0.25);
  color: inherit;
  padding: 1px 4px;
  border-radius: var(--radius-xs);
}


/* ============================================
   Sources Panel - Side drawer
   ============================================ */
.chat-panel-body {
  display: flex;
  gap: 0;
  height: 100%;
}

.chat-container.with-sources {
  flex: 1;
  min-width: 0;
}

/* Sources Modal Overlay */
.sources-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(12px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-4);
}

.sources-modal {
  width: 100%;
  max-width: 520px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  box-shadow: 0 32px 64px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-scale-in {
  animation: scale-in 0.2s var(--ease-out);
}

.sources-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--color-border-subtle);
}

.sources-modal-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.sources-count {
  padding: 3px 8px;
  font-size: 10px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
}

.sources-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-5);
}

.sources-trust-hint {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 14px;
  margin-bottom: var(--space-4);
  background: rgba(34, 197, 94, 0.15);
  border: 1px solid rgba(34, 197, 94, 0.3);
  border-radius: var(--radius-lg);
  font-size: 13px;
  font-weight: var(--font-medium);
  color: #4ade80;
}

.sources-trust-hint svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.sources-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.source-card {
  padding: var(--space-5);
  border: 1.5px solid var(--color-border);
  border-radius: var(--radius-xl);
  background: var(--color-surface);
  cursor: pointer;
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-xs);
}

.source-card:hover {
  border-color: var(--color-ai);
  background: var(--color-surface-elevated);
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.source-card.selected {
  border-color: var(--color-ai);
  background: var(--color-ai-bg);
  box-shadow: 0 0 0 3px var(--color-ai-muted);
}

.source-card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.source-badge {
  padding: 4px 10px;
  font-size: 11px;
  font-weight: var(--font-bold);
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
}

.source-score {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
}

.source-score svg {
  width: 12px;
  height: 12px;
}

.source-snippet {
  margin: 0 0 12px;
  font-size: 14px;
  line-height: var(--leading-relaxed);
  color: var(--color-text);
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.source-card-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-top: 12px;
  border-top: 1px solid var(--color-border-subtle);
}

.source-card-footer .btn {
  color: var(--color-ai);
  font-weight: var(--font-medium);
}

.source-time {
  font-size: 12px;
  color: var(--color-text-secondary);
}


/* ============================================
   Citation Tooltip - Premium popover
   ============================================ */
.citation-chip-wrapper {
  position: relative;
  display: inline;
}

.citation-chip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  padding: 3px 8px;
  margin: 0 4px;
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
  font-size: 10px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all var(--transition-normal);
  vertical-align: middle;
  box-shadow: var(--shadow-xs);
}

.citation-chip:hover {
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-color: var(--color-ai-border);
  transform: scale(1.1);
  box-shadow: var(--shadow-sm);
}

.citation-tooltip {
  position: absolute;
  bottom: calc(100% + 12px);
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  padding: var(--space-4);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  pointer-events: none;
  animation: tooltip-in 0.2s var(--ease-out);
}

@keyframes tooltip-in {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.citation-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 7px solid transparent;
  border-top-color: var(--color-surface);
  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.05));
}

.citation-tooltip-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.citation-tooltip-badge {
  padding: 4px 10px;
  font-size: 10px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
  background: var(--color-surface-elevated);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-full);
}

.citation-tooltip-score {
  font-size: 10px;
  color: var(--color-muted);
}

.citation-tooltip-text {
  margin: 0 0 10px;
  font-size: 12px;
  line-height: var(--leading-relaxed);
  color: var(--color-text);
}

.citation-tooltip-hint {
  font-size: 10px;
  font-weight: var(--font-medium);
  color: var(--color-ai);
}

/* Chat bubble states */
.chat-bubble-loading {
  display: flex;
  align-items: center;
  gap: 10px;
}

.chat-bubble-error {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  flex-wrap: wrap;
  background: var(--color-danger-bg);
  border: 1px solid var(--color-danger-border);
  color: var(--color-danger);
}

.chat-bubble-error .error-icon {
  flex-shrink: 0;
  margin-top: 2px;
}

.chat-bubble-error .retry-btn {
  margin-left: auto;
  margin-top: 8px;
  color: var(--color-danger);
  border-color: var(--color-danger-border);
}

.chat-bubble-error .retry-btn:hover {
  background: var(--color-danger);
  color: white;
  border-color: var(--color-danger);
}

/* ============================================
   Note Detail Drawer - Premium modal overlay
   ============================================ */
.note-drawer-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-5);
  animation: modal-backdrop-in 0.3s var(--ease-out);
}

@keyframes modal-backdrop-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.note-drawer {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  box-shadow: 0 32px 64px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  max-width: 600px;
  width: 100%;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  animation: modal-in 0.3s var(--ease-spring);
  overflow: hidden;
}

@keyframes modal-in {
  from {
    opacity: 0;
    transform: scale(0.95) translateY(20px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.note-drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--color-border-subtle);
  background: var(--color-surface);
}

.note-drawer-header h3 {
  display: flex;
  align-items: center;
  font-size: 15px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.note-drawer-body {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-6);
  background: var(--color-bg-subtle);
}

.note-detail-text {
  font-size: 15px;
  line-height: 1.8;
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--color-text);
}

.note-drawer-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  border-top: 1px solid var(--color-border-subtle);
  background: var(--color-surface);
}

.note-drawer-meta {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  font-size: 11px;
  color: var(--color-muted);
}

.note-drawer-time {
  display: flex;
  align-items: center;
}

.note-drawer-id {
  font-family: var(--font-mono);
  font-size: 10px;
  padding: 3px 8px;
  background: var(--color-bg-muted);
  color: var(--color-muted);
  border-radius: var(--radius-md);
}

.note-drawer-actions {
  display: flex;
  gap: 8px;
}

/* ============================================
   Utilities & Helpers
   ============================================ */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

*:focus-visible {
  outline: none;
  box-shadow: var(--ring);
}

::selection {
  background: rgba(220, 38, 38, 0.15);
  color: inherit;
}

/* Hover lift effect */
.hover-lift {
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.hover-lift:hover {
  transform: translateY(-2px);
}

/* Stagger animation for lists */
.stagger-children > * {
  animation: fade-slide-in 0.3s var(--ease-out) backwards;
}

.stagger-children > *:nth-child(1) { animation-delay: 0.02s; }
.stagger-children > *:nth-child(2) { animation-delay: 0.04s; }
.stagger-children > *:nth-child(3) { animation-delay: 0.06s; }
.stagger-children > *:nth-child(4) { animation-delay: 0.08s; }
.stagger-children > *:nth-child(5) { animation-delay: 0.10s; }

@keyframes fade-slide-in {
  from {
    opacity: 0;
    transform: translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Animations */
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Subtle glow for AI elements */
.glow-ai {
  box-shadow: 0 0 20px rgba(225, 29, 72, 0.15);
}

/* Gradient text */
.gradient-text {
  background: var(--brand-aurora);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* ============================================
   Mobile Optimizations
   ============================================ */
@media (max-width: 480px) {
  /* Reduce padding on very small screens */
  .app-shell {
    padding: var(--space-2);
  }

  .panel {
    border-radius: var(--radius-lg);
    min-height: 450px;
    max-height: calc(100vh - 140px);
    max-height: calc(100dvh - 140px);
  }

  .panel-header {
    padding: var(--space-3) var(--space-4);
  }

  .panel-body {
    padding: var(--space-3);
  }

  /* Composer optimization */
  .composer-input {
    min-height: 60px;
    font-size: 16px; /* Prevents iOS zoom on focus */
  }

  .composer-row {
    flex-wrap: wrap;
    gap: var(--space-2);
  }

  /* Chat input optimization */
  .chat-input {
    font-size: 16px; /* Prevents iOS zoom on focus */
    padding: var(--space-2) var(--space-3);
  }

  .chat-input-row {
    gap: var(--space-2);
  }

  /* Chat messages */
  .chat-bubble {
    padding: var(--space-3);
    font-size: 14px;
    max-width: 95%;
  }

  .chat-empty {
    padding: var(--space-4);
  }

  .chat-empty h3 {
    font-size: 16px;
  }

  .chat-empty p {
    font-size: 13px;
  }

  /* Suggestions on mobile */
  .chat-suggestions {
    flex-wrap: wrap;
    gap: var(--space-2);
    padding: var(--space-2) 0;
  }

  .suggestion-chip {
    font-size: 12px;
    padding: var(--space-2) var(--space-3);
  }

  /* Note cards */
  .note-card {
    padding: var(--space-3);
  }

  .note-text {
    font-size: 14px;
    line-height: 1.5;
  }

  /* Sources modal - full screen on mobile */
  .sources-modal-overlay {
    padding: 0;
    align-items: flex-end;
  }

  .sources-modal {
    max-width: 100%;
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  .sources-modal-body {
    padding: var(--space-4);
  }

  .source-card {
    padding: var(--space-3);
  }

  /* Note drawer - full screen on mobile */
  .note-drawer-backdrop {
    padding: 0;
    align-items: flex-end;
  }

  .note-drawer {
    max-width: 100%;
    max-height: 90vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  .note-drawer-body {
    padding: var(--space-4);
  }

  /* Citation tooltip - wider on mobile */
  .citation-tooltip {
    width: 220px;
    padding: var(--space-3);
  }

  /* Header simplification */
  .app-header {
    padding: var(--space-2) var(--space-3);
    margin-bottom: var(--space-3);
  }

  .app-logo {
    width: 28px;
    height: 28px;
  }

  .app-title h1 {
    font-size: 16px;
  }

  /* Mobile tabs */
  .mobile-tabs {
    margin-bottom: var(--space-3);
  }

  .mobile-tabs button {
    padding: var(--space-2) var(--space-3);
    font-size: 13px;
  }

  /* Rate limit notice */
  .rate-limit-notice {
    font-size: 12px;
    padding: var(--space-2);
  }

  /* Character count */
  .chat-char-count {
    font-size: 11px;
  }

  /* Toolbar and filters */
  .notes-toolbar {
    flex-direction: column;
    gap: var(--space-2);
  }

  .filter-tabs {
    width: 100%;
    justify-content: space-between;
  }

  .filter-tab {
    flex: 1;
    text-align: center;
  }

  .search-box {
    width: 100%;
  }
}

/* Touch-friendly tap targets */
@media (hover: none) and (pointer: coarse) {
  .btn {
    min-height: 44px;
    min-width: 44px;
  }

  .btn-sm {
    min-height: 36px;
    min-width: 36px;
  }

  .btn-icon {
    min-height: 44px;
    min-width: 44px;
  }

  .filter-tab {
    min-height: 40px;
  }

  .mobile-tabs button {
    min-height: 44px;
  }

  .note-card {
    padding: var(--space-4);
  }

  .citation-chip {
    padding: 4px 10px;
    font-size: 11px;
  }

  .source-chip {
    padding: 6px 12px;
    min-height: 32px;
  }
}

/* Safe area insets for notched devices */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
  .app-shell {
    padding-bottom: calc(var(--space-3) + env(safe-area-inset-bottom));
  }

  .chat-input-area {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .sources-modal,
  .note-drawer {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .toast-container {
    bottom: calc(var(--space-4) + env(safe-area-inset-bottom));
  }
}

/* ============================================
   Additional Component Styles
   ============================================ */

/* Warning toast */
.toast.warning .toast-icon {
  color: var(--color-warning);
}

/* Confidence level styling for source cards */
.source-card.confidence-high {
  border-left: 3px solid var(--color-success);
}

.source-card.confidence-medium {
  border-left: 3px solid var(--color-warning);
}

.source-card.confidence-low {
  border-left: 3px solid var(--color-muted);
}

/* Error Boundary */
.error-boundary {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-6);
  background: var(--color-bg-subtle);
}

.error-boundary-content {
  max-width: 480px;
  text-align: center;
  padding: var(--space-8);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  box-shadow: var(--shadow-lg);
}

.error-boundary-icon {
  width: 64px;
  height: 64px;
  margin: 0 auto var(--space-5);
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-danger-bg);
  color: var(--color-danger);
  border-radius: var(--radius-full);
}

.error-boundary-content h2 {
  font-size: 20px;
  font-weight: var(--font-bold);
  color: var(--color-text);
  margin-bottom: var(--space-3);
}

.error-boundary-content p {
  color: var(--color-text-secondary);
  margin-bottom: var(--space-6);
  line-height: var(--leading-relaxed);
}

.error-boundary-details {
  text-align: left;
  margin-bottom: var(--space-6);
  padding: var(--space-4);
  background: var(--color-bg-muted);
  border-radius: var(--radius-lg);
  font-size: 12px;
}

.error-boundary-details summary {
  cursor: pointer;
  font-weight: var(--font-medium);
  color: var(--color-text-secondary);
  margin-bottom: var(--space-2);
}

.error-boundary-details pre {
  overflow-x: auto;
  white-space: pre-wrap;
  word-break: break-word;
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--color-danger);
}

.error-boundary-actions {
  display: flex;
  gap: var(--space-3);
  justify-content: center;
}

/* Delete button danger style */
.btn-danger {
  color: var(--color-danger);
}

.btn-danger:hover {
  background: var(--color-danger-bg);
  border-color: var(--color-danger-border);
}

/* Skip link for accessibility */
.skip-link {
  position: absolute;
  top: -100px;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--space-3) var(--space-5);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  font-weight: var(--font-medium);
  color: var(--color-text);
  z-index: 9999;
  transition: top var(--transition-fast);
}

.skip-link:focus {
  top: var(--space-4);
  outline: none;
  box-shadow: var(--shadow-lg), var(--ring);
}

/* Offline banner */
.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: var(--space-2) var(--space-4);
  background: var(--color-warning-bg);
  border-bottom: 1px solid var(--color-warning);
  color: var(--color-warning);
  font-size: 13px;
  font-weight: var(--font-medium);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  z-index: 1200;
  animation: slide-down 0.3s var(--ease-out);
}

@keyframes slide-down {
  from {
    transform: translateY(-100%);
  }
  to {
    transform: translateY(0);
  }
}

.offline-banner svg {
  flex-shrink: 0;
}

/* Keyboard shortcuts help modal */
.shortcuts-modal {
  max-width: 400px;
}

.shortcuts-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.shortcut-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-2) 0;
  border-bottom: 1px solid var(--color-border-subtle);
}

.shortcut-item:last-child {
  border-bottom: none;
}

.shortcut-keys {
  display: flex;
  gap: var(--space-1);
}

.shortcut-keys kbd {
  padding: var(--space-1) var(--space-2);
  background: var(--color-bg-muted);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: var(--font-medium);
}

/* Clear chat button */
.clear-chat-btn {
  color: var(--color-text-secondary);
}

.clear-chat-btn:hover {
  color: var(--color-danger);
}

/* Edit note modal */
.edit-note-modal {
  max-width: 600px;
}

.edit-note-textarea {
  width: 100%;
  min-height: 200px;
  padding: var(--space-4);
  border: 1.5px solid var(--color-border);
  border-radius: var(--radius-xl);
  background: var(--color-surface);
  color: var(--color-text);
  font-family: inherit;
  font-size: 15px;
  line-height: var(--leading-relaxed);
  resize: vertical;
  transition: all var(--transition-normal);
}

.edit-note-textarea:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: var(--ring);
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--space-3);
  padding-top: var(--space-4);
  margin-top: var(--space-4);
  border-top: 1px solid var(--color-border-subtle);
}

/* Modal base styles */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-4);
  animation: fade-in 0.2s var(--ease-out);
}

.modal {
  position: relative;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  padding: var(--space-6);
  box-shadow: 0 24px 48px rgba(0, 0, 0, 0.2);
  width: 100%;
}

.modal-close {
  position: absolute;
  top: var(--space-4);
  right: var(--space-4);
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--space-4);
}

.modal-header h2 {
  font-size: 16px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

/* Button variants */
.btn-secondary {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  color: var(--color-text);
}

.btn-secondary:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-border-strong);
}

.btn-warning {
  background: var(--color-warning);
  border-color: transparent;
  color: white;
}

.btn-warning:hover {
  filter: brightness(1.1);
}

/* Confirm dialog */
.confirm-dialog {
  max-width: 400px;
  text-align: center;
}

.confirm-dialog-icon {
  width: 48px;
  height: 48px;
  margin: 0 auto var(--space-4);
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-danger-bg);
  color: var(--color-danger);
  border-radius: var(--radius-full);
}

.confirm-dialog h3 {
  font-size: 16px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  margin-bottom: var(--space-2);
}

.confirm-dialog p {
  color: var(--color-text-secondary);
  margin-bottom: var(--space-5);
}

.confirm-dialog-actions {
  display: flex;
  gap: var(--space-3);
  justify-content: center;
}

/* Keyboard shortcuts modal */
.shortcuts-modal {
  max-width: 420px;
}

.shortcuts-content {
  display: flex;
  flex-direction: column;
  gap: var(--space-5);
}

.shortcuts-section {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.shortcuts-category {
  font-size: var(--text-xs);
  font-weight: var(--font-semibold);
  color: var(--color-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 0;
}

.shortcuts-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-2) 0;
  border-bottom: 1px solid var(--color-border-subtle);
}

.shortcut-item:last-child {
  border-bottom: none;
}

.shortcut-description {
  color: var(--color-text-secondary);
  font-size: var(--text-sm);
}

.shortcut-keys {
  display: flex;
  gap: var(--space-1);
}

.shortcut-key {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  height: 24px;
  padding: 0 var(--space-2);
  background: var(--color-bg-muted);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  font-size: var(--text-xs);
  font-family: var(--font-sans);
  color: var(--color-text-secondary);
  box-shadow: 0 1px 2px var(--color-shadow-sm);
}

/* Improved chat bubble for long-form content */
.chat-bubble {
  line-height: 1.75;
}

/* Markdown content styles */
.markdown-content h1,
.markdown-content h2,
.markdown-content h3 {
  font-weight: var(--font-semibold);
  margin-top: 1em;
  margin-bottom: 0.5em;
  color: var(--color-text);
}

.markdown-content h1 { font-size: 1.5em; }
.markdown-content h2 { font-size: 1.25em; }
.markdown-content h3 { font-size: 1.1em; }

.markdown-content p {
  margin-bottom: 0.75em;
}

.markdown-content ul,
.markdown-content ol {
  margin-bottom: 0.75em;
  padding-left: 1.5em;
}

.markdown-content li {
  margin-bottom: 0.25em;
}

.markdown-content code {
  padding: 2px 6px;
  background: var(--color-bg-muted);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-size: 0.9em;
}

.markdown-content pre {
  padding: var(--space-4);
  background: var(--color-bg-muted);
  border-radius: var(--radius-lg);
  overflow-x: auto;
  margin-bottom: 0.75em;
}

.markdown-content pre code {
  padding: 0;
  background: none;
}

.markdown-content blockquote {
  border-left: 3px solid var(--color-primary);
  padding-left: var(--space-4);
  margin: 0.75em 0;
  color: var(--color-text-secondary);
  font-style: italic;
}

.markdown-content a {
  color: var(--color-primary);
  text-decoration: underline;
}

.markdown-content a:hover {
  text-decoration: none;
}

.markdown-content strong {
  font-weight: var(--font-semibold);
}

.markdown-content em {
  font-style: italic;
}

/* ============================================
   How It Works Landing Page
   ============================================ */
.how-it-works-page {
  min-height: 100vh;
  min-height: 100dvh;
  padding: var(--space-6) var(--space-4);
  background: var(--color-bg);
  overflow-y: auto;
}

@media (min-width: 768px) {
  .how-it-works-page {
    padding: var(--space-10) var(--space-8);
  }
}

.how-it-works-container {
  max-width: 1000px;
  margin: 0 auto;
}

.how-it-works-header {
  text-align: center;
  margin-bottom: var(--space-12);
  position: relative;
}

.how-it-works-logo {
  width: 64px;
  height: 64px;
  margin: 0 auto var(--space-5);
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--brand-aurora);
  border-radius: var(--radius-xl);
  box-shadow: 0 8px 24px rgba(220, 38, 38, 0.3);
}

.how-it-works-logo svg {
  color: white;
}

.how-it-works-header h1 {
  font-size: 32px;
  font-weight: var(--font-bold);
  letter-spacing: var(--tracking-tight);
  margin-bottom: var(--space-3);
  background: var(--brand-aurora);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

@media (min-width: 768px) {
  .how-it-works-header h1 {
    font-size: 42px;
  }
}

.how-it-works-subtitle {
  font-size: 16px;
  color: var(--color-text-secondary);
  max-width: 500px;
  margin: 0 auto;
  line-height: var(--leading-relaxed);
}

.how-it-works-close {
  position: absolute;
  top: 0;
  right: 0;
}

/* Intro Section */
.how-it-works-intro {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  margin-bottom: var(--space-10);
  box-shadow: var(--shadow-md);
}

.how-it-works-intro h2 {
  font-size: 20px;
  font-weight: var(--font-semibold);
  margin-bottom: var(--space-4);
  color: var(--color-text);
}

.how-it-works-intro p {
  font-size: 15px;
  line-height: var(--leading-relaxed);
  color: var(--color-text-secondary);
  margin-bottom: var(--space-6);
}

.how-it-works-intro p strong {
  color: var(--color-primary);
  font-weight: var(--font-semibold);
}

.how-it-works-intro p em {
  color: var(--color-text);
  font-style: normal;
  font-weight: var(--font-medium);
}

.rag-flow {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  flex-wrap: wrap;
}

.rag-flow-item {
  padding: var(--space-2) var(--space-4);
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border: 1px solid var(--color-ai-border);
  border-radius: var(--radius-full);
  font-size: 13px;
  font-weight: var(--font-medium);
}

.rag-flow svg {
  color: var(--color-muted);
  flex-shrink: 0;
}

/* Steps Section */
.how-it-works-steps h2 {
  font-size: 20px;
  font-weight: var(--font-semibold);
  margin-bottom: var(--space-6);
  color: var(--color-text);
  text-align: center;
}

.steps-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-5);
}

@media (min-width: 640px) {
  .steps-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 900px) {
  .steps-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

.how-it-works-step {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  padding: var(--space-6);
  position: relative;
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-sm);
}

.how-it-works-step:hover {
  border-color: var(--color-ai-border);
  box-shadow: var(--shadow-md);
  transform: translateY(-4px);
}

.step-number {
  position: absolute;
  top: var(--space-4);
  right: var(--space-4);
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-bg-muted);
  color: var(--color-text-tertiary);
  border-radius: var(--radius-full);
  font-size: 12px;
  font-weight: var(--font-bold);
  font-family: var(--font-mono);
}

.step-icon {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-radius: var(--radius-lg);
  margin-bottom: var(--space-4);
}

.step-title {
  font-size: 16px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  margin-bottom: var(--space-2);
}

.step-description {
  font-size: 14px;
  color: var(--color-text-secondary);
  line-height: var(--leading-relaxed);
  margin-bottom: var(--space-4);
}

.step-details {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.step-details li {
  display: flex;
  align-items: flex-start;
  gap: var(--space-2);
  font-size: 13px;
  color: var(--color-text-tertiary);
  line-height: var(--leading-snug);
}

.step-details li svg {
  color: var(--color-success);
  flex-shrink: 0;
  margin-top: 2px;
}

/* How It Works Modal Overlay */
.how-it-works-modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 1100;
  background: var(--color-bg);
  overflow-y: auto;
  animation: fade-in 0.2s var(--ease-out);
}

/* Section styling */
.how-it-works-section {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  margin-bottom: var(--space-6);
  box-shadow: var(--shadow-md);
}

.how-it-works-section h2 {
  font-size: 20px;
  font-weight: var(--font-semibold);
  margin-bottom: var(--space-4);
  color: var(--color-text);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.how-it-works-section h2 svg {
  color: var(--color-ai);
}

.section-intro {
  color: var(--color-text-secondary);
  margin-bottom: var(--space-6);
  line-height: var(--leading-relaxed);
}

/* Tech Table */
.tech-table {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.tech-row {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
  padding: var(--space-3) var(--space-4);
  background: var(--color-bg-subtle);
  border-radius: var(--radius-lg);
}

@media (min-width: 640px) {
  .tech-row {
    flex-direction: row;
    align-items: center;
  }
}

.tech-label {
  font-weight: var(--font-semibold);
  color: var(--color-text);
  min-width: 120px;
}

.tech-value {
  color: var(--color-text-secondary);
  font-family: var(--font-mono);
  font-size: 13px;
}

/* Pipeline Steps */
.pipeline-steps {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.pipeline-step {
  background: var(--color-bg-subtle);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  padding: var(--space-5);
}

.pipeline-step-header {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  margin-bottom: var(--space-2);
}

.pipeline-number {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
  font-size: 12px;
  font-weight: var(--font-bold);
}

.pipeline-step-header svg {
  color: var(--color-ai);
}

.pipeline-step-header h3 {
  font-size: 15px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.pipeline-step p {
  color: var(--color-text-secondary);
  font-size: 14px;
  line-height: var(--leading-relaxed);
  margin: 0;
}

.pipeline-step p strong {
  color: var(--color-text);
}

.pipeline-connector {
  display: flex;
  justify-content: center;
  color: var(--color-muted);
  padding: var(--space-1) 0;
}

/* Retrieval Stages */
.retrieval-stages {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.retrieval-stage {
  background: var(--color-bg-subtle);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  padding: var(--space-5);
}

.stage-header {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  margin-bottom: var(--space-3);
}

.stage-badge {
  padding: 4px 10px;
  background: var(--color-ai);
  color: white;
  border-radius: var(--radius-full);
  font-size: 11px;
  font-weight: var(--font-bold);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.stage-header h3 {
  font-size: 16px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
}

.retrieval-stage > p {
  color: var(--color-text-secondary);
  font-size: 14px;
  line-height: var(--leading-relaxed);
  margin: 0 0 var(--space-3) 0;
}

.retrieval-stage > p strong {
  color: var(--color-text);
}

.retrieval-stage ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.retrieval-stage ul li {
  font-size: 14px;
  color: var(--color-text-secondary);
}

.retrieval-stage ul li strong {
  color: var(--color-text);
}

/* Strategy Cards */
.strategy-cards {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-3);
}

@media (min-width: 640px) {
  .strategy-cards {
    grid-template-columns: repeat(3, 1fr);
  }
}

.strategy-card {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  padding: var(--space-4);
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
}

.strategy-card svg {
  color: var(--color-ai);
}

.strategy-card strong {
  font-size: 14px;
  color: var(--color-text);
}

.strategy-card span {
  font-size: 13px;
  color: var(--color-text-tertiary);
  line-height: var(--leading-snug);
}

/* Generation Steps */
.generation-steps {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.generation-step {
  display: flex;
  gap: var(--space-4);
  padding: var(--space-5);
  background: var(--color-bg-subtle);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
}

.generation-step-icon {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-ai-bg);
  color: var(--color-ai);
  border-radius: var(--radius-lg);
  flex-shrink: 0;
}

.generation-step-content {
  flex: 1;
}

.generation-step-content h3 {
  font-size: 15px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  margin-bottom: var(--space-2);
}

.generation-step-content p {
  font-size: 14px;
  color: var(--color-text-secondary);
  line-height: var(--leading-relaxed);
  margin: 0 0 var(--space-3) 0;
}

.generation-step-content p.note {
  font-size: 13px;
  color: var(--color-muted);
  font-style: italic;
  margin-top: var(--space-2);
}

.generation-step-content ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.generation-step-content ul li {
  display: flex;
  align-items: flex-start;
  gap: var(--space-2);
  font-size: 13px;
  color: var(--color-text-secondary);
}

.generation-step-content ul li svg {
  color: var(--color-success);
  flex-shrink: 0;
  margin-top: 2px;
}

.generation-step-content ul li strong {
  color: var(--color-text);
}

/* Decisions Grid */
.decisions-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-3);
}

@media (min-width: 640px) {
  .decisions-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 900px) {
  .decisions-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

.decision-card {
  padding: var(--space-5);
  background: var(--color-bg-subtle);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  transition: border-color var(--transition-normal), transform var(--transition-normal), box-shadow var(--transition-normal);
}

.decision-card:hover {
  border-color: var(--color-ai-border);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.decision-card h4 {
  font-size: 14px;
  font-weight: var(--font-semibold);
  color: var(--color-text);
  margin-bottom: var(--space-2);
}

.decision-card p {
  font-size: 13px;
  color: var(--color-text-tertiary);
  line-height: var(--leading-snug);
  margin: 0;
}

/* Scale Section */
.scale-section {
  text-align: center;
}

.scale-stats {
  display: flex;
  justify-content: center;
  gap: var(--space-8);
  flex-wrap: wrap;
  margin-bottom: var(--space-4);
}

.scale-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-1);
}

.scale-number {
  font-size: 36px;
  font-weight: var(--font-bold);
  background: var(--brand-aurora);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.scale-label {
  font-size: 13px;
  color: var(--color-text-secondary);
  font-weight: var(--font-medium);
}

.scale-note {
  font-size: 13px;
  color: var(--color-muted);
  margin: 0;
}

/* Landing Page Hero CTA */
.landing-hero-cta {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-8) 0;
  margin-bottom: var(--space-6);
}

.btn-lg {
  padding: var(--space-4) var(--space-6);
  font-size: 16px;
  border-radius: var(--radius-xl);
  min-height: 52px;
}

.landing-cta-btn {
  padding: var(--space-4) var(--space-8);
  gap: var(--space-3);
}

.landing-cta-hint {
  font-size: 14px;
  color: var(--color-text-tertiary);
  margin: 0;
}

/* Landing Footer */
.landing-footer {
  display: flex;
  justify-content: center;
  padding: var(--space-10) 0 var(--space-6);
  margin-top: var(--space-6);
  border-top: 1px solid var(--color-border);
}


==================================================
FILE: ./src/test/setup.ts
==================================================

/**
 * Vitest test setup file
 * Configures the testing environment with jsdom and testing-library matchers
 */

import '@testing-library/jest-dom';

// Mock import.meta.env for tests
Object.defineProperty(import.meta, 'env', {
  value: {
    VITE_API_BASE: 'https://test-api.example.com',
    VITE_API_KEY: 'test-api-key',
  },
  writable: true,
});



==================================================
FILE: ./tsconfig.app.json
==================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test.tsx", "src/**/*.spec.ts", "src/**/*.spec.tsx", "src/test"]
}


==================================================
FILE: ./tsconfig.json
==================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


==================================================
FILE: ./tsconfig.node.json
==================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


==================================================
FILE: ./vite.config.ts
==================================================

import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
  },
})


